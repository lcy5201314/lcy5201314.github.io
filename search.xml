<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/18/hello-world/"/>
      <url>/2021/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法实验</title>
      <link href="/2021/11/17/suan-fa-shi-yan/"/>
      <url>/2021/11/17/suan-fa-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><blockquote><p>这其实是为了测试博客，内容随意了。。</p></blockquote><h2 id="问题-A-排列问题"><a href="#问题-A-排列问题" class="headerlink" title="问题 A: 排列问题"></a>问题 A: 排列问题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法，这里采用回溯进行遍历枚举。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;string path;vector&lt;string&gt; result;vector&lt;int&gt; used;void backtrack(string str){if(path.size() == str.size()){result.push_back(path);return;}for(int i=0;i&lt;str.size();i++){if(used[i]){continue;}used[i] = 1;path.push_back(str[i]);backtrack(str);path.pop_back();used[i] = 0;}}int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());used.resize(str.size(),0);backtrack(str);for(auto s : result){cout &lt;&lt; s &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-B-快速幂"><a href="#问题-B-快速幂" class="headerlink" title="问题 B: 快速幂"></a>问题 B: 快速幂</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111172252507.png" alt="20180914130647_85638-16364329703111"></p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">332893414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这里是快速幂的技巧，采用化二进制判断迭代。</p><p>这里代码思路没问题，但得用long long类型</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 100000007;long long mypow(long long n,long long m){long long ans = 1;while(m){if(m &amp; 1){ans = ans * n % mod;}m = m &gt;&gt; 1;n = (n * n) % mod;}return ans;}int main(){int n;while(cin &gt;&gt; n){long long ans = 0;for(int i=1;i&lt;=n;i++){ans = (ans + mypow(i,i)) % mod;}cout &lt;&lt; ans+1 &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());do{cout &lt;&lt; str &lt;&lt; " ";}while(next_permutation(str.begin(),str.end()));return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-C-求第k小"><a href="#问题-C-求第k小" class="headerlink" title="问题 C: 求第k小"></a>问题 C: 求第k小</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>输出一行，输出第k小数。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">5 21 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><a href="https://blog.51cto.com/svenman/1851716">https://blog.51cto.com/svenman/1851716</a></p><p>qsort排序 <a href="https://blog.csdn.net/weixin_41096569/article/details/104771864">https://blog.csdn.net/weixin_41096569/article/details/104771864</a></p><p>不知道为什么c++算法的sort会超时，用c的就可以 过</p><p>这里有一点qsort使用配合数组，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="方法一-使用qsort"><a href="#方法一-使用qsort" class="headerlink" title="方法一 使用qsort"></a>方法一 使用qsort</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int compare (const void * a, const void * b){  return ( *(int*)a - *(int*)b );}int nums[1000011];int main(){int n,k;cin &gt;&gt; n &gt;&gt; k;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}//sort(nums.begin(),nums.end());qsort(nums,n,sizeof(int),compare);cout &lt;&lt; nums[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二-手写sort"><a href="#方法二-手写sort" class="headerlink" title="方法二 手写sort"></a>方法二 手写sort</h4><p>这里输入cin会超时（离谱）就这一点点差距。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std; int a[1000001];   int partition(int a[],int p,int r){    int x=a[r];    int middle=p;    int j;    for(j=p;j&lt;r;j++)    {        if(a[j]&lt;x)        {            if(j!=middle)              swap(a[middle],a[j]);            middle++;        }     }    swap(a[middle],a[j]);    return middle;}   void select(int a[],int p,int r){    if(p&lt;r)    {        int q=partition(a,p,r);        select(a,p,q-1);        select(a,q+1,r);        }}   int main(){    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)        scanf("%d",&amp;a[i]);    select(a,0,n-1);    cout&lt;&lt;a[k-1]&lt;&lt;endl;    return 0;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法三-发现数组sort能过"><a href="#方法三-发现数组sort能过" class="headerlink" title="方法三 发现数组sort能过"></a>方法三 发现数组sort能过</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main(){int n,k;cin&gt;&gt;n&gt;&gt;k;for(int i=0;i&lt;n;i++){cin &gt;&gt; a[i];}sort(a,a+n);cout &lt;&lt; a[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-D-内部收益率"><a href="#问题-D-内部收益率" class="headerlink" title="问题 D: 内部收益率"></a>问题 D: 内部收益率</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="%E5%AE%9E%E9%AA%8C1.assets/20180914131556_63531.png" alt="img"></p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p><img src="%E5%AE%9E%E9%AA%8C1.assets/20180914131642_82198.png" alt="img"></p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">1-1 22-8 6 90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">1.000.50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>二分搜索，模拟逼近</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;while((cin &gt;&gt; n) &amp;&amp; n){vector&lt;int&gt; cf(n+1,0);for(int i=0;i&lt;= n;i++){cin &gt;&gt; cf[i];}double min, max, ans, mid;min = -1.0;        max = 1000000;        while(max - min &gt; 1e-6){ans = cf[0];            mid = (max-min) / 2 + min;            for(int i=1;i&lt;=n;i++){ans += cf[i] / pow(1 + mid, i);}            if(ans &gt; 0)            min = mid;            else            max = mid;}printf("%.2lf\n",mid);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-E-跳台阶"><a href="#问题-E-跳台阶" class="headerlink" title="问题 E: 跳台阶"></a>问题 E: 跳台阶</h2><blockquote><p>时间限制: 1 Sec </p><p>内存限制: 128 MB </p></blockquote><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p><p>所得到的结果模1000000007</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>可以看成初等的动态规划</p><p>dp数组存储</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="方法一-直接dp存储"><a href="#方法一-直接dp存储" class="headerlink" title="方法一 直接dp存储"></a>方法一 直接dp存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}vector&lt;long long&gt; dp(n+1,0);dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[i] = (dp[i-1] + dp[i-2]) % mod;}cout &lt;&lt; dp[n] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二-改进只需要维护3个dp就行了"><a href="#方法二-改进只需要维护3个dp就行了" class="headerlink" title="方法二 改进只需要维护3个dp就行了"></a>方法二 改进只需要维护3个dp就行了</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}int dp[3];dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[2] = (dp[0] + dp[1]) % mod;dp[0] = dp[1];dp[1] = dp[2];}cout &lt;&lt; dp[2] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    int flag=0;    long long x;    for(int i=1;i&lt;=n;i++)    {        scanf("%lld",&amp;x);        flag^=x;    }    if(flag)   printf("Yes\n");    else    printf("No\n");}return 0;</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none"># 问题 L: sort2时间限制: 1 Sec内存限制: 64 MB## 题目描述给你n个整数，请按从大到小的顺序输出其中前m大的数。## 输入每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个都处于区间[-500000,500000]的整数，***整数可能会重复出现\***。## 输出对每组测试数据按从大到小的顺序输出前m大的数。## 样例输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10 5<br>1 2 3 4 5 6 7 7 8 9</p><pre class="line-numbers language-none"><code class="language-none">## 样例输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>9 8 7 7 6</p><pre class="line-numbers language-none"><code class="language-none">## 思路## 代码### 直接sort超时### map超时```c++#include &lt;bits/stdc++.h&gt;using namespace std;int nums[1000001];int main(){int n,m;cin &gt;&gt; n &gt;&gt; m;map&lt;int,int&gt; mp;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];if(mp.find(nums[i]) != mp.end()){mp[nums[i]]++;}mp.insert(pair&lt;int,int&gt;(nums[i],1));}int i = 0;for(auto num : mp){while(num.second){nums[i] = num.first;num.second--;i++;}}for(int i=n-1;i&gt;n-m-1;i--){cout &lt;&lt; nums[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int offset = 500000;int Hash[1000001] = {0};int main(){int m,n;while(cin &gt;&gt; n &gt;&gt; m){for(int i=0;i&lt;n;i++){int x;cin &gt;&gt; x;Hash[x+offset]++;}for(int i=offset;i&gt;=-offset &amp;&amp; m &gt; 0;i--){while(Hash[i+offset] &gt; 0 &amp;&amp; m &gt; 0){cout &lt;&lt; i &lt;&lt; " ";Hash[i+offset]--;m--;}}cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
