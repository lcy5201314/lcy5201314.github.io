<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数学建模总结</title>
      <link href="/2022/01/19/2022-1-19-shu-xue-jian-mo-ru-men/"/>
      <url>/2022/01/19/2022-1-19-shu-xue-jian-mo-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="数学建模介绍"><a href="#数学建模介绍" class="headerlink" title="数学建模介绍"></a>数学建模介绍</h2><h3 id="数学建模是什么"><a href="#数学建模是什么" class="headerlink" title="数学建模是什么"></a>数学建模是什么</h3><p>数学模型是利用系统化的符号和数学表达式对间题的一种抽象描述。数学建模可看作是把问题定义转换为数学模型的过程。 和问题定义相对应，数学模型包括几个主要组成部分：决策变量、环境变量、目标函数和约束条件。决策变量表示决策者可以控制的因素，即可控输入，是需要通过模型求解来确定的模型中的未知变量。环境变量表示决策者不可控的外界因素，即非可控输入，需要在收集数据阶段确定其具体数值，并在模型中以常量表示。目标函数是指描述问题目标的数学方程，而约束条件则是指描述问题中制约和限制因素的数学表达式（等式或不等式）。（这个主要是规划的一种定义） </p><p>简单来说，就是利用数学知识和专业知识解决生活中的问题。这里最常见的有优化模型，预测模型。比如工业流程的优化，最佳策略的选取，数据预测等等，解决这些本质还是利用数学相关的知识。</p><p>个人感觉：数字建模就像一个小的科研经历，可以培养你和科研相关的一些知识，有些数学建模本身其实也是现在科研的一部分。当然这里区分一些数学建模和数学建模比赛，这俩个其实有一点点差距，数学建模应该是严谨的专业的，而数学建模比赛嘛，从个人利益角度出发，比赛就是为了学到东西和获奖，所以，这里也有了一些出入，现实和理想嘛，毕竟不少每一个人的模型都是严谨的准确的，误差可控的，这里一些题目本身其实也是不严谨的，所以一些美化，包装，甚至结果的一些篡改，借鉴等也成了一种获奖的方法。但还是希望大家可以独立思考，争取模型和结果的准确性，完成真正的“数字建模”。</p><h3 id="数学建模比赛"><a href="#数学建模比赛" class="headerlink" title="数学建模比赛"></a>数学建模比赛</h3><ul><li><p>全国大学生数模竞赛CUMCM</p></li><li><p>全国研究生数模竞赛NPGMCM</p></li><li>美国大学生数模竞赛MCM/ICM；</li><li>五一数学建模</li><li>亚太数学建模等等</li></ul><p>这里最主要的是国赛和美赛，美赛和国赛，我感觉是不一样的，国赛分赛区，获奖也取决赛区的强弱，当然国赛获奖更难，国赛不仅对数学建模的思路和方法进行评估，还对模型结果的准确性有一个评估。美赛其实更推荐小白常见，因为美赛更看重思路，一些异想天开，不一样的想法模型很可能就获奖。其他的一些大部分是用来练手吧，多参加多实践才能在比赛中取得好成绩。</p><h3 id="组队分工"><a href="#组队分工" class="headerlink" title="组队分工"></a>组队分工</h3><p>找到建模小伙伴，认真负责，靠谱的人。建模比赛一般都是三天，三天要做出一篇建模论文时间是很紧迫的，三个人一起做会轻松很多，互相鼓励也更不容易放弃。个人觉得靠谱是挑选队友最重要的点，我看过很多队伍比赛会出现突然消失，平常答应很好，比赛突然不见了；还看到过队伍发生内部矛盾而发生撂挑子不干的事故。不用自卑不用盲目寻求大佬队友，成绩好不代表竞赛好，只要队友可以一起学习就可。最好是模拟一两次比赛看队友适不适合。</p><p>然后就得多参加多配合，这里我很感谢有磨合了2年的队友。</p><p>下面介绍一下分工：</p><ol><li>建模</li><li>编程</li><li>写作</li></ol><p>其实这三个不是对立的，最好的状态是队友什么都会，尤其擅长1-2个方向，如果编程和写作不懂建模，拿建模出来的东西很难后续实现，对于数据处理题，有时也需要编程手预处理等给出合理的建议，写作过程中也可能发现模型的不足，进行更改。总之，数学建模是团队合作的比赛。这里推荐大家一些基本的应该都会，比如查论文，能看懂模型，会排版（公式）等。</p><p>对于写作，其实这部分很关键，因为最后提交的是一篇论文，论文的好坏直接就是对应不同的成绩。</p><h2 id="建模手"><a href="#建模手" class="headerlink" title="建模手"></a>建模手</h2><h3 id="查找文献"><a href="#查找文献" class="headerlink" title="查找文献"></a>查找文献</h3><h4 id="知网"><a href="#知网" class="headerlink" title="知网"></a>知网</h4><p>知网得会吧，一些模型可以利用句子搜索来确定。</p><p><a href="https://www.cnki.net/">知网</a> : <a href="https://www.cnki.net/">https://www.cnki.net/</a></p><h4 id="谷歌学术"><a href="#谷歌学术" class="headerlink" title="谷歌学术"></a>谷歌学术</h4><p><a href="https://scholar.google.com.hk/?hl=zh-CN">谷歌学术</a> : <a href="https://scholar.google.com.hk/?hl=zh-CN">https://scholar.google.com.hk/?hl=zh-CN</a></p><p>美赛会涉及一些外网的东西，至于怎么查自己了解一下吧</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>像web science，EI自己了解一下吧</p><p><img src="https://s2.loli.net/2022/01/17/fbK2zqJu4V7sFNi.png" alt="image-20220117110930249"></p><p>这里还推举一些其他我可能用到的东西。</p><p><a href="https://www.aminer.cn/">Aminer</a> : <a href="https://www.aminer.cn/">https://www.aminer.cn/</a></p><p><img src="https://s2.loli.net/2022/01/17/U96wpAG3KOezvcD.png" alt="image-20220117111119650"></p><p><a href="http://www.4243.net/">大木虫导航</a> : <a href="http://www.4243.net/">http://www.4243.net/</a></p><p><img src="https://s2.loli.net/2022/01/17/VIOWh1i8LR6TZFt.png" alt="image-20220117111717645"></p><p><img src="https://s2.loli.net/2022/01/17/UkAtYRQTdiP17CW.png" alt="image-20220117111728409"></p><h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><p>这里我copy网上一些内容：</p><blockquote><p>常规优化模型：<br>线性规划，非线性规划，整数规划，多目标规划，动态规划</p><p>评价模型：<br>层次分析法，模糊综合评价，熵值法，TOPSIS法，数据包络分析，秩和比法，灰色关联分析</p><p>预测模型：<br>回归拟合，灰色预测，马尔可夫预测，时间序列分析</p><p>动态模型：<br>微分方程模型，差分方程模型，元胞自动机，排队论，蒙特卡罗随机模拟</p><p>图论模型：<br>最短路径，最小生成树，最小费用最大流，指派问题，旅行商问题</p><p>统计分析模型：<br>分布检验，均值T检验，方差分析，协方差分析，相关分析，卡方检验，秩和检验，回归分析，Logistic回归，聚类分析，判别分析，关联分析</p><p>现代智能算法：<br>模拟退火，神经网络，遗传算法，蚁群算法，粒子群算法，支持向量机，决策树，随机森林</p></blockquote><p>其实也不用都掌握，大概了解不同情况下用那些就行了，到时候在具体看，一些常见的简单的会就行了，难一点只需要了解即可。</p><p>下面简单瞎说一点（主要好多人想了解建模的思路，但我是编程手，建模死马当活马医了，哈哈哈）</p><h4 id="1-、优化模型"><a href="#1-、优化模型" class="headerlink" title="1 、优化模型"></a>1 、优化模型</h4><p>1.1 数学规划模型<br>线性规划、整数线性规划、非线性规划、多目标规划、动态规划。</p><p>1.2 微分方程组模型<br>阻滞增长模型、SARS传播模型。</p><p>1.3 图论与网络优化问题<br>最短路径问题、网络最大流问题、最小费用最大流问题、最小生成树问题(MST)、旅行商问题(TSP)、图的着色问题。</p><p>1.4 概率模型<br>决策模型、随机存储模型、随机人口模型、报童问题、Markov链模型。</p><p>1.5 组合优化经典问题</p><p><strong>现代优化算法：禁忌搜索；模拟退火；遗传算法；人工神经网络</strong></p><h4 id="2、分类模型"><a href="#2、分类模型" class="headerlink" title="2、分类模型"></a>2、分类模型</h4><p> 判别分析是在已知研究对象分成若干类型并已经取得各种类型的一批已知样本的观测数据，在此基础上根据某些准则建立判别式，然后对未知类型的样品进行判别分析。<br>聚类分析则是给定的一批样品，要划分的类型实现并不知道，正需要通过局内分析来给以确定类型的。</p><p>2.1 判别分析</p><p>2.2 聚类分析</p><p>2.2.1 系统聚类法（分层聚类法）<br>基本思想：开始将每个样本自成一类；然后求两两之间的距离，将距离最近的两类合成一类；如此重复，直到所有样本都合为一类为止。<br>适用范围：既适用于样本聚类，也适用于变量聚类。并且距离分类准则和距离计算方法都有多种，可以依据具体情形选择。</p><p>2.2.2 快速聚类法（K-均值聚类法）<br>基本思想：按照指定分类数目，选择个初始聚类中心；计算每个观测量（样本）到各个聚类中心的距离，按照就近原则将其分别分到放入各类中；重新计算聚类中心，继续以上步骤；满足停止条件时（如最大迭代次数等）则停止。<br>使用范围：要求用户给定分类数目，只适用于样本聚类（Q型），不适用于变量聚类（R型）。</p><p>2.2.3 两步聚类法（智能聚类方法）<br>基本思想：先进行预聚类，然后再进行正式聚类。<br>适用范围：属于智能聚类方法，用于解决海量数据或者具有复杂类别结构的聚类分析问题。可以同时处理离散和连续变量，自动选择聚类数，可以处理超大样本量的数据。</p><p>2.2.4 模糊聚类分析</p><p>2.2.5 与遗传算法、神经网络或灰色理论联合的聚类方法</p><p>2.3 神经网络分类方法</p><h4 id="3、评价模型"><a href="#3、评价模型" class="headerlink" title="3、评价模型"></a>3、评价模型</h4><p>3.1 层次分析法(AHP)<br>基本思想：是定性与定量相结合的多准则决策、评价方法。将决策的有关元素分解成目标层、准则层和方案层，并通过人们的判断对决策方案的优劣进行排序，在此基础上进行定性和定量分析。它把人的思维过程层次化、数量化，并用数学为分析、决策、评价、预报和控制提供定量的依据。<br>基本步骤：构建层次结构模型；构建成对比较矩阵；层次单排序及一致性检验（即判断主观构建的成对比较矩阵在整体上是否有较好的一致性）；层次总排序及一致性检验（检验层次之间的一致性）。<br>优点：它完全依靠主观评价做出方案的优劣排序，所需数据量少，决策花费的时间很短。从整体上看，AHP在复杂决策过程中引入定量分析，并充分利用决策者在两两比较中给出的偏好信息进行分析与决策支持，既有效地吸收了定性分析的结果，又发挥了定量分析的优势，从而使决策过程具有很强的条理性和科学性，特别适合在社会经济系统的决策分析中使用。<br>缺点：用AHP进行决策主观成分很大。当决策者的判断过多地受其主观偏好影响，而产生某种对客观规律的歪曲时，AHP的结果显然就靠不住了。<br>适用范围：尤其适合于人的定性判断起重要作用的、对决策结果难于直接准确计量的场合。要使AHP的决策结论尽可能符合客观规律，决策者必须对所面临的问题有比较深入和全面的认识。另外，当遇到因素众多，规模较大的评价问题时，该模型容易出现问题，它要求评价者对问题的本质、包含的要素及其相互之间的逻辑关系能掌握得十分透彻，否则评价结果就不可靠和准确。<br>改进方法：<br>(1) 成对比较矩阵可以采用德尔菲法获得。<br>(2) 如果评价指标个数过多（一般超过9个），利用层次分析法所得到的权重就有一定的偏差，继而组合评价模型的结果就不再可靠。可以根据评价对象的实际情况和特点，利用一定的方法，将各原始指标分层和归类，使得每层各类中的指标数少于9个。</p><p>3.2 灰色综合评价法（灰色关联度分析）<br>基本思想：灰色关联分析的实质就是，可利用各方案与最优方案之间关联度大小对评价对象进行比较、排序。关联度越大，说明比较序列与参考序列变化的态势越一致，反之，变化态势则相悖。由此可得出评价结果。<br>基本步骤：建立原始指标矩阵；确定最优指标序列；进行指标标准化或无量纲化处理；求差序列、最大差和最小差；计算关联系数；计算关联度。<br>优点：是一种评价具有大量未知信息的系统的有效模型，是定性分析和定量分析相结合的综合评价模型，该模型可以较好地解决评价指标难以准确量化和统计的问题，可以排除人为因素带来的影响，使评价结果更加客观准确。整个计算过程简单，通俗易懂，易于为人们所掌握;数据不必进行归一化处理，可用原始数据进行直接计算，可靠性强；评价指标体系可以根据具体情况增减；无需大量样本，只要有代表性的少量样本即可。<br>缺点：要求样本数据且具有时间序列特性；只是对评判对象的优劣做出鉴别，并不反映绝对水平，故基于灰色关联分析综合评价具有“相对评价”的全部缺点。<br>适用范围：对样本量没有严格要求，不要求服从任何分布，适合只有少量观测数据的问题；应用该种方法进行评价时，指标体系及权重分配是一个关键的问题，选择的恰当与否直接影响最终评价结果。<br>改进方法：<br>(1) 采用组合赋权法：根据客观赋权法和主观赋权法综合而得权系数。<br>(2) 结合TOPSIS法：不仅关注序列与正理想序列的关联度，而且关注序列与负理想序列的关联度，依据公式计算最后的关联度。</p><p>3.3 模糊综合评价法<br>基本思想：是以模糊数学为基础，应用模糊关系合成的原理，将一些边界不清、不易定量的因素定量化，从多个因素对被评价事物隶属等级（或称为评语集）状况进行综合性评价的一种方法。综合评判对评判对象的全体，根据所给的条件，给每个对象赋予一个非负实数评判指标，再据此排序择优。<br>基本步骤：确定因素集、评语集；构造模糊关系矩阵；确定指标权重；进行模糊合成和做出评价。<br>优点：数学模型简单，容易掌握，对多因素、多层次的复杂问题评判效果较好。模糊评判模型不仅可对评价对象按综合分值的大小进行评价和排序，而且还可根据模糊评价集上的值按最大隶属度原则去评定对象所属的等级，结果包含的信息量丰富。评判逐对进行，对被评对象有唯一的评价值，不受被评价对象所处对象集合的影响。接近于东方人的思维习惯和描述方法，因此它更适用于对社会经济系统问题进行评价。<br>缺点：并不能解决评价指标间相关造成的评价信息重复问题，隶属函数的确定还没有系统的方法，而且合成的算法也有待进一步探讨。其评价过程大量运用了人的主观判断，由于各因素权重的确定带有一定的主观性，因此，总的来说，模糊综合评判是一种基于主观信息的综合评价方法。<br>应用范围：广泛地应用于经济管理等领域。综合评价结果的可靠性和准确性依赖于合理选取因素、因素的权重分配和综合评价的合成算子等。<br>改进方法：采用组合赋权法：根据客观赋权法和主观赋权法综合而得权系数。</p><p>3.4 BP神经网络综合评价法<br>基本思想：是一种交互式的评价方法，它可以根据用户期望的输出不断修改指标的权值，直到用户满意为止。因此，一般来说，人工神经网络评价方法得到的结果会更符合实际情况。<br>优点：神经网络具有自适应能力，能对多指标综合评价问题给出一个客观评价，这对于弱化权重确定中的人为因素是十分有益的。在以前的评价方法中，传统的权重设计带有很大的模糊性，同时权重确定中人为因素影响也很大。随着时间、空间的推移，各指标对其对应问题的影响程度也可能发生变化，确定的初始权重不一定符合实际情况。再者，考虑到整个分析评价是一个复杂的非线性大系统，必须建立权重的学习机制，这些方面正是人工神经网络的优势所在。针对综合评价建模过程中变量选取方法的局限性，采用神经网络原理可对变量进行贡献分析，进而剔除影响不显著和不重要的因素，以建立简化模型，可以避免主观因素对变量选取的干扰。<br>缺点： ANN在应用中遇到的最大问题是不能提供解析表达式，权值不能解释为一种回归系数，也不能用来分析因果关系，目前还不能从理论上或从实际出发来解释ANN的权值的意义。需要大量的训练样本，精度不高，应用范围是有限的。最大的应用障碍是评价算法的复杂性，人们只能借助计算机进行处理，而这方面的商品化软件还不够成熟。<br>适用范围：神经网络评价模型具有自适应能力、可容错性，能够处理非线性、非局域性的大型复杂系统。在对学习样本训练中，无需考虑输入因子之间的权系数，ANN通过输入值与期望值之间的误差比较，沿原连接权自动地进行调节和适应，因此该方法体现了因子之间的相互作用。<br>改进方法：<br>采用组合评价法：对用其它评价方法得出的结果，选取一部分作为训练样本，一部分作为待测样本进行检验，如此对神经网络进行训练，知道满足要求为止，可得到更好的效果。</p><p>3.5 数据包络法(DEA)</p><p>3.6 组合评价法</p><h4 id="4、预测模型"><a href="#4、预测模型" class="headerlink" title="4、预测模型"></a>4、预测模型</h4><p>定性研究与定量研究的结合，是科学的预测的发展趋势。在实际预测工作中，应该将定性预测和定量预测结合起来使用，即在对系统做出正确分析的基础上，根据定量预测得出的量化指标，对系统未来走势做出判断。</p><p>4.1 回归分析法<br>基本思想：根据历史数据的变化规律，寻找自变量与因变量之间的回归方程式，确定模型参数，据此预测。回归问题分为一元和多元回归、线性和非线性回归。<br>特点：技术比较成熟，预测过程简单；将预测对象的影响因素分解，考察各因素的变化情况，从而估计预测对象未来的数量状态；回归模型误差较大，外推特性差。<br>适用范围：回归分析法一般适用于中期预测。回归分析法要求样本量大且要求样本有较好的分布规律，当预测的长度大于占有的原始数据长度时，采用该方法进行预测在理论上不能保证预测结果的精度。另外，可能出现量化结果与定性分析结果不符的现象，有时难以找到合适的回归方程类型。</p><p>4.2 时间序列分析法<br>基本思想：把预测对象的历史数据按一定的时间间隔进行排列，构成一个随时间变化的统计序列，建立相应的数据随时间变化的变化模型，并将该模型外推到未来进行预测。<br>适用范围：此方法有效的前提是过去的发展模式会延续到未来，因而这种方法对短期预测效果比较好，而不适合作中长期预测。一般来说，若影响预测对象变化各因素不发生突变，利用时间序列分析方法能得到较好的预测结果；若这些因素发生突变，时间序列法的预测结果将受到一定的影响。</p><p>4.3 灰色预测法<br>基本思想：将一切随机变量看作是在一定范围内变化的灰色变量，不是从统计规律角度出发进行大样本分析研究，而是利用数据处理方法(数据生成与还原)，将杂乱无章的原始数据整理成规律性较强的生成数据来加以研究，即灰色系统理论建立的不是原始数据模型，而是生成数据模型。<br>适用范围：预测模型是一个指数函数，如果待测量是以某一指数规律发展的，则可望得到较高精度的预测结果。影响模型预测精度及其适应性的关键因素，是模型中背景值的构造及预测公式中初值的选取。</p><p>4.4 BP神经网络法<br>人工神经网络的理论有表示任意非线性关系和学习等的能力，给解决很多具有复杂的不确定性和时变性的实际问题提供了新思想和新方法。<br>利用人工神经网络的学习功能，用大量样本对神经元网络进行训练，调整其连接权值和闭值，然后可以利用已确定的模型进行预测。神经网络能从数据样本中自动地学习以前的经验而无需繁复的查询和表述过程，并自动地逼近那些最佳刻画了样本数据规律的函数，而不论这些函数具有怎样的形式，且所考虑的系统表现的函数形式越复杂，神经网络这种特性的作用就越明显。<br>误差反向传播算法(BP算法)的基本思想是通过网络误差的反向传播，调整和修改网络的连接权值和闭值，使误差达到最小，其学习过程包括前向计算和误差反向传播。它利用一个简单的三层人工神经网络模型，就能实现从输入到输出之间任何复杂的非线性映射关系。目前，神经网络模型已成功地应用于许多领域，诸如经济预测、财政分析、贷款抵押评估和破产预测等许多经济领域。<br>优点：可以在不同程度和层次上模仿人脑神经系统的结构及信息处理和检索等功能，对大量非结构性、非精确性规律具有极强的自适应功能，具有信息记忆、自主学习、知识推理和优化计算等特点，其自学习和自适应功能是常规算法和专家系统技术所不具备的，同时在一定程度上克服了由于随机性和非定量因素而难以用数学公式严密表达的困难。<br>缺点：网络结构确定困难，同时要求有足够多的历史数据，样本选择困难，算法复杂，容易陷入局部极小点。</p><p>4.5 支持向量机法<br>支持向量机是基于统计学习的机器学习方法，通过寻求结构风险化最小，实现经验风险和置信范围的最小，从而达到在统计样本较少的情况下，亦能获得良好统计规律的目的。 其中支持向量机是统计学习理论的核心和重点。支持向量机是结构风险最小化原理的近似，它能够提高学习机的泛化能力，既能够由有限的训练样本得到小的误差，又能够保证对独立的测试集仍保持小的误差，而且支持向量机算法是一个凸优化问题，因此局部最优解一定是全局最优解，支持向量机就克服了神经网络收敛速度慢和局部极小点等缺陷。 核函数的选取在SVM方法中是一个较为困难的问题，至今没有一定的理论方面的指导。</p><p>4.6 组合预测法<br>在实际预测工作中，从信息利用的角度来说，就是任何一种单一预测方法都只利用了部分有用信息，同时也抛弃了其它有用的信息。为了充分发挥各预测模型的优势，对于同一预测问题，往往可以采用多种预测方法进行预测。不同的预测方法往往能提供不同的有用信息，组合预测将不同预测模型按一定方式进行综合。根据组合定理，各种预测方法通过组合可以尽可能利用全部的信息，尽可能地提高预测精度，达到改善预测性能的目的。<br>优化组合预测有两类概念，一是指将几种预测方法所得的预测结果，选取适当的权重进行加权平均的一种预测方法，其关键是确定各个单项预测方法的加权系数；二是指在几种预测方法中进行比较，选择拟合度最佳或标准离差最小的预测模型作为最优模型进行最优模型进行预测。组合预测是在单个预测模型不能完全正确地描述预测量的变化规律时发挥其作用的。</p><h3 id="论文资料"><a href="#论文资料" class="headerlink" title="论文资料"></a>论文资料</h3><p>我这里只有有小部分可以参考，不过我相信每一个参加的，都会有一堆这些资料，如果感兴趣可以私聊我发你。</p><p>这里推荐一个Github</p><p><a href="https://github.com/personqianduixue/Math_Model"> Math_Model</a> : <a href="https://github.com/personqianduixue/Math_Model/">https://github.com/personqianduixue/Math_Model/</a></p><p><a href="https://github.com/zhanwen/MathModel"> MathModel</a> : <a href="https://github.com/zhanwen/MathModel">https://github.com/zhanwen/MathModel</a></p><p><a href="https://github.com/HuangCongQing/Algorithms_MathModels"> Algorithms_MathModels</a>: <a href="https://github.com/HuangCongQing/Algorithms_MathModels">https://github.com/HuangCongQing/Algorithms_MathModels</a></p><p>其他可以自己github查找：</p><p><img src="https://s2.loli.net/2022/01/17/tZJNnQCrfA5jo9i.png" alt="image-20220117113128392"></p><h2 id="编程手"><a href="#编程手" class="headerlink" title="编程手"></a>编程手</h2><p>因为我主要是编程手，干的杂，其实大部分还是依赖有一个好队友，哈哈哈。</p><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><h4 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h4><p>matlab应该是最熟悉的软件，内置很多包和操作，很多数学建模的代码也是matlab的。</p><p><img src="https://s2.loli.net/2022/01/19/E5PGKLwcQB9f7nX.png" alt="image-20220119092506185"></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://s2.loli.net/2022/01/19/UmVvM3FfyX9Dt2g.png" alt="image-20220119092547686"></p><p><img src="https://s2.loli.net/2022/01/19/4iQBPCJjpItmSkR.png" alt="image-20220119092711049"></p><h3 id="工具软件"><a href="#工具软件" class="headerlink" title="工具软件"></a>工具软件</h3><h4 id="SPSS"><a href="#SPSS" class="headerlink" title="SPSS"></a>SPSS</h4><p><img src="https://s2.loli.net/2022/01/18/QVWIGJzCnZEyUbw.png" alt="image-20220118104812319"></p><h4 id="mpai"><a href="#mpai" class="headerlink" title="mpai"></a>mpai</h4><p><img src="https://s2.loli.net/2022/01/18/34k7YzCLRBVrf6n.png" alt="image-20220118121544529"></p><h3 id="Lingo"><a href="#Lingo" class="headerlink" title="Lingo"></a>Lingo</h3><p>Lingo是运筹优化问题比较好的软件之一，它可以用于求解非线性规划，也可用于一些线性和非线性方程组的求解等，功能十分强大，是求解优化模型的最佳选择，其特色在于内置建模语言，提供十几个内部函数，可以允许决策变量是整数（既整数规划，包括0-1整数规划），方便灵活，而且执行速度很快。能与Excel，数据库等软件交换数据。</p><h4 id="mathematica"><a href="#mathematica" class="headerlink" title="mathematica"></a>mathematica</h4><p>科学计算多一点，多用在和物理相关的题目进行一些计算。</p><p>  <a href="https://www.wolfram.com/mathematica/">mathematica</a> : <a href="https://www.wolfram.com/mathematica/">https://www.wolfram.com/mathematica/</a></p><h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><h4 id="draw-io"><a href="#draw-io" class="headerlink" title="draw.io"></a>draw.io</h4><p><img src="https://s2.loli.net/2022/01/19/k7oKajAuZySN6eW.png" alt="image-20220119080703472"></p><h4 id="echart"><a href="#echart" class="headerlink" title="echart"></a>echart</h4><p><a href="https://echarts.apache.org/zh/index.html">echart</a> : <a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p><p><img src="https://s2.loli.net/2022/01/19/J537PpTtFjDEUgZ.png" alt="image-20220119080821381"></p><p><img src="https://s2.loli.net/2022/01/19/kihc5sptO1UlNHv.png" alt="热带雨林"></p><h4 id="ppt"><a href="#ppt" class="headerlink" title="ppt"></a>ppt</h4><p>一些流程图配合</p><p><a href="https://www.iconfont.cn/">图库</a> : <a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a></p><p><img src="https://s2.loli.net/2022/01/19/e6fw9VgDY4Td85J.png" alt="C4DB3D22-1AE8-456a-AD5F-8FF91D2369FE"></p><h4 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h4><p><img src="https://s2.loli.net/2022/01/19/KXbn5TqaoCu4tQ2.png" alt="图片1"></p><h4 id="matlab"><a href="#matlab" class="headerlink" title="matlab"></a>matlab</h4><p>这里推荐一个插件：</p><p>关注b站MATLAB大佬<a href="https://space.bilibili.com/223755925?from=search&amp;seid=7825192864172994189&amp;spm_id_from=333.337.0.0">图通道</a> : <a href="https://space.bilibili.com/223755925?from=search&amp;seid=7825192864172994189&amp;spm_id_from=333.337.0.0">https://space.bilibili.com/223755925?from=search&amp;seid=7825192864172994189&amp;spm_id_from=333.337.0.0</a></p><p><img src="https://s2.loli.net/2022/01/19/oEk9ijFvfaexP1X.png" alt="image-20220119081228057"></p><p><img src="https://s2.loli.net/2022/01/19/QsIvOoj1ywPDhfu.png" alt="图20210206T220235"></p><h4 id="python绘图"><a href="#python绘图" class="headerlink" title="python绘图"></a>python绘图</h4><p>首先类似matlab的Matplotlib</p><p><a href="https://matplotlib.org/">Matplotlib</a> : <a href="https://matplotlib.org/">https://matplotlib.org/</a></p><p><img src="https://s2.loli.net/2022/01/19/9MH1Ss2PbZOw46X.png" alt="image-20220119092913103"></p><p>Pyecharts</p><p><a href="https://pyecharts.org/#/zh-cn/intro">Pyecharts</a> : <a href="https://pyecharts.org/#/zh-cn/intro">https://pyecharts.org/#/zh-cn/intro</a></p><p>和前面echart一样的，代码及其相似，可视化交互吧</p><p><img src="https://s2.loli.net/2022/01/19/S7NDEj2AspBd3oy.png" alt="image-20220119093125771"></p><h4 id="seaborn（sns）"><a href="#seaborn（sns）" class="headerlink" title="seaborn（sns）"></a>seaborn（sns）</h4><p>也就是seaborn</p><p><a href="https://seaborn.pydata.org/">seaborn</a> : <a href="https://seaborn.pydata.org/">https://seaborn.pydata.org/</a></p><p>这个更快。用于特征选取的对比，一些封装好的图，输入数据就能出图，最喜欢seaborn.heatmap的相关性</p><p><img src="https://s2.loli.net/2022/01/19/VMHzscZCnExlU9L.png" alt="image-20220119093437327"></p><p>还有seaborn.pairplot，变量之间的关系</p><p><img src="https://s2.loli.net/2022/01/19/jmwGUc8tICKEXWh.png" alt="image-20220119093541385"></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><a href="https://scikit-learn.org.cn/">scikit-learn</a> : <a href="https://scikit-learn.org.cn/">https://scikit-learn.org.cn/</a></p><p>主流的机器学习，适合一些预测题</p><p><a href="https://scikit-opt.github.io/scikit-opt/#/zh/">scikit-opt</a> : <a href="https://scikit-opt.github.io/scikit-opt/#/zh/">https://scikit-opt.github.io/scikit-opt/#/zh/</a></p><p>一些智能优化，封装好的，之间导包就能用。</p><p><a href="https://github.com/statsmodels/statsmodels/tree/main/examples">statsmodels</a> ： <a href="https://www.statsmodels.org/stable/examples/index.html">https://www.statsmodels.org/stable/examples/index.html</a></p><p>一个统计相关的库，很全面，偶尔使用吧</p><p><a href="https://pycaret.org/">pycarets</a>  : <a href="https://pycaret.org/">https://pycaret.org/</a></p><p>和时间序列有关的slam吧</p><p><a href="https://github.com/fxsjy/jieba">jieba</a> :  <a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a></p><p>中文的分词的，用于nlp处理吧</p><p><a href="https://github.com/keredson/wordninja">wordninja</a> : <a href="https://github.com/keredson/wordninja">https://github.com/keredson/wordninja</a></p><p>英文的分词的，用于nlp处理吧</p><p><a href="https://amueller.github.io/word_cloud/#">wordcloud</a> : <a href="https://amueller.github.io/word_cloud/">https://amueller.github.io/word_cloud/</a></p><p>词云生成器，也不难</p><p>nlp最难的是分析，噪声太多了，自己不太擅长。</p><h2 id="写作手"><a href="#写作手" class="headerlink" title="写作手"></a>写作手</h2><h3 id="写作模板"><a href="#写作模板" class="headerlink" title="写作模板"></a>写作模板</h3><blockquote><p>摘要</p><p>1.问题重述（背景介绍、文献综述、问题重述等）</p><p>2.问题分析（主要对问题进行一定的分析，可以做一个分析流图）</p><p>3.问题假设（其实也就是对问题的边界进行划定，我们需要让问题更具体一些）</p><p>4.符号说明（对于文章中主要出现的符号进行一定的解释，方便评委老师理解）</p><p>5.模型建立与求解（这一步最为核心，即数学建模和模型的求解部分）</p><p>6.灵敏度分析（即分析模型的输出，对参数或环境变化的敏感程度的分析）</p><p>7.模型的推广及优缺点（主要对模型的进一步研究分析和优缺点解释）</p><p>参考文献</p><p>附录</p></blockquote><p>上面是大致的模板,当然具体情况可以自己修改,小白还是推荐参考,这里模型建立与求解,可以分开模型一的建模与求解,模型二的建模与求解等也可以合在一起,模型的建模,模型的求解.</p><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>这里word应该是最简单，这里我也不多介绍,这个应该学一下,后面课程报告等都会用到.</p><p>这里推荐b站的一些视频,这里就不推荐,毕竟word这部分一个合格的大学生都应该掌握.(感兴趣还可以顺便考个二级)</p><h4 id="latex"><a href="#latex" class="headerlink" title="latex"></a>latex</h4><p>这里提一下latex,其实建议掌握,最起码会个latex的公式(这个真的是必学)</p><p>然后论文排版,latex和word在比赛中差距不是很大,但latex学习成本高于word,一定要慎重,latex排版的写作手,最好用latex排几次,练练手,要不然在比赛很容易产生没时间,or意外的bug,导致结果不太理想.</p><p>latex公式这里是强烈推荐的,尤其是</p><p><a href="https://www.latexlive.com/home">LaTeX公式编辑器</a> : <a href="https://www.latexlive.com/home">https://www.latexlive.com/home</a></p><p><img src="https://s2.loli.net/2022/01/15/n9tAwZzyfsBaPde.png" alt="image-20220115174319364"></p><p>支持图像识别，latex公式代码提示。</p><p>latex编辑器推荐<a href="https://cn.overleaf.com/">overleaf</a>:<a href="https://cn.overleaf.com/">https://cn.overleaf.com/</a></p><p><img src="https://s2.loli.net/2022/01/15/tnQHGNZjPXm8Mqr.png" alt="image-20220115182813329"></p><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>这里其实更推荐机器翻译，人工审核，美赛量有点大，纯人工翻译挺难的，而且还可能不太准确，这里最好推荐人工核查，搭配机器翻译，这里推荐谷歌翻译和deepl</p><p>deepl</p><p><img src="https://s2.loli.net/2022/01/17/M4m36wPv7Jba5Y8.png" alt="image-20220117102134600"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUMT算法考试总结</title>
      <link href="/2021/12/08/2021-12-8-suan-fa-zong-jie/"/>
      <url>/2021/12/08/2021-12-8-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="算法考试总结"><a href="#算法考试总结" class="headerlink" title="算法考试总结"></a>算法考试总结</h1><blockquote><p>作者：lowlyli</p><p>时间：2021-12-8</p><p>内容：含泪写下这个算法的总结，太离谱了，我真的写不完，不会写。</p></blockquote><h2 id="问题回忆"><a href="#问题回忆" class="headerlink" title="问题回忆"></a>问题回忆</h2><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><blockquote><p>这题其实很简单，但比以往的上课题一点点复杂</p></blockquote><p>大意：</p><script type="math/tex; mode=display">T(n) = \left\{ \begin{array}{c}{1} & n = 1 \\  2T(\frac{n}{2}) + n^2 + 1 & n>1\end{array}\right.</script><p>主定理盒递推都可以</p><h3 id="流水作业调度（变形）"><a href="#流水作业调度（变形）" class="headerlink" title="流水作业调度（变形）"></a>流水作业调度（变形）</h3><p>基本步骤一样，就是这个卷子给的数字和计算规模大，写不完。</p><ol><li><p><strong>问题描述</strong> n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业$i$所需的时间分别为$a_i$ 和$b_i$。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>分为$N_1,N_2$集合存放 <script type="math/tex">N_1 = \{a_i\leq b_i\} ,N_2 = \{a_i > b_i\}</script></li><li>$N_1$中作业按照$a_i$升序排序，$N_2$中作业按照$b_i$降序排序</li><li>$N_1$连接$N_2$，计算时间</li></ol></li></ol><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>简单送分题（送命题）</p><p>这题和平时步骤一样，唯一区别就说这个题是10个字母的，上课也只有6，7个的，10个的规模有点大，写了满满一面的步骤和树，画吐了。</p><h3 id="暖气管道最优安排"><a href="#暖气管道最优安排" class="headerlink" title="暖气管道最优安排"></a>暖气管道最优安排</h3><p>这题很迷惑，给了22个点,每个点包括$(x_i,y_i)$,问有没有最佳的一个点$(0,y_{best})$,这题没见过，考试跳过了，其实就说二分法求中位数</p><p>类似：</p><p>某石油公司计划建造一条由东向西的主输油管道。该管道要穿过一个有n口油井的油田。从每口油井都要有一条输油管道沿最短路经（或南或北）与主管道相连。</p><p>如果给定n口油井的位置，即它们的x坐标（东西向）和y坐标（南北向），应如何确定主管道的最优位置，即使各油井到主管道之间的输油管道长度总和最小的位置？</p><p>给定n口油井的位置，编程计算各油井到主管道之间的输油管道最小长度总和。</p><p><img src="https://s2.loli.net/2021/12/09/G2nFJwBPsKmhgiE.png" alt="这里写图片描述"></p><p>（这15分基本上空了，没时间写，后面想到了，二分中位数，但22个数，每日吐槽题量大）</p><h3 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h3><p>这里是等待，有n个顾客，每个人需要$t_i$的服务时间，有m个窗口，求最短的等待时间的安排</p><p>就是贪心，从小到大排序，依次插入窗口。</p><p>（再次吐槽，给了10个数，2窗口，没时间写）</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>离谱，如果考实践的时候我还会（其实现在也会写代码）但这里理论分析，属实蚌埠住了，最离谱的是2种方法，放过我吧，我只写了后面的问题求解，理论属实不会。</p><p>这是考场上想到的：居然蒙对了一个，不过第二种属实不会了。</p><script type="math/tex; mode=display">dp[i]=max(dp[j])+1,其中0≤j<i且num[j]<num[i]</script><p>这里自己参考：</p><p>力扣<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">最长递增子序列</a></p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</a></p><h3 id="回溯法和分支限界"><a href="#回溯法和分支限界" class="headerlink" title="回溯法和分支限界"></a>回溯法和分支限界</h3><p>这里是0-1背包变形</p><p>但这里要求2次，还是5层的树。</p><p>最后就一点点时间了，稀里糊涂画的，现在想起来，答案估计都有问题。唉~题量也太大了。根本写不完。</p><h2 id="反思总结（也给一点准备建议）"><a href="#反思总结（也给一点准备建议）" class="headerlink" title="反思总结（也给一点准备建议）"></a>反思总结（也给一点准备建议）</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次考试，题量大的离谱，我这种写的慢的，当年数据库都没写完的人，这根本写不完，除非，我不用思考，但这题还是有点难度，需要思考的，不清楚为啥19如此难。本来2周前就考了，因为突如其来的疫情，推迟了，导致理论和实践间隔久，反正就是只复习了书上，然后老师画的重点，然后就崩了。呜呜呜。</p><h3 id="备考建议"><a href="#备考建议" class="headerlink" title="备考建议:"></a>备考建议:</h3><p>课上内容不太行，建议在平时学习看一遍书就可以开始刷力扣了，培养题感，这里推荐：</p><p> <a href="https://www.programmercarl.com/">代码随想录</a> : <a href="https://www.programmercarl.com/">https://www.programmercarl.com/</a></p><p>可以参考上面的最基础的地方刷，本人在2周多一点刷了100来道，虽然考试帮助不太大，但感觉还是学到了算法的一些精髓。</p><p><img src="https://s2.loli.net/2021/12/09/NiIkxXUwQpVsDWc.png" alt="image-20211209090200310"></p><p>理论的一些可以参考：<a href="https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/">胡神的博客</a></p><p>还是可以的，我的一般吧。</p><p>没有什么了，算法好好学吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 考试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SM4算法</title>
      <link href="/2021/12/05/2021-12-5-sm4-suan-fa/"/>
      <url>/2021/12/05/2021-12-5-sm4-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="SM4算法"><a href="#SM4算法" class="headerlink" title="SM4算法"></a>SM4算法</h1><blockquote><p>作者：lowlyli</p><p>时间：2021-12-5</p><p>内容：SM4是国密里面针对无线标准进行的分组密码，和DES加密很像。它采用的方法是能够很好抵抗差值攻击的仿射函数逆映射复合法。有时间分析一下如何破解吧。</p></blockquote><h2 id="SM4算法介绍"><a href="#SM4算法介绍" class="headerlink" title="SM4算法介绍"></a>SM4算法介绍</h2><p> 2012年3月，国家密码管理局正式公布了包含SM4分组密码算法在内的《祖冲之序列密码算法》等6项密码行业标准。与DES和AES算法类似，SM4算法是一种分组密码算法。其分组长度为128bit，密钥长度也为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构，以字（32位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。</p><p>SMS4分组加密算法是中国无线标准中使用的分组加密算法，在2012年已经被国家商用密码管理局确定为国家密码行业标准，标准编号GM/T 0002-2012并且改名为SM4算法，与SM2椭圆曲线公钥密码算法，SM3密码杂凑算法共同作为国家密码的行业标准，在我国密码行业中有着极其重要的位置。</p><p> SM4有很高的灵活性，所采用的S盒可以灵活地被替换，以应对突发性的安全威胁。算法的32轮迭代采用串行处理，这与AES中每轮使用代换和混淆并行地处理整个分组有很大不同。</p><p>S盒是一种利用非线性变换构造的分组密码的一个组件，主要是为了实现分组密码过程中的混淆的特性和设计的。SMS4算法中的S盒在设计之初完全按照欧美分组密码的设计标准进行，它采用的方法是能够很好抵抗差值攻击的仿射函数逆映射复合法。</p><p>参考官方网站：<a href="http://www.gmbz.org.cn/main/bzlb.html">密码行业标准化</a>:   <a href="http://www.gmbz.org.cn/main/bzlb.html">http://www.gmbz.org.cn/main/bzlb.html</a></p><p><img src="https://s2.loli.net/2021/12/05/TkmWHtsxwIzpajl.png" alt="202112051241833.png"></p><h2 id="SM4算法原理"><a href="#SM4算法原理" class="headerlink" title="SM4算法原理"></a>SM4算法原理</h2><p>本算法是一个分组算法。该算法的分组长度为128比特，密钥长度为128比特。加密算法与密钥扩展算法都采用32轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。</p><h3 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h3><h4 id="字与字节"><a href="#字与字节" class="headerlink" title="字与字节"></a>字与字节</h4><p>用$Z_2^e$表示e-比特的向量集，$Z_2^{32}$中的元素称为字，$Z_2^8$中的元素称为字节。</p><h4 id="S盒"><a href="#S盒" class="headerlink" title="S盒"></a>S盒</h4><p>S盒为固定的8比特输入8比特输出的置换，记为$Sbox(X)$</p><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><p>在本算法中采用了以下基本运算：</p><ul><li>$⊕$ 32比特异或</li><li>$&lt;&lt;&lt;i$ 32比特循环左移$i$位</li></ul><h4 id="密钥及密钥参量"><a href="#密钥及密钥参量" class="headerlink" title="密钥及密钥参量"></a>密钥及密钥参量</h4><p>加密密钥长度为 128 比特, 表示为<script type="math/tex">\mathrm{MK}=\left(\mathrm{MK}_{0}, \mathrm{MK}_{1}, \mathrm{MK}_{2}, \mathrm{MK}_{3}\right)</script>, 其中  <script type="math/tex">\mathrm{MK}_{i}(\mathrm{i}=0,1,2,3)</script>为 字。</p><p>轮密钥表示为 <script type="math/tex">\left(\mathrm{rk}_{0}, \mathrm{rk}_{1}, \ldots, \mathrm{rk}_{31}\right)</script>, 其中  <script type="math/tex">\mathrm{rk}_{\mathrm{i}}(\mathrm{i}=0, \ldots, 31)</script>为字。轮密钥由加密密钥生成。</p><p>系统参数为<script type="math/tex">\mathrm{FK}=\left(\mathrm{FK}_{0}, \mathrm{FK}_{1}, \mathrm{FK}_{2}, \mathrm{FK}_{3}\right)</script></p><p>固定参数<script type="math/tex">\mathrm{CK}=\left(\mathrm{CK}_{0}, \mathrm{CK}_{1}, \ldots, \mathrm{CK}_{31}\right)</script>, 用于密钥扩展算法, </p><p>其中 <script type="math/tex">\mathrm{FK}_{\mathrm{i}}(i=0, \ldots, 3) 、 \mathrm{CK}_{\mathrm{i}}(i=0, \ldots, 31)</script>为字。</p><h3 id="轮函数F"><a href="#轮函数F" class="headerlink" title="轮函数F"></a>轮函数F</h3><p>本算法采用非线性迭代结构, 以字为单位进行加密运算, 称一次迭代运算为一轮变换。</p><p>设输入为<script type="math/tex">( X_ {0} , X_ {1} , X_ {2} , X_ {3} ) \in (Z_ {2}^ {32})^ {4}</script>,轮密钥为<script type="math/tex">rk \in Z_ {2}^ {32}</script>,则轮函数F为:</p><script type="math/tex; mode=display">F( X_ {0} , X_ {1} , X_ {2} , X_ {3} ,rk)= X_ {0} \oplus T( X_ {1} \oplus X_ {2} \oplus X_ {3} \oplus rk)</script><h4 id="合成置换T"><a href="#合成置换T" class="headerlink" title="合成置换T"></a>合成置换T</h4><p>$T:Z_2^{32} \rightarrow Z_2^{32}$，是一个可逆变换，由非线性变换$τ$和线性变换$L$复合而成,即$T(x)=L(τ(x))$</p><h5 id="非线性变换τ"><a href="#非线性变换τ" class="headerlink" title="非线性变换τ"></a>非线性变换τ</h5><p> $\tau$  由 4 个并行的S盒构成。<br>设输入为 <script type="math/tex">A=\left(a_{0}, a_{1}, a_{2}, a_{3}\right) \in\left(Z_{2}^{8}\right)^{4}</script>, 输出为 <script type="math/tex">B=\left(b_{0}, b_{1}, b_{2}, b_{3}\right) \in\left(Z_{2}^{8}\right)^{4}</script>, 则</p><script type="math/tex; mode=display">\left(b_{0}, b_{1}, b_{2}, b_{3}\right)=\tau(A)=\left(\operatorname{Sbox}\left(a_{0}\right), \operatorname{Sbox}\left(a_{1}\right), \operatorname{Sbox}\left(a_{2}\right), \operatorname{Sbox}\left(a_{3}\right)\right)</script><h5 id="线性变换L"><a href="#线性变换L" class="headerlink" title="线性变换L"></a>线性变换L</h5><p>非线性变换 <script type="math/tex">\tau</script> 的输出是线性变换 <script type="math/tex">\mathrm{L}</script>的输入。设输入为 <script type="math/tex">B \in Z_{2}^{32}</script> , 输出为 <script type="math/tex">C \in Z_{2}^{32}</script>, 则 </p><script type="math/tex; mode=display">C=L(B)=B \oplus(B<<<2) \oplus(B<<<10) \oplus(B<<<18) \oplus(B<<<24)</script><h4 id="S盒-1"><a href="#S盒-1" class="headerlink" title="S盒"></a>S盒</h4><p><img src="https://s2.loli.net/2021/12/05/WOoB8NY34dm6xKM.png" alt="image-20211205153046989"></p><p>输入‘ef’，则经S盒后的值为表中第e行和第f列的值，Sbox(‘ef’)= ‘84’。</p><h3 id="加-解密算法"><a href="#加-解密算法" class="headerlink" title="加/解密算法"></a>加/解密算法</h3><p>定义反序变换 <script type="math/tex">\mathrm{R}</script>为: </p><script type="math/tex; mode=display">R\left(A_{0}, A_{1}, A_{2}, A_{3}\right)=\left(A_{3}, A_{2}, A_{1}, A_{0}\right), A_{i} \in Z_{2}^{32}, i=0,1,2,3</script><p>设明文输入为 <script type="math/tex">\left(X_{0}, X_{1}, X_{2}, X_{3}\right) \in\left(Z_{2}^{32}\right)^{4}</script>, 密文输出为<script type="math/tex">\left(Y_{0}, Y_{1}, Y_{2}, Y_{3}\right) \in\left(Z_{2}^{32}\right)^{4}</script>, 轮密钥为<script type="math/tex">r k_{i} \in Z_{2}^{32}, i=0,1,2, \ldots, 31</script> 。则本算法的加密变换为: </p><script type="math/tex; mode=display">X_{i+4}=F\left(X_{i}, X_{i+1}, X_{i+2}, X_{i+3}, r k_{i}\right)\\=X_{i} \oplus T\left(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus r k_{i}\right), i=0,1, \ldots, 31 . \\\left(Y_{0}, Y_{1}, Y_{2}, Y_{3}\right)=R\left(X_{32}, X_{33}, X_{34}, X_{35}\right)=\left(X_{35}, X_{34}, X_{33}, X_{32}\right)</script><p>本算法的解密变换与加密变换结构相同, 不同的仅是轮密钥的使用顺序。 </p><p>密时轮密钥的使用顺序为:<script type="math/tex">\left(r k_{0}, r k_{1}, \ldots, r k_{31}\right)</script></p><p>解密时轮密钥的使用顺序为:<script type="math/tex">\left(r k_{31}, r k_{30}, \ldots, r k_{0}\right)</script></p><h3 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h3><p>本算法中加密算法的轮密钥由加密密钥通过密钥扩展算法生成。</p><p>加密密钥 </p><script type="math/tex; mode=display">M K=\left(M K_{0}, M K_{1}, M K_{2}, M K_{3}\right), M K_{i} \in Z_{2}^{32}, i=0,1,2,3 ;</script><p>令 <script type="math/tex">K_{i} \in Z_{2}^{32}, i=0,1, \ldots, 35</script> , 轮密钥为 <script type="math/tex">r k_{i} \in Z_{2}^{32}, i=0,1, \ldots, 31</script>, 则轮密钥生成方法为:</p><p>首先, </p><script type="math/tex; mode=display">\small\left(K_{0}, K_{1}, K_{2}, K_{3}\right)=\left(\mathrm{MK}_{0} \oplus \mathrm{FK}_{0}, \mathrm{MK}_{1} \oplus \mathrm{FK}_{1}, \mathrm{MK}_{2} \oplus \mathrm{FK}_{2}, \mathrm{MK}_{3} \oplus \mathrm{FK}_{3}\right)</script><p>然后, 对 $ i=0,1,2, \ldots, 31$  :</p><script type="math/tex; mode=display">r k_{i}=K_{i+4}=K_{i} \oplus T^{\prime}\left(K_{i+1} \oplus K_{i+2} \oplus K_{i+3} \oplus C K_{i}\right)</script><p>说明:</p><p>(1)  $T^{\prime} $ 变换与加密算法轮函数中的  T  基本相同, 只将其中的线性变换  L  修改为以下$  L^{\prime} $ :</p><script type="math/tex; mode=display"> L^{\prime}(\mathrm{B})=\mathrm{B} \oplus(\mathrm{B}<<<13) \oplus(\mathrm{B}<<<23) ;</script><p>(2) 系统参数 FK的取值, 采用 16 进制表示为:</p><script type="math/tex; mode=display">\mathrm{FK}_{0}=(\mathrm{A} 3 \mathrm{~B} 1 \mathrm{BAC}), \mathrm{FK}_{1}=(56 \mathrm{AA} 3350), \\\mathrm{FK}_{2}=(677 \mathrm{D} 9197), \mathrm{FK}_{3}=(\mathrm{B} 27022 \mathrm{DC})</script><p> (3) 固定参数<script type="math/tex">\mathrm{CK}</script>的取值方法为:</p><p>设  <script type="math/tex">c k_{i, j}</script>为  <script type="math/tex">C K_{i}</script> 的第 <script type="math/tex">j</script>字节<script type="math/tex">(i=0,1, \ldots, 31 ; j=0,1,2,3)</script> , 即 <script type="math/tex">C K_{i}=\left(c k_{i, 0}, c k_{i, 1}, c k_{i, 2}, c k_{i, 3}\right) \in\left(Z_{2}^{8}\right)^{4}</script> ,则<script type="math/tex">c k_{i, j}=(4 i+j) \times 7(\bmod 256)</script>。 32 个固定参数 <script type="math/tex">C K_{i}</script> , 其 16 进制表示为:</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">00070e15</td><td style="text-align:center">1c232a31</td><td style="text-align:center">383f464d</td><td style="text-align:center">545b6269</td></tr><tr><td style="text-align:center">70777e85</td><td style="text-align:center">8c939aa1</td><td style="text-align:center">a8afb6bd</td><td style="text-align:center">c4cbd2d9</td></tr><tr><td style="text-align:center">e0e7eef5</td><td style="text-align:center">fc030a11</td><td style="text-align:center">181f262d</td><td style="text-align:center">343b4249</td></tr><tr><td style="text-align:center">50575e65</td><td style="text-align:center">6c737a81</td><td style="text-align:center">888f969d</td><td style="text-align:center">a4abb2b9</td></tr><tr><td style="text-align:center">c0c7ced5</td><td style="text-align:center">dce3eaf1</td><td style="text-align:center">f8ff060d</td><td style="text-align:center">141b2229</td></tr><tr><td style="text-align:center">30373e45</td><td style="text-align:center">4c535a61</td><td style="text-align:center">686f767d</td><td style="text-align:center">848b9299</td></tr><tr><td style="text-align:center">a0a7aeb5</td><td style="text-align:center">bcc3cad1</td><td style="text-align:center">d8dfe6ed</td><td style="text-align:center">f4fb0209</td></tr><tr><td style="text-align:center">10171e25</td><td style="text-align:center">2c333a41</td><td style="text-align:center">484f565d</td><td style="text-align:center">646b7279</td></tr></tbody></table></div><h3 id="加密解密可逆分析"><a href="#加密解密可逆分析" class="headerlink" title="加密解密可逆分析"></a>加密解密可逆分析</h3><p>这里设加密密钥 </p><script type="math/tex; mode=display">M K=\left(M K_{0}, M K_{1}, M K_{2}, M K_{3}\right), M K_{i} \in Z_{2}^{32}, i=0,1,2,3 ;</script><p>令 <script type="math/tex">K_{i} \in Z_{2}^{32}, i=0,1, \ldots, 35</script> , 则可以生成轮密钥为 <script type="math/tex">r k_{i} \in Z_{2}^{32}, i=0,1, \ldots, 31</script>, </p><p>在加密中密钥<script type="math/tex">i : 0 \rightarrow 31</script>, 在解密中<script type="math/tex">i : 31 \rightarrow 0</script>， 即：每一轮的密钥一致。</p><p>设明文输入为 <script type="math/tex">\left(X_{0}, X_{1}, X_{2}, X_{3}\right) \in\left(Z_{2}^{32}\right)^{4}</script></p><p>设 密文输出为<script type="math/tex">\left(Y_{0}, Y_{1}, Y_{2}, Y_{3}\right) \in\left(Z_{2}^{32}\right)^{4}</script>, </p><p>根据加密原则：</p><script type="math/tex; mode=display">\left(Y_{0}, Y_{1}, Y_{2}, Y_{3}\right)=R\left(X_{32}, X_{33}, X_{34}, X_{35}\right)=\left(X_{35}, X_{34}, X_{33}, X_{32}\right)</script><p>而加密流程</p><script type="math/tex; mode=display">X_{i+4}=X_{i} \oplus T\left(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus r k_{i}\right), i=0,1, \ldots, 31 . \\</script><p>设<script type="math/tex">C = T\left(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus r k_{i}\right),</script> 则<script type="math/tex">X_i :=X_{i+4}\oplus  X_{i}</script></p><p>故可解出<script type="math/tex">X_i</script>,以此类推得到：<script type="math/tex">\left(X_{0}, X_{1}, X_{2}, X_{3}\right)</script></p><h2 id="SM4算法流程"><a href="#SM4算法流程" class="headerlink" title="SM4算法流程"></a>SM4算法流程</h2><h3 id="完整流程如下："><a href="#完整流程如下：" class="headerlink" title="完整流程如下："></a>完整流程如下：</h3><p> <img src="https://s2.loli.net/2021/12/05/bHkwWJIfONs9mRp.png" alt="202112051250479.png"></p><h3 id="密钥扩展算法-1"><a href="#密钥扩展算法-1" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h3><p>第一步：密钥与系统参数的异或:</p><script type="math/tex; mode=display">\small\left(K_{0}, K_{1}, K_{2}, K_{3}\right)=\left(\mathrm{MK}_{0} \oplus \mathrm{FK}_{0}, \mathrm{MK}_{1} \oplus \mathrm{FK}_{1}, \mathrm{MK}_{2} \oplus \mathrm{FK}_{2}, \mathrm{MK}_{3} \oplus \mathrm{FK}_{3}\right)</script><p>第二步：获取子密钥：</p><script type="math/tex; mode=display">r k_{i}=K_{i+4}=K_{i} \oplus T^{\prime}\left(K_{i+1} \oplus K_{i+2} \oplus K_{i+3} \oplus C K_{i}\right)</script><p>流程如下：</p><p><img src="https://s2.loli.net/2021/12/05/ja1yQwbsgfSKNhC.png" alt="20210514162641653"></p><p>函数T：</p><p><img src="https://s2.loli.net/2021/12/05/KIo1mSLWzwVhMl2.png" alt="在这里插入图片描述"></p><h3 id="明文加密"><a href="#明文加密" class="headerlink" title="明文加密"></a>明文加密</h3><p>明文处理大致分解为3步：</p><p>1）、将128bit的明文分成4个32bit的字<script type="math/tex">(X_1,X_2,X_3,X_4)</script>。</p><p>2）、将上述得到的字进行32轮的轮操作。</p><p>3）、最后将进行过32轮操作的4个字进行反序变换后组成128bit的密文。</p><script type="math/tex; mode=display">X_{i+4}=F\left(X_{i}, X_{i+1}, X_{i+2}, X_{i+3}, r k_{i}\right)\\=X_{i} \oplus T\left(X_{i+1} \oplus X_{i+2} \oplus X_{i+3} \oplus r k_{i}\right), i=0,1, \ldots, 31 . \\\left(Y_{0}, Y_{1}, Y_{2}, Y_{3}\right)=R\left(X_{32}, X_{33}, X_{34}, X_{35}\right)=\left(X_{35}, X_{34}, X_{33}, X_{32}\right)</script><p><img src="https://s2.loli.net/2021/12/07/ouFQJWXMqKb6Cdm.png" alt="在这里插入图片描述"></p><p><img src="https://s2.loli.net/2021/12/05/lZA15sPzoMQjyGt.png" alt="在这里插入图片描述"></p><h2 id="SM4代码介绍"><a href="#SM4代码介绍" class="headerlink" title="SM4代码介绍"></a>SM4代码介绍</h2><h3 id="定义S盒和FK-CK"><a href="#定义S盒和FK-CK" class="headerlink" title="定义S盒和FK,CK"></a>定义S盒和FK,CK</h3><p>如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># S盒</span>S_BOX <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0xD6</span><span class="token punctuation">,</span> <span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token number">0xE9</span><span class="token punctuation">,</span> <span class="token number">0xFE</span><span class="token punctuation">,</span> <span class="token number">0xCC</span><span class="token punctuation">,</span> <span class="token number">0xE1</span><span class="token punctuation">,</span> <span class="token number">0x3D</span><span class="token punctuation">,</span> <span class="token number">0xB7</span><span class="token punctuation">,</span> <span class="token number">0x16</span><span class="token punctuation">,</span> <span class="token number">0xB6</span><span class="token punctuation">,</span> <span class="token number">0x14</span><span class="token punctuation">,</span> <span class="token number">0xC2</span><span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">,</span> <span class="token number">0xFB</span><span class="token punctuation">,</span> <span class="token number">0x2C</span><span class="token punctuation">,</span> <span class="token number">0x05</span><span class="token punctuation">,</span> <span class="token number">0x2B</span><span class="token punctuation">,</span>       <span class="token number">0x67</span><span class="token punctuation">,</span> <span class="token number">0x9A</span><span class="token punctuation">,</span> <span class="token number">0x76</span><span class="token punctuation">,</span> <span class="token number">0x2A</span><span class="token punctuation">,</span> <span class="token number">0xBE</span><span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">,</span> <span class="token number">0xC3</span><span class="token punctuation">,</span> <span class="token number">0xAA</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">,</span> <span class="token number">0x13</span><span class="token punctuation">,</span> <span class="token number">0x26</span><span class="token punctuation">,</span> <span class="token number">0x49</span><span class="token punctuation">,</span> <span class="token number">0x86</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x9C</span><span class="token punctuation">,</span> <span class="token number">0x42</span><span class="token punctuation">,</span>       <span class="token number">0x50</span><span class="token punctuation">,</span> <span class="token number">0xF4</span><span class="token punctuation">,</span> <span class="token number">0x91</span><span class="token punctuation">,</span> <span class="token number">0xEF</span><span class="token punctuation">,</span> <span class="token number">0x98</span><span class="token punctuation">,</span> <span class="token number">0x7A</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">,</span> <span class="token number">0x54</span><span class="token punctuation">,</span> <span class="token number">0x0B</span><span class="token punctuation">,</span> <span class="token number">0x43</span><span class="token punctuation">,</span> <span class="token number">0xED</span><span class="token punctuation">,</span> <span class="token number">0xCF</span><span class="token punctuation">,</span> <span class="token number">0xAC</span><span class="token punctuation">,</span> <span class="token number">0x62</span><span class="token punctuation">,</span> <span class="token number">0xE4</span><span class="token punctuation">,</span> <span class="token number">0xB3</span><span class="token punctuation">,</span> <span class="token number">0x1C</span><span class="token punctuation">,</span>       <span class="token number">0xA9</span><span class="token punctuation">,</span> <span class="token number">0xC9</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0xE8</span><span class="token punctuation">,</span> <span class="token number">0x95</span><span class="token punctuation">,</span> <span class="token number">0x80</span><span class="token punctuation">,</span> <span class="token number">0xDF</span><span class="token punctuation">,</span> <span class="token number">0x94</span><span class="token punctuation">,</span> <span class="token number">0xFA</span><span class="token punctuation">,</span> <span class="token number">0x75</span><span class="token punctuation">,</span> <span class="token number">0x8F</span><span class="token punctuation">,</span> <span class="token number">0x3F</span><span class="token punctuation">,</span> <span class="token number">0xA6</span><span class="token punctuation">,</span> <span class="token number">0x47</span><span class="token punctuation">,</span> <span class="token number">0x07</span><span class="token punctuation">,</span> <span class="token number">0xA7</span><span class="token punctuation">,</span> <span class="token number">0xFC</span><span class="token punctuation">,</span>       <span class="token number">0xF3</span><span class="token punctuation">,</span> <span class="token number">0x73</span><span class="token punctuation">,</span> <span class="token number">0x17</span><span class="token punctuation">,</span> <span class="token number">0xBA</span><span class="token punctuation">,</span> <span class="token number">0x83</span><span class="token punctuation">,</span> <span class="token number">0x59</span><span class="token punctuation">,</span> <span class="token number">0x3C</span><span class="token punctuation">,</span> <span class="token number">0x19</span><span class="token punctuation">,</span> <span class="token number">0xE6</span><span class="token punctuation">,</span> <span class="token number">0x85</span><span class="token punctuation">,</span> <span class="token number">0x4F</span><span class="token punctuation">,</span> <span class="token number">0xA8</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token number">0x6B</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0xB2</span><span class="token punctuation">,</span> <span class="token number">0x71</span><span class="token punctuation">,</span>       <span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token number">0xDA</span><span class="token punctuation">,</span> <span class="token number">0x8B</span><span class="token punctuation">,</span> <span class="token number">0xF8</span><span class="token punctuation">,</span> <span class="token number">0xEB</span><span class="token punctuation">,</span> <span class="token number">0x0F</span><span class="token punctuation">,</span> <span class="token number">0x4B</span><span class="token punctuation">,</span> <span class="token number">0x70</span><span class="token punctuation">,</span> <span class="token number">0x56</span><span class="token punctuation">,</span> <span class="token number">0x9D</span><span class="token punctuation">,</span> <span class="token number">0x35</span><span class="token punctuation">,</span> <span class="token number">0x1E</span><span class="token punctuation">,</span> <span class="token number">0x24</span><span class="token punctuation">,</span> <span class="token number">0x0E</span><span class="token punctuation">,</span> <span class="token number">0x5E</span><span class="token punctuation">,</span> <span class="token number">0x63</span><span class="token punctuation">,</span> <span class="token number">0x58</span><span class="token punctuation">,</span>       <span class="token number">0xD1</span><span class="token punctuation">,</span> <span class="token number">0xA2</span><span class="token punctuation">,</span> <span class="token number">0x25</span><span class="token punctuation">,</span> <span class="token number">0x22</span><span class="token punctuation">,</span> <span class="token number">0x7C</span><span class="token punctuation">,</span> <span class="token number">0x3B</span><span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">,</span> <span class="token number">0x21</span><span class="token punctuation">,</span> <span class="token number">0x78</span><span class="token punctuation">,</span> <span class="token number">0x87</span><span class="token punctuation">,</span> <span class="token number">0xD4</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x46</span><span class="token punctuation">,</span> <span class="token number">0x57</span><span class="token punctuation">,</span> <span class="token number">0x9F</span><span class="token punctuation">,</span> <span class="token number">0xD3</span><span class="token punctuation">,</span> <span class="token number">0x27</span><span class="token punctuation">,</span>       <span class="token number">0x52</span><span class="token punctuation">,</span> <span class="token number">0x4C</span><span class="token punctuation">,</span> <span class="token number">0x36</span><span class="token punctuation">,</span> <span class="token number">0x02</span><span class="token punctuation">,</span> <span class="token number">0xE7</span><span class="token punctuation">,</span> <span class="token number">0xA0</span><span class="token punctuation">,</span> <span class="token number">0xC4</span><span class="token punctuation">,</span> <span class="token number">0xC8</span><span class="token punctuation">,</span> <span class="token number">0x9E</span><span class="token punctuation">,</span> <span class="token number">0xEA</span><span class="token punctuation">,</span> <span class="token number">0xBF</span><span class="token punctuation">,</span> <span class="token number">0x8A</span><span class="token punctuation">,</span> <span class="token number">0xD2</span><span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">,</span> <span class="token number">0xC7</span><span class="token punctuation">,</span> <span class="token number">0x38</span><span class="token punctuation">,</span> <span class="token number">0xB5</span><span class="token punctuation">,</span>       <span class="token number">0xA3</span><span class="token punctuation">,</span> <span class="token number">0xF7</span><span class="token punctuation">,</span> <span class="token number">0xF2</span><span class="token punctuation">,</span> <span class="token number">0xCE</span><span class="token punctuation">,</span> <span class="token number">0xF9</span><span class="token punctuation">,</span> <span class="token number">0x61</span><span class="token punctuation">,</span> <span class="token number">0x15</span><span class="token punctuation">,</span> <span class="token number">0xA1</span><span class="token punctuation">,</span> <span class="token number">0xE0</span><span class="token punctuation">,</span> <span class="token number">0xAE</span><span class="token punctuation">,</span> <span class="token number">0x5D</span><span class="token punctuation">,</span> <span class="token number">0xA4</span><span class="token punctuation">,</span> <span class="token number">0x9B</span><span class="token punctuation">,</span> <span class="token number">0x34</span><span class="token punctuation">,</span> <span class="token number">0x1A</span><span class="token punctuation">,</span> <span class="token number">0x55</span><span class="token punctuation">,</span> <span class="token number">0xAD</span><span class="token punctuation">,</span>       <span class="token number">0x93</span><span class="token punctuation">,</span> <span class="token number">0x32</span><span class="token punctuation">,</span> <span class="token number">0x30</span><span class="token punctuation">,</span> <span class="token number">0xF5</span><span class="token punctuation">,</span> <span class="token number">0x8C</span><span class="token punctuation">,</span> <span class="token number">0xB1</span><span class="token punctuation">,</span> <span class="token number">0xE3</span><span class="token punctuation">,</span> <span class="token number">0x1D</span><span class="token punctuation">,</span> <span class="token number">0xF6</span><span class="token punctuation">,</span> <span class="token number">0xE2</span><span class="token punctuation">,</span> <span class="token number">0x2E</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0xCA</span><span class="token punctuation">,</span> <span class="token number">0x60</span><span class="token punctuation">,</span> <span class="token number">0xC0</span><span class="token punctuation">,</span> <span class="token number">0x29</span><span class="token punctuation">,</span>       <span class="token number">0x23</span><span class="token punctuation">,</span> <span class="token number">0xAB</span><span class="token punctuation">,</span> <span class="token number">0x0D</span><span class="token punctuation">,</span> <span class="token number">0x53</span><span class="token punctuation">,</span> <span class="token number">0x4E</span><span class="token punctuation">,</span> <span class="token number">0x6F</span><span class="token punctuation">,</span> <span class="token number">0xD5</span><span class="token punctuation">,</span> <span class="token number">0xDB</span><span class="token punctuation">,</span> <span class="token number">0x37</span><span class="token punctuation">,</span> <span class="token number">0x45</span><span class="token punctuation">,</span> <span class="token number">0xDE</span><span class="token punctuation">,</span> <span class="token number">0xFD</span><span class="token punctuation">,</span> <span class="token number">0x8E</span><span class="token punctuation">,</span> <span class="token number">0x2F</span><span class="token punctuation">,</span> <span class="token number">0x03</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">,</span> <span class="token number">0x6A</span><span class="token punctuation">,</span>       <span class="token number">0x72</span><span class="token punctuation">,</span> <span class="token number">0x6D</span><span class="token punctuation">,</span> <span class="token number">0x6C</span><span class="token punctuation">,</span> <span class="token number">0x5B</span><span class="token punctuation">,</span> <span class="token number">0x51</span><span class="token punctuation">,</span> <span class="token number">0x8D</span><span class="token punctuation">,</span> <span class="token number">0x1B</span><span class="token punctuation">,</span> <span class="token number">0xAF</span><span class="token punctuation">,</span> <span class="token number">0x92</span><span class="token punctuation">,</span> <span class="token number">0xBB</span><span class="token punctuation">,</span> <span class="token number">0xDD</span><span class="token punctuation">,</span> <span class="token number">0xBC</span><span class="token punctuation">,</span> <span class="token number">0x7F</span><span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token number">0xD9</span><span class="token punctuation">,</span> <span class="token number">0x5C</span><span class="token punctuation">,</span> <span class="token number">0x41</span><span class="token punctuation">,</span>       <span class="token number">0x1F</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">,</span> <span class="token number">0x5A</span><span class="token punctuation">,</span> <span class="token number">0xD8</span><span class="token punctuation">,</span> <span class="token number">0x0A</span><span class="token punctuation">,</span> <span class="token number">0xC1</span><span class="token punctuation">,</span> <span class="token number">0x31</span><span class="token punctuation">,</span> <span class="token number">0x88</span><span class="token punctuation">,</span> <span class="token number">0xA5</span><span class="token punctuation">,</span> <span class="token number">0xCD</span><span class="token punctuation">,</span> <span class="token number">0x7B</span><span class="token punctuation">,</span> <span class="token number">0xBD</span><span class="token punctuation">,</span> <span class="token number">0x2D</span><span class="token punctuation">,</span> <span class="token number">0x74</span><span class="token punctuation">,</span> <span class="token number">0xD0</span><span class="token punctuation">,</span> <span class="token number">0x12</span><span class="token punctuation">,</span> <span class="token number">0xB8</span><span class="token punctuation">,</span>       <span class="token number">0xE5</span><span class="token punctuation">,</span> <span class="token number">0xB4</span><span class="token punctuation">,</span> <span class="token number">0xB0</span><span class="token punctuation">,</span> <span class="token number">0x89</span><span class="token punctuation">,</span> <span class="token number">0x69</span><span class="token punctuation">,</span> <span class="token number">0x97</span><span class="token punctuation">,</span> <span class="token number">0x4A</span><span class="token punctuation">,</span> <span class="token number">0x0C</span><span class="token punctuation">,</span> <span class="token number">0x96</span><span class="token punctuation">,</span> <span class="token number">0x77</span><span class="token punctuation">,</span> <span class="token number">0x7E</span><span class="token punctuation">,</span> <span class="token number">0x65</span><span class="token punctuation">,</span> <span class="token number">0xB9</span><span class="token punctuation">,</span> <span class="token number">0xF1</span><span class="token punctuation">,</span> <span class="token number">0x09</span><span class="token punctuation">,</span> <span class="token number">0xC5</span><span class="token punctuation">,</span> <span class="token number">0x6E</span><span class="token punctuation">,</span>       <span class="token number">0xC6</span><span class="token punctuation">,</span> <span class="token number">0x84</span><span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">,</span> <span class="token number">0xF0</span><span class="token punctuation">,</span> <span class="token number">0x7D</span><span class="token punctuation">,</span> <span class="token number">0xEC</span><span class="token punctuation">,</span> <span class="token number">0x3A</span><span class="token punctuation">,</span> <span class="token number">0xDC</span><span class="token punctuation">,</span> <span class="token number">0x4D</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x79</span><span class="token punctuation">,</span> <span class="token number">0xEE</span><span class="token punctuation">,</span> <span class="token number">0x5F</span><span class="token punctuation">,</span> <span class="token number">0x3E</span><span class="token punctuation">,</span> <span class="token number">0xD7</span><span class="token punctuation">,</span> <span class="token number">0xCB</span><span class="token punctuation">,</span> <span class="token number">0x39</span><span class="token punctuation">,</span>       <span class="token number">0x48</span><span class="token punctuation">]</span><span class="token comment"># 系统参数FK</span>FK <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0xa3b1bac6</span><span class="token punctuation">,</span> <span class="token number">0x56aa3350</span><span class="token punctuation">,</span> <span class="token number">0x677d9197</span><span class="token punctuation">,</span> <span class="token number">0xb27022dc</span><span class="token punctuation">]</span><span class="token comment"># 固定参数CK</span>CK <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0x00070e15</span><span class="token punctuation">,</span> <span class="token number">0x1c232a31</span><span class="token punctuation">,</span> <span class="token number">0x383f464d</span><span class="token punctuation">,</span> <span class="token number">0x545b6269</span><span class="token punctuation">,</span> <span class="token number">0x70777e85</span><span class="token punctuation">,</span> <span class="token number">0x8c939aa1</span><span class="token punctuation">,</span> <span class="token number">0xa8afb6bd</span><span class="token punctuation">,</span> <span class="token number">0xc4cbd2d9</span><span class="token punctuation">,</span>      <span class="token number">0xe0e7eef5</span><span class="token punctuation">,</span> <span class="token number">0xfc030a11</span><span class="token punctuation">,</span> <span class="token number">0x181f262d</span><span class="token punctuation">,</span> <span class="token number">0x343b4249</span><span class="token punctuation">,</span> <span class="token number">0x50575e65</span><span class="token punctuation">,</span> <span class="token number">0x6c737a81</span><span class="token punctuation">,</span> <span class="token number">0x888f969d</span><span class="token punctuation">,</span> <span class="token number">0xa4abb2b9</span><span class="token punctuation">,</span>      <span class="token number">0xc0c7ced5</span><span class="token punctuation">,</span> <span class="token number">0xdce3eaf1</span><span class="token punctuation">,</span> <span class="token number">0xf8ff060d</span><span class="token punctuation">,</span> <span class="token number">0x141b2229</span><span class="token punctuation">,</span> <span class="token number">0x30373e45</span><span class="token punctuation">,</span> <span class="token number">0x4c535a61</span><span class="token punctuation">,</span> <span class="token number">0x686f767d</span><span class="token punctuation">,</span> <span class="token number">0x848b9299</span><span class="token punctuation">,</span>      <span class="token number">0xa0a7aeb5</span><span class="token punctuation">,</span> <span class="token number">0xbcc3cad1</span><span class="token punctuation">,</span> <span class="token number">0xd8dfe6ed</span><span class="token punctuation">,</span> <span class="token number">0xf4fb0209</span><span class="token punctuation">,</span> <span class="token number">0x10171e25</span><span class="token punctuation">,</span> <span class="token number">0x2c333a41</span><span class="token punctuation">,</span> <span class="token number">0x484f565d</span><span class="token punctuation">,</span> <span class="token number">0x646b7279</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义T函数"><a href="#定义T函数" class="headerlink" title="定义T函数"></a>定义T函数</h3><p>$T(x)=L(τ(x))$</p><p>这里分别定义$τ(x)$和$L(x)$</p><p>$τ(x)$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@staticmethod</span><span class="token keyword">def</span> <span class="token function">_s_box</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 将 32bit 拆分成 4x8bit，依次进行S盒变换</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>S_BOX<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$L(x)$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token decorator annotation punctuation">@staticmethod</span><span class="token keyword">def</span> <span class="token function">_rot_left</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""循环左移"""</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">-</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_generate_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""密钥生成"""</span>    key_r<span class="token punctuation">,</span> key_temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token comment"># 将 128bit 拆分成 4x32bit</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        temp <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> i<span class="token punctuation">:</span><span class="token number">4</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span>        key_temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp <span class="token operator">^</span> FK<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token comment"># 循环生成轮密钥</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        box_in <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_temp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_temp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">^</span> CK<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        box_out <span class="token operator">=</span> self<span class="token punctuation">.</span>_s_box<span class="token punctuation">(</span>box_in<span class="token punctuation">)</span>        key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> box_out <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>        key_temp <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> key_r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主体循环（加密解密一样）"><a href="#主体循环（加密解密一样）" class="headerlink" title="主体循环（加密解密一样）"></a>主体循环（加密解密一样）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_do</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">,</span> key_r<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>       text_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>       <span class="token comment"># 将 128bit 转化成 4x32bit</span>       <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>           text_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>text<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> i<span class="token punctuation">:</span><span class="token number">4</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span>       <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>           box_in <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> text_<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">^</span> text_<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span>           box_out <span class="token operator">=</span> self<span class="token punctuation">.</span>_s_box<span class="token punctuation">(</span>box_in<span class="token punctuation">)</span>           temp <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> box_out <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>           temp <span class="token operator">=</span> temp <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span>           text_ <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>temp<span class="token punctuation">]</span>       text_ <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 结果逆序</span>       <span class="token comment"># 将 4x32bit 合并成 128bit</span>       result <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>           result<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>text_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token keyword">return</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加密解密接口"><a href="#加密解密接口" class="headerlink" title="加密解密接口"></a>加密解密接口</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> plaintext<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_do<span class="token punctuation">(</span>plaintext<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_key_r<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ciphertext<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_do<span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_key_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行验证"><a href="#运行验证" class="headerlink" title="运行验证"></a>运行验证</h3><p>这里只关注算法本身的加密，未实现分组密码的分组的加密模式和填充，故只支持标准的128bit输入和输出。</p><p>明文：<code>00112233445566778899aabbccddeeff</code></p><p>密钥：<code>0123456789ABCDEFFEDCBA9876543210</code></p><p>密文：<code>09325c4853832dcb9337a5984f671b9a</code></p><p>运行代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"16进制Key：0123456789ABCDEFFEDCBA9876543210"</span><span class="token punctuation">)</span>    <span class="token comment"># 128bit密钥</span>    key <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"0123456789ABCDEFFEDCBA9876543210"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"16进制明文：00112233445566778899aabbccddeeff"</span><span class="token punctuation">)</span>    <span class="token comment"># 128bit明文</span>    plaintext <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"00112233445566778899aabbccddeeff"</span><span class="token punctuation">)</span>    sm4 <span class="token operator">=</span> SM4Cipher<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"16进制密文："</span><span class="token operator">+</span> sm4<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 09325c4853832dcb9337a5984f671b9a</span>    encryption <span class="token operator">=</span> sm4<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    encryp_txt <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>encryption<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"16进制解密密文："</span><span class="token operator">+</span>sm4<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>encryp_txt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="https://s2.loli.net/2021/12/05/MhitfE7LwINscRU.png" alt="image-20211205163627150"></p><p>网站验证：</p><p>网站：<a href="https://the-x.cn/cryptography/Sm4.aspx">SM4加密网站</a>:  <a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="https://s2.loli.net/2021/12/05/ol8TypPBFCHhbXx.png" alt="image-20211205163922636"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""@Time    : 2021/12/5@Author  : LowlyLi@Version : 1.0@File    : SM4.py@Introduce: SM4 国密4"""</span><span class="token comment"># S盒</span>S_BOX <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0xD6</span><span class="token punctuation">,</span> <span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token number">0xE9</span><span class="token punctuation">,</span> <span class="token number">0xFE</span><span class="token punctuation">,</span> <span class="token number">0xCC</span><span class="token punctuation">,</span> <span class="token number">0xE1</span><span class="token punctuation">,</span> <span class="token number">0x3D</span><span class="token punctuation">,</span> <span class="token number">0xB7</span><span class="token punctuation">,</span> <span class="token number">0x16</span><span class="token punctuation">,</span> <span class="token number">0xB6</span><span class="token punctuation">,</span> <span class="token number">0x14</span><span class="token punctuation">,</span> <span class="token number">0xC2</span><span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">,</span> <span class="token number">0xFB</span><span class="token punctuation">,</span> <span class="token number">0x2C</span><span class="token punctuation">,</span> <span class="token number">0x05</span><span class="token punctuation">,</span> <span class="token number">0x2B</span><span class="token punctuation">,</span>       <span class="token number">0x67</span><span class="token punctuation">,</span> <span class="token number">0x9A</span><span class="token punctuation">,</span> <span class="token number">0x76</span><span class="token punctuation">,</span> <span class="token number">0x2A</span><span class="token punctuation">,</span> <span class="token number">0xBE</span><span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">,</span> <span class="token number">0xC3</span><span class="token punctuation">,</span> <span class="token number">0xAA</span><span class="token punctuation">,</span> <span class="token number">0x44</span><span class="token punctuation">,</span> <span class="token number">0x13</span><span class="token punctuation">,</span> <span class="token number">0x26</span><span class="token punctuation">,</span> <span class="token number">0x49</span><span class="token punctuation">,</span> <span class="token number">0x86</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">,</span> <span class="token number">0x99</span><span class="token punctuation">,</span> <span class="token number">0x9C</span><span class="token punctuation">,</span> <span class="token number">0x42</span><span class="token punctuation">,</span>       <span class="token number">0x50</span><span class="token punctuation">,</span> <span class="token number">0xF4</span><span class="token punctuation">,</span> <span class="token number">0x91</span><span class="token punctuation">,</span> <span class="token number">0xEF</span><span class="token punctuation">,</span> <span class="token number">0x98</span><span class="token punctuation">,</span> <span class="token number">0x7A</span><span class="token punctuation">,</span> <span class="token number">0x33</span><span class="token punctuation">,</span> <span class="token number">0x54</span><span class="token punctuation">,</span> <span class="token number">0x0B</span><span class="token punctuation">,</span> <span class="token number">0x43</span><span class="token punctuation">,</span> <span class="token number">0xED</span><span class="token punctuation">,</span> <span class="token number">0xCF</span><span class="token punctuation">,</span> <span class="token number">0xAC</span><span class="token punctuation">,</span> <span class="token number">0x62</span><span class="token punctuation">,</span> <span class="token number">0xE4</span><span class="token punctuation">,</span> <span class="token number">0xB3</span><span class="token punctuation">,</span> <span class="token number">0x1C</span><span class="token punctuation">,</span>       <span class="token number">0xA9</span><span class="token punctuation">,</span> <span class="token number">0xC9</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0xE8</span><span class="token punctuation">,</span> <span class="token number">0x95</span><span class="token punctuation">,</span> <span class="token number">0x80</span><span class="token punctuation">,</span> <span class="token number">0xDF</span><span class="token punctuation">,</span> <span class="token number">0x94</span><span class="token punctuation">,</span> <span class="token number">0xFA</span><span class="token punctuation">,</span> <span class="token number">0x75</span><span class="token punctuation">,</span> <span class="token number">0x8F</span><span class="token punctuation">,</span> <span class="token number">0x3F</span><span class="token punctuation">,</span> <span class="token number">0xA6</span><span class="token punctuation">,</span> <span class="token number">0x47</span><span class="token punctuation">,</span> <span class="token number">0x07</span><span class="token punctuation">,</span> <span class="token number">0xA7</span><span class="token punctuation">,</span> <span class="token number">0xFC</span><span class="token punctuation">,</span>       <span class="token number">0xF3</span><span class="token punctuation">,</span> <span class="token number">0x73</span><span class="token punctuation">,</span> <span class="token number">0x17</span><span class="token punctuation">,</span> <span class="token number">0xBA</span><span class="token punctuation">,</span> <span class="token number">0x83</span><span class="token punctuation">,</span> <span class="token number">0x59</span><span class="token punctuation">,</span> <span class="token number">0x3C</span><span class="token punctuation">,</span> <span class="token number">0x19</span><span class="token punctuation">,</span> <span class="token number">0xE6</span><span class="token punctuation">,</span> <span class="token number">0x85</span><span class="token punctuation">,</span> <span class="token number">0x4F</span><span class="token punctuation">,</span> <span class="token number">0xA8</span><span class="token punctuation">,</span> <span class="token number">0x68</span><span class="token punctuation">,</span> <span class="token number">0x6B</span><span class="token punctuation">,</span> <span class="token number">0x81</span><span class="token punctuation">,</span> <span class="token number">0xB2</span><span class="token punctuation">,</span> <span class="token number">0x71</span><span class="token punctuation">,</span>       <span class="token number">0x64</span><span class="token punctuation">,</span> <span class="token number">0xDA</span><span class="token punctuation">,</span> <span class="token number">0x8B</span><span class="token punctuation">,</span> <span class="token number">0xF8</span><span class="token punctuation">,</span> <span class="token number">0xEB</span><span class="token punctuation">,</span> <span class="token number">0x0F</span><span class="token punctuation">,</span> <span class="token number">0x4B</span><span class="token punctuation">,</span> <span class="token number">0x70</span><span class="token punctuation">,</span> <span class="token number">0x56</span><span class="token punctuation">,</span> <span class="token number">0x9D</span><span class="token punctuation">,</span> <span class="token number">0x35</span><span class="token punctuation">,</span> <span class="token number">0x1E</span><span class="token punctuation">,</span> <span class="token number">0x24</span><span class="token punctuation">,</span> <span class="token number">0x0E</span><span class="token punctuation">,</span> <span class="token number">0x5E</span><span class="token punctuation">,</span> <span class="token number">0x63</span><span class="token punctuation">,</span> <span class="token number">0x58</span><span class="token punctuation">,</span>       <span class="token number">0xD1</span><span class="token punctuation">,</span> <span class="token number">0xA2</span><span class="token punctuation">,</span> <span class="token number">0x25</span><span class="token punctuation">,</span> <span class="token number">0x22</span><span class="token punctuation">,</span> <span class="token number">0x7C</span><span class="token punctuation">,</span> <span class="token number">0x3B</span><span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">,</span> <span class="token number">0x21</span><span class="token punctuation">,</span> <span class="token number">0x78</span><span class="token punctuation">,</span> <span class="token number">0x87</span><span class="token punctuation">,</span> <span class="token number">0xD4</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x46</span><span class="token punctuation">,</span> <span class="token number">0x57</span><span class="token punctuation">,</span> <span class="token number">0x9F</span><span class="token punctuation">,</span> <span class="token number">0xD3</span><span class="token punctuation">,</span> <span class="token number">0x27</span><span class="token punctuation">,</span>       <span class="token number">0x52</span><span class="token punctuation">,</span> <span class="token number">0x4C</span><span class="token punctuation">,</span> <span class="token number">0x36</span><span class="token punctuation">,</span> <span class="token number">0x02</span><span class="token punctuation">,</span> <span class="token number">0xE7</span><span class="token punctuation">,</span> <span class="token number">0xA0</span><span class="token punctuation">,</span> <span class="token number">0xC4</span><span class="token punctuation">,</span> <span class="token number">0xC8</span><span class="token punctuation">,</span> <span class="token number">0x9E</span><span class="token punctuation">,</span> <span class="token number">0xEA</span><span class="token punctuation">,</span> <span class="token number">0xBF</span><span class="token punctuation">,</span> <span class="token number">0x8A</span><span class="token punctuation">,</span> <span class="token number">0xD2</span><span class="token punctuation">,</span> <span class="token number">0x40</span><span class="token punctuation">,</span> <span class="token number">0xC7</span><span class="token punctuation">,</span> <span class="token number">0x38</span><span class="token punctuation">,</span> <span class="token number">0xB5</span><span class="token punctuation">,</span>       <span class="token number">0xA3</span><span class="token punctuation">,</span> <span class="token number">0xF7</span><span class="token punctuation">,</span> <span class="token number">0xF2</span><span class="token punctuation">,</span> <span class="token number">0xCE</span><span class="token punctuation">,</span> <span class="token number">0xF9</span><span class="token punctuation">,</span> <span class="token number">0x61</span><span class="token punctuation">,</span> <span class="token number">0x15</span><span class="token punctuation">,</span> <span class="token number">0xA1</span><span class="token punctuation">,</span> <span class="token number">0xE0</span><span class="token punctuation">,</span> <span class="token number">0xAE</span><span class="token punctuation">,</span> <span class="token number">0x5D</span><span class="token punctuation">,</span> <span class="token number">0xA4</span><span class="token punctuation">,</span> <span class="token number">0x9B</span><span class="token punctuation">,</span> <span class="token number">0x34</span><span class="token punctuation">,</span> <span class="token number">0x1A</span><span class="token punctuation">,</span> <span class="token number">0x55</span><span class="token punctuation">,</span> <span class="token number">0xAD</span><span class="token punctuation">,</span>       <span class="token number">0x93</span><span class="token punctuation">,</span> <span class="token number">0x32</span><span class="token punctuation">,</span> <span class="token number">0x30</span><span class="token punctuation">,</span> <span class="token number">0xF5</span><span class="token punctuation">,</span> <span class="token number">0x8C</span><span class="token punctuation">,</span> <span class="token number">0xB1</span><span class="token punctuation">,</span> <span class="token number">0xE3</span><span class="token punctuation">,</span> <span class="token number">0x1D</span><span class="token punctuation">,</span> <span class="token number">0xF6</span><span class="token punctuation">,</span> <span class="token number">0xE2</span><span class="token punctuation">,</span> <span class="token number">0x2E</span><span class="token punctuation">,</span> <span class="token number">0x82</span><span class="token punctuation">,</span> <span class="token number">0x66</span><span class="token punctuation">,</span> <span class="token number">0xCA</span><span class="token punctuation">,</span> <span class="token number">0x60</span><span class="token punctuation">,</span> <span class="token number">0xC0</span><span class="token punctuation">,</span> <span class="token number">0x29</span><span class="token punctuation">,</span>       <span class="token number">0x23</span><span class="token punctuation">,</span> <span class="token number">0xAB</span><span class="token punctuation">,</span> <span class="token number">0x0D</span><span class="token punctuation">,</span> <span class="token number">0x53</span><span class="token punctuation">,</span> <span class="token number">0x4E</span><span class="token punctuation">,</span> <span class="token number">0x6F</span><span class="token punctuation">,</span> <span class="token number">0xD5</span><span class="token punctuation">,</span> <span class="token number">0xDB</span><span class="token punctuation">,</span> <span class="token number">0x37</span><span class="token punctuation">,</span> <span class="token number">0x45</span><span class="token punctuation">,</span> <span class="token number">0xDE</span><span class="token punctuation">,</span> <span class="token number">0xFD</span><span class="token punctuation">,</span> <span class="token number">0x8E</span><span class="token punctuation">,</span> <span class="token number">0x2F</span><span class="token punctuation">,</span> <span class="token number">0x03</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">,</span> <span class="token number">0x6A</span><span class="token punctuation">,</span>       <span class="token number">0x72</span><span class="token punctuation">,</span> <span class="token number">0x6D</span><span class="token punctuation">,</span> <span class="token number">0x6C</span><span class="token punctuation">,</span> <span class="token number">0x5B</span><span class="token punctuation">,</span> <span class="token number">0x51</span><span class="token punctuation">,</span> <span class="token number">0x8D</span><span class="token punctuation">,</span> <span class="token number">0x1B</span><span class="token punctuation">,</span> <span class="token number">0xAF</span><span class="token punctuation">,</span> <span class="token number">0x92</span><span class="token punctuation">,</span> <span class="token number">0xBB</span><span class="token punctuation">,</span> <span class="token number">0xDD</span><span class="token punctuation">,</span> <span class="token number">0xBC</span><span class="token punctuation">,</span> <span class="token number">0x7F</span><span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">,</span> <span class="token number">0xD9</span><span class="token punctuation">,</span> <span class="token number">0x5C</span><span class="token punctuation">,</span> <span class="token number">0x41</span><span class="token punctuation">,</span>       <span class="token number">0x1F</span><span class="token punctuation">,</span> <span class="token number">0x10</span><span class="token punctuation">,</span> <span class="token number">0x5A</span><span class="token punctuation">,</span> <span class="token number">0xD8</span><span class="token punctuation">,</span> <span class="token number">0x0A</span><span class="token punctuation">,</span> <span class="token number">0xC1</span><span class="token punctuation">,</span> <span class="token number">0x31</span><span class="token punctuation">,</span> <span class="token number">0x88</span><span class="token punctuation">,</span> <span class="token number">0xA5</span><span class="token punctuation">,</span> <span class="token number">0xCD</span><span class="token punctuation">,</span> <span class="token number">0x7B</span><span class="token punctuation">,</span> <span class="token number">0xBD</span><span class="token punctuation">,</span> <span class="token number">0x2D</span><span class="token punctuation">,</span> <span class="token number">0x74</span><span class="token punctuation">,</span> <span class="token number">0xD0</span><span class="token punctuation">,</span> <span class="token number">0x12</span><span class="token punctuation">,</span> <span class="token number">0xB8</span><span class="token punctuation">,</span>       <span class="token number">0xE5</span><span class="token punctuation">,</span> <span class="token number">0xB4</span><span class="token punctuation">,</span> <span class="token number">0xB0</span><span class="token punctuation">,</span> <span class="token number">0x89</span><span class="token punctuation">,</span> <span class="token number">0x69</span><span class="token punctuation">,</span> <span class="token number">0x97</span><span class="token punctuation">,</span> <span class="token number">0x4A</span><span class="token punctuation">,</span> <span class="token number">0x0C</span><span class="token punctuation">,</span> <span class="token number">0x96</span><span class="token punctuation">,</span> <span class="token number">0x77</span><span class="token punctuation">,</span> <span class="token number">0x7E</span><span class="token punctuation">,</span> <span class="token number">0x65</span><span class="token punctuation">,</span> <span class="token number">0xB9</span><span class="token punctuation">,</span> <span class="token number">0xF1</span><span class="token punctuation">,</span> <span class="token number">0x09</span><span class="token punctuation">,</span> <span class="token number">0xC5</span><span class="token punctuation">,</span> <span class="token number">0x6E</span><span class="token punctuation">,</span>       <span class="token number">0xC6</span><span class="token punctuation">,</span> <span class="token number">0x84</span><span class="token punctuation">,</span> <span class="token number">0x18</span><span class="token punctuation">,</span> <span class="token number">0xF0</span><span class="token punctuation">,</span> <span class="token number">0x7D</span><span class="token punctuation">,</span> <span class="token number">0xEC</span><span class="token punctuation">,</span> <span class="token number">0x3A</span><span class="token punctuation">,</span> <span class="token number">0xDC</span><span class="token punctuation">,</span> <span class="token number">0x4D</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token number">0x79</span><span class="token punctuation">,</span> <span class="token number">0xEE</span><span class="token punctuation">,</span> <span class="token number">0x5F</span><span class="token punctuation">,</span> <span class="token number">0x3E</span><span class="token punctuation">,</span> <span class="token number">0xD7</span><span class="token punctuation">,</span> <span class="token number">0xCB</span><span class="token punctuation">,</span> <span class="token number">0x39</span><span class="token punctuation">,</span>       <span class="token number">0x48</span><span class="token punctuation">]</span><span class="token comment"># 系统参数FK</span>FK <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0xa3b1bac6</span><span class="token punctuation">,</span> <span class="token number">0x56aa3350</span><span class="token punctuation">,</span> <span class="token number">0x677d9197</span><span class="token punctuation">,</span> <span class="token number">0xb27022dc</span><span class="token punctuation">]</span><span class="token comment"># 固定参数CK</span>CK <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0x00070e15</span><span class="token punctuation">,</span> <span class="token number">0x1c232a31</span><span class="token punctuation">,</span> <span class="token number">0x383f464d</span><span class="token punctuation">,</span> <span class="token number">0x545b6269</span><span class="token punctuation">,</span> <span class="token number">0x70777e85</span><span class="token punctuation">,</span> <span class="token number">0x8c939aa1</span><span class="token punctuation">,</span> <span class="token number">0xa8afb6bd</span><span class="token punctuation">,</span> <span class="token number">0xc4cbd2d9</span><span class="token punctuation">,</span>      <span class="token number">0xe0e7eef5</span><span class="token punctuation">,</span> <span class="token number">0xfc030a11</span><span class="token punctuation">,</span> <span class="token number">0x181f262d</span><span class="token punctuation">,</span> <span class="token number">0x343b4249</span><span class="token punctuation">,</span> <span class="token number">0x50575e65</span><span class="token punctuation">,</span> <span class="token number">0x6c737a81</span><span class="token punctuation">,</span> <span class="token number">0x888f969d</span><span class="token punctuation">,</span> <span class="token number">0xa4abb2b9</span><span class="token punctuation">,</span>      <span class="token number">0xc0c7ced5</span><span class="token punctuation">,</span> <span class="token number">0xdce3eaf1</span><span class="token punctuation">,</span> <span class="token number">0xf8ff060d</span><span class="token punctuation">,</span> <span class="token number">0x141b2229</span><span class="token punctuation">,</span> <span class="token number">0x30373e45</span><span class="token punctuation">,</span> <span class="token number">0x4c535a61</span><span class="token punctuation">,</span> <span class="token number">0x686f767d</span><span class="token punctuation">,</span> <span class="token number">0x848b9299</span><span class="token punctuation">,</span>      <span class="token number">0xa0a7aeb5</span><span class="token punctuation">,</span> <span class="token number">0xbcc3cad1</span><span class="token punctuation">,</span> <span class="token number">0xd8dfe6ed</span><span class="token punctuation">,</span> <span class="token number">0xf4fb0209</span><span class="token punctuation">,</span> <span class="token number">0x10171e25</span><span class="token punctuation">,</span> <span class="token number">0x2c333a41</span><span class="token punctuation">,</span> <span class="token number">0x484f565d</span><span class="token punctuation">,</span> <span class="token number">0x646b7279</span><span class="token punctuation">]</span><span class="token keyword">class</span> <span class="token class-name">SM4Cipher</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">16</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"SM4 key must be length of 16. "</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_key_r <span class="token operator">=</span> self<span class="token punctuation">.</span>_generate_key<span class="token punctuation">(</span>key<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>block_size <span class="token operator">=</span> <span class="token number">16</span>    <span class="token keyword">def</span> <span class="token function">encrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> plaintext<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_do<span class="token punctuation">(</span>plaintext<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_key_r<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ciphertext<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_do<span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span> self<span class="token punctuation">.</span>_key_r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_do</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">,</span> key_r<span class="token punctuation">:</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        text_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 将 128bit 转化成 4x32bit</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            text_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>text<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> i<span class="token punctuation">:</span><span class="token number">4</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            box_in <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> text_<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">^</span> text_<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            box_out <span class="token operator">=</span> self<span class="token punctuation">.</span>_s_box<span class="token punctuation">(</span>box_in<span class="token punctuation">)</span>            temp <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> box_out <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>            temp <span class="token operator">=</span> temp <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span>            text_ <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>temp<span class="token punctuation">]</span>        text_ <span class="token operator">=</span> text_<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment"># 结果逆序</span>        <span class="token comment"># 将 4x32bit 合并成 128bit</span>        result <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>text_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">bytes</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_generate_key</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">:</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""密钥生成"""</span>        key_r<span class="token punctuation">,</span> key_temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment"># 将 128bit 拆分成 4x32bit</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> i<span class="token punctuation">:</span><span class="token number">4</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span>            key_temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp <span class="token operator">^</span> FK<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token comment"># 循环生成轮密钥</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            box_in <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_temp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">^</span> key_temp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">^</span> CK<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            box_out <span class="token operator">=</span> self<span class="token punctuation">.</span>_s_box<span class="token punctuation">(</span>box_in<span class="token punctuation">)</span>            key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> box_out <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token operator">^</span> self<span class="token punctuation">.</span>_rot_left<span class="token punctuation">(</span>box_out<span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>            key_temp <span class="token operator">=</span> key_temp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span>key_r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> key_r    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">_s_box</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> <span class="token builtin">bytearray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 将 32bit 拆分成 4x8bit，依次进行S盒变换</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>S_BOX<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">'big'</span><span class="token punctuation">)</span>    <span class="token decorator annotation punctuation">@staticmethod</span>    <span class="token keyword">def</span> <span class="token function">_rot_left</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""循环左移"""</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> m<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">-</span> m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFF</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>     <span class="token comment"># 128bit密钥</span>    key <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"0123456789ABCDEFFEDCBA9876543210"</span><span class="token punctuation">)</span>     <span class="token comment"># 128bit明文</span>    plaintext <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">"00112233445566778899aabbccddeeff"</span><span class="token punctuation">)</span>      sm4 <span class="token operator">=</span> SM4Cipher<span class="token punctuation">(</span>key<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sm4<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment"># 09325c4853832dcb9337a5984f671b9a</span>    encryption <span class="token operator">=</span> sm4<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>plaintext<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    encryp_txt <span class="token operator">=</span> <span class="token builtin">bytes</span><span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>encryption<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sm4<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>encryp_txt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">hex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 00112233445566778899aabbccddeeff</span><span class="token triple-quoted-string string">"""# 样例一key = "0123456789ABCDEFFEDCBA9876543210"  # 16进制字符串plaintext = "0123456789ABCDEFFEDCBA9876543210"  # 16进制字符串ciphertext = "681edf34d206965e86b3e94f536e4246"  # 16进制字符串# 样例二key = "0123456789ABCDEFFEDCBA9876543210"  # 16进制字符串plaintext = "00112233445566778899aabbccddeeff"  # 16进制字符串ciphertext = "09325c4853832dcb9337a5984f671b9a"  # 16进制字符串# 样例三key = "456789ABCDEFFEDCBA98765432100123"  # 16进制字符串plaintext = "2233445566778899aabbccddeeff0011"  # 16进制字符串ciphertext = "58ab414d84fb3008b0bee987f97021e6"  # 16进制字符串# 样例四key = "89ABCDEFFEDCBA987654321001234567"  # 16进制字符串plaintext = "445566778899aabbccddeeff00112233"  # 16进制字符串ciphertext = "5937a929a2d9137216c72a28cd9cf619"  # 16进制字符串"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paillier算法</title>
      <link href="/2021/12/03/2021-12-3-paillier-suan-fa/"/>
      <url>/2021/12/03/2021-12-3-paillier-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Paillier算法"><a href="#Paillier算法" class="headerlink" title="Paillier算法"></a>Paillier算法</h1><blockquote><p>作者：lowlyli</p><p>时间：2021-12-3</p><p>选题原因：这部分是联邦学习里面的最基础的同态加密，机器学习其实也只是简单的线性运算$y=a*x+b$ ，而同态加密实现加密后运算保存一致，造就了在敏感数据行业机器学习，云计算的发展，采用联邦学习的分布式计算可以有效运用在金融，医疗等敏感信息上，随着个人隐私的加强，无法得到明文数据时，同态加密或许会成为互联网企业进行用户画像分析的下一个突破点。</p></blockquote><h2 id="同态加密介绍"><a href="#同态加密介绍" class="headerlink" title="同态加密介绍"></a>同态加密介绍</h2><h3 id="同态加密"><a href="#同态加密" class="headerlink" title="同态加密"></a>同态加密</h3><p><strong>同态加密</strong>（英语：<strong>Homomorphic encryption</strong>）是一种加密形式，它允许人们对密文进行特定形式的代数运算得到仍然是加密的结果，将其解密所得到的结果与对明文进行同样的运算结果一样。换言之，这项技术令人们可以在加密的数据中进行诸如检索、比较等操作，得出正确的结果，而在整个处理过程中无需对数据进行解密。其意义在于，真正从根本上解决将数据及其操作委托给第三方时的保密问题，例如对于各种云计算的应用。</p><p>本质上，同态加密是指这样一种加密函数，对明文进行环上的加法和乘法运算再加密，与加密后对密文进行相应的运算，结果是等价的。由于这个良好的性质，人们可以委托第三方对数据进行处理而不泄露信息。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>简单定义</strong></p><p>一种加密算法E()和相应的解密算法D()。</p><p>$⊕$和$⊙$为某种数学运算。</p><p>如果加密算法满足：$E(x + y) = E(x) ⊕ E(y)$，我们将这种加密函数叫做加法同态 。</p><p>如果加密算法满足：$E(x * y) = E(x) ⊙ E(y)$，我们将这种加密函数叫做乘法同态 。</p><p><strong>严格定义</strong></p><p>同态加密的思想起源于私密同态，代数同态和算术同态是私密同态的子集。</p><p>$R$ 和 $S$ 是域，称加密函数 $E：R→S $为：</p><p>加法同态，如果存在有效算法$⊕$，$E(x+y)=E(x)⊕E(y)$或者 $x+y=D(E(x)⊕E(y))$成立，并且不泄漏 $x$ 和 $ y$。</p><p>乘法同态，如果存在有效算法$\otimes$ ，$E(xy)=E(x) \otimes E(y)$或者 $xy=D(E(x)\otimes E(y))$成立，并且不泄漏 $x $和 $y$。</p><p>混合乘法同态，如果存在有效算法$\odot$ ，$E(x×y)=E(x)\odot y$ 或者 $xy=D(E(x)\odot y)$成立，并且不泄漏$ x$。</p><p>减法同态，如果存在有效算法$\ominus$ ，$E(x-y)=E(x)\ominus E(y)$或者 $x-y=D(E(x)\ominus E(y))$成立，并且不泄漏 $x$ 和 $ y$，则称$ E() $为减法同态。</p><p>除法同态，如果存在有效算法$\oslash$，$E(x/y)=E(x)\oslash E(y)$或者 $x/y=D(E(x)\oslash E(y))$成立，并且不泄漏$ x $和 $ y$，则称 $E() $为除法同态。</p><p>代数同态，如果 E 既是加法同态又是乘法同态。</p><p>算术同态，如果 E 同时为加法同态、减法同态、乘法同态和除法同态。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>半同态加密 （Partial Homomorphic Encryption, PHE）</strong>：只支持某些特定的运算法则 f ,PHE 的优点是原理简单、易实现，缺点是仅支持一种运算(加法或乘法)；</p><p><strong>层次同态加密（Liveled HE，LHE）</strong>：一般支持有限次数的加密算法,LHE 的优点是同时支持加法和乘法，并且因为出现时间比 PHE 晚，所以技术更加成熟、一般效率比 FHE 要高很多、和 PHE 效率接近或高于 PHE，缺点是支持的计算次数有限。</p><p><strong>全同态加密 （Fully Homomorphic Encryption, FHE）</strong>：支持无限次的任意运算法则 f，FHE 有以下类别：基于理想格的 FHE 方案、基于 LWE/RLWE 的 FHE 方案等等。FHE 的优点是支持的算子多并且运算次数没有限制，缺点是效率很低，目前还无法支撑大规模的计算。</p><p>第一个满足加法和乘法同态的同态加密方法直到2009年才由Craig Gentry提出。目前来说，全同态加密算法性能较差，应用较少。</p><p>比较常用的是半同态加密算法，实现方式有 RSA （乘法同态）、Elgamal（乘法同态）、Paillier （加法同态）等。</p><h2 id="Paillier算法介绍"><a href="#Paillier算法介绍" class="headerlink" title="Paillier算法介绍"></a>Paillier算法介绍</h2><p>Paillier同态加密是由Pascal Paillier于1999年提出并命名的密码学理论。它是⼀种基于公私钥密码学的概率非对称算法。</p><p>这套理论是⼀个加法同态加密算法，意味着，只要给定公钥和需要加密的信息和，就可以计算加密后的和之和，再可以⽤私钥解密结果，这整个过程精度没有损失。</p><h3 id="算法理论"><a href="#算法理论" class="headerlink" title="算法理论"></a>算法理论</h3><p>Paillier 加密算法作为一种适用性非常广泛的同态公钥加密算法，因基于合数阶剩余类的难解性问题，使得该算法能够应用于许多实际的场景中，下面就 paillier算法的难解问题进行说明。 </p><p>设<script type="math/tex">n= pq</script>，其中<script type="math/tex">p,q</script>为 2 个大素数，<script type="math/tex">\varphi(n)</script>为欧拉函数，</p><script type="math/tex; mode=display">\varphi(n)=(p-1)(q-1)</script><p>Caemichael 函数 $λ(n) = lcm( p-1, q-1)$，</p><script type="math/tex; mode=display">|Z_{n^2}^*|= \varphi(n^2)= n\varphi(n),\\\forall \omega \in Z_{n^2}^* \ \ \ {\omega}^{\lambda} = 1 \bmod\ n,\ \ {\omega}^{n\lambda}=1 \bmod \ n^2</script><p>为直观起见，以下所有的 $λ(n)$用$λ$表示。根据 Caemichael 理论有整数值的函数<script type="math/tex">ε_g</script>定义如下：<script type="math/tex">Z _ {n} \times Z _ {n}^{ * } \rightarrow Z _ {n^{2}}^{ * },(x, y) \rightarrow g^{x} \cdot y^{n} \bmod n^{2}</script>，如果<script type="math/tex">g</script>在<script type="math/tex">Z _ {n^{2}}^{ * }</script>中阶为<script type="math/tex">n</script>的倍数，则<script type="math/tex">ε _ g</script>是一一映射。既对于给定的</p><script type="math/tex; mode=display">\omega \in Z_{n^2}^*,x\in Z_n,\exists y \in Z_{n}^* \ 使得 \varepsilon_{g}(x, y)=\omega</script><p>这样的 <script type="math/tex">\varepsilon_{g}(x, y)</script>称为 <script type="math/tex">\omega</script>  的 n-residousity class, 用 <script type="math/tex">[[\omega]] _ {g}</script>表示。</p><p>目前认为, 对于给定的  <script type="math/tex">n, g, \omega</script> , 计算  <script type="math/tex">[[\omega ]] _ {g}</script>  的问题是困难的, 这也就是 Composite Residousity Assumption(CRA)。</p><p>但是依据  <script type="math/tex">p, q</script> 的知识, 也就是  $\lambda$ , 可以计算出任意的<script type="math/tex">[[\omega ]] _ {g}</script> 事实上, 设<script type="math/tex">S _ {n}=\left\{u<n^{2} \mid u=1 \bmod n\right\}, \forall u \in S _ {n}, L(u)=\frac{u-1}{n}</script> , 则有如下的结果: </p><script type="math/tex; mode=display">[[\omega]]_{g}=\frac{L\left(\omega^{\lambda} \bmod n^{2}\right)}{L\left(g^{\lambda} \bmod n^{2}\right)} \bmod n</script><blockquote><p>补充：Carmichael function[卡迈克尔函数相关性质]</p><p><strong>定义</strong></p><p>在数论中，Carmichael函数的定义为使得$a^m ≡ 1   \bmod   n \ $成立的最小正整数$m$ 其中$( a , n ) = 1$ 将$m$记作$ \lambda(n)$。在抽象代数术语中，$ \lambda(n)$是模$n$的乘法群的指数。</p><p>Carmichael函数也被称为规约函数(reduced totient function)以及最小泛指数函数(least universal exponent function)。</p><p><strong>用Carmichael定理计算</strong><script type="math/tex">\lambda(n)</script><br>根据唯一因式分解定理，任何$n&gt;1$的整数都可以用唯一的方式写成</p><script type="math/tex; mode=display">n=p_{1}^{r_{1}} p_{2}^{r_{2}} \cdots p_{k}^{r_{k}}</script><p>其中，<script type="math/tex">p _ {1}<p _ {2}<\ldots<p _ {k}</script>  是有小到大排列的素数,<script type="math/tex">r _ {1}, r _ {2}, \ldots, r _ {k}</script>是正整数。那么，<script type="math/tex">\lambda(n)</script>就是其中每一项的<script type="math/tex">λ</script>的最小公倍数，有：</p><script type="math/tex; mode=display">\lambda(n)=\operatorname{lcm}\left(\lambda\left(p_{1}^{r_{1}}\right), \lambda\left(p_{2}^{r_{2}}\right), \ldots, \lambda\left(p_{k}^{r_{k}}\right)\right)</script><p>上述的公式可由中国剩余定理来证明。</p><p><strong>Carmichael函数的性质</strong><br>设 $ a$ 和 $ n $ 互素， $ m $ 是最小指数，  <script type="math/tex">a^{m} \equiv 1 \bmod n</script>  ，那么有:</p><script type="math/tex; mode=display">m \mid \lambda(n)</script><p>也就是说，模$n$整数环中任意元素 $ a $ 的阶$  m:=\operatorname{ord}_{n}(a) $ 整除$  \lambda(n)  $。同时还有:</p><script type="math/tex; mode=display">\lambda(n)=\max \left\{\operatorname{ord}_{n}(a): \operatorname{gcd}(a, n)=1\right\}\\ a|b \Rightarrow \lambda(a)| \lambda(b) \\  \lambda(\operatorname{lcm}(a, b))=\operatorname{lcm}(\lambda(a), \lambda(b))</script></blockquote><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p><strong>(1) 密钥产生</strong></p><p>选取两个随机的大素数<script type="math/tex">p, q</script> ，计算 <script type="math/tex">n=p * q</script> 和 <script type="math/tex">\lambda=lcm(p-1, q-1)</script> .选取随机数 $g$ ，<script type="math/tex">g \in \mathbb{Z}_{n^{2}}^{ * }</script>  且满足 <script type="math/tex">\mu=\left(L\left(g^{\lambda} \bmod n^{2}\right)\right)^{-1}</script>  存在， 其中函数<script type="math/tex">L(x)</script>  的定义如下 <script type="math/tex">L(x)=\frac{x-1}{n}</script> 。</p><p>此时，公钥为 <script type="math/tex">(n, g)</script> ，私钥为 <script type="math/tex">(\lambda, \mu)</script>。</p><p><strong>(2) 加密过程</strong></p><p>对于明文$m$ ，$ m \in \mathbb{Z}_{n}$  ，选择随机数 $r&lt;n$  ，加密过程为</p><script type="math/tex; mode=display">c=g^{m} r^{n}\left(\bmod n^{2}\right)</script><p><strong>(3) 解密过程</strong></p><p>对于密文  c  解密过程为</p><script type="math/tex; mode=display">m=L\left(c^{\lambda} \operatorname{ \bmod n}^{2}\right) * \mu \operatorname{\bmod n}=\frac{L\left(c^{\lambda} \operatorname{\bmod n}^{2}\right)}{L\left(g^{\lambda} \operatorname{\bmod n}^{2}\right)}</script><h3 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h3><blockquote><p><strong>补充前提：</strong></p><p>首先回顾一下二项式定理。  $n \in \mathbb{N}^{*}$ </p><script type="math/tex; mode=display">\small(a+b)^{n}=\sum_{r=0}^{n} C_{n}^{r} a^{n-r} b^{r}=C_{n}^{0} a^{n}+C_{n}^{1} a^{n-1} b+\cdots+C_{n}^{r} a^{n-r} b^{r}+\cdots+C_{n}^{n} b^{n}</script><p>当 $a=1, b=n, n=x $时可以化成下面的形式:</p><script type="math/tex; mode=display">(1+n)^{x}=1+n x+\frac{x(x-1) n^{2}}{2 !}+\ldots</script><p>可以化为:</p><script type="math/tex; mode=display">(1+n)^{x} \equiv 1+n x\left(\bmod n^{2}\right)</script><p>令 $ y=(1+n)^{x} \bmod n^{2} $, 可化简为$  x \equiv \frac{y-1}{n} \quad\left(\bmod n^{2}\right) $, 再令  $L(u)=\frac{u-1}{n} $<br>则</p><script type="math/tex; mode=display">\smallL\left((1+n)^{x} \bmod n^{2}\right) \equiv L(y) \equiv \frac{y-1}{n} \quad(\bmod n) \equiv x \quad(\bmod</script><p>即：$L\left((1+n)^{x} \bmod n^{2}\right) \equiv x \quad(\bmod n) $</p><p>由上式结论不难知道：$μ=λ^{-1},(g=n+1)$。</p><p>此外，还有 $ r^{λn}\bmod N^2=1$</p></blockquote><p><strong>证明过程如下：</strong></p><p>因为</p><script type="math/tex; mode=display">\lambda=l c m(p-1, q-1)</script><p>所以</p><script type="math/tex; mode=display">p-1|\lambda, \quad q-1| \lambda=>\lambda=a(p-1)=b(q-1)</script><p>由费马小定理可得</p><script type="math/tex; mode=display">g^{\lambda}=g^{a(p-1)} \equiv 1 \bmod p=>p \mid g^{\lambda}-1</script><p>同理</p><script type="math/tex; mode=display">g^{\lambda}=g^{b(q-1)} \equiv 1 \bmod p \Rightarrow q \mid g^{\lambda}-1</script><p>又因为$gcd(p,q) = 1$</p><p>所以</p><script type="math/tex; mode=display">p q\left|g^{\lambda}-1=>n\right| g^{\lambda}-1 \Rightarrow g^{\lambda} \equiv 1 \bmod n=>g^{\lambda}=k_{1} n+1</script><p>同理</p><script type="math/tex; mode=display">r^{\lambda}=k_{2} n+1\\c^{\lambda}=\left(g^{m} r^{n}\right)^{\lambda} \bmod \left(n^{2}\right) \\=g^{m \lambda} \bmod \left(n^{2}\right) \cdot r^{n \lambda} \bmod \left(n^{2}\right)\\=\left(k_{1} n+1\right)^{m} \bmod \left(n^{2}\right) \cdot\left(k_{2} n+1\right)^{n} \bmod \left(n^{2}\right)</script><p>有以下性质</p><script type="math/tex; mode=display">\begin{aligned}(k n+1) \bmod \left(n^{2}\right) &=k n+1 \\(k n+1)^{2} \bmod \left(n^{2}\right) &=2 k n+1 \\(k n+1)^{3} \bmod \left(n^{2}\right) &=3 k n+1 \\\cdots & \\(k n+1)^{m} \bmod \left(n^{2}\right) &=m k n+1\end{aligned}</script><p>所以</p><script type="math/tex; mode=display">c^{\lambda}=\left(m k_{1} n+1\right) \bmod \left(n^{2}\right) \cdot\left(k_{2} n^{2}+1\right) \bmod \left(n^{2}\right)\\=\left(m k_{1} n+1\right) \bmod \left(n^{2}\right)</script><p>所以</p><script type="math/tex; mode=display">\frac{L\left(c^{\lambda} \bmod \left(n^{2}\right)\right)}{L\left(g^{\lambda} \bmod \left(n^{2}\right)\right)}=\frac{\frac{m k_{1} n}{n}}{\frac{k_{1} n}{n}}=m</script><h3 id="同态分析"><a href="#同态分析" class="headerlink" title="同态分析"></a>同态分析</h3><p>同时，该算法还满足加法同态和乘法同态的两个性质。</p><p>下面分别就加法同态和乘法同态的证明过程做具体介绍。 </p><p>首先给定两个密文</p><script type="math/tex; mode=display"> E\left(M_{1}, p k\right)=g^{M_{1}} R_{1}^{n} \bmod n^{2}</script><p>  和</p><script type="math/tex; mode=display"> E\left(M_{2}, p k\right)=g^{M_{2}} R_{2}^{n} \bmod n^{2}  ，</script><p>其中<script type="math/tex">R_{1} \in Z_{n}^{*}, R_{2} \in Z_{n}^{*}</script></p><p><strong>(1) paillier 算法的加法同态证明过程如下:</strong></p><script type="math/tex; mode=display">\begin{array}{l}D\left(E\left(M_{1}, p k\right) \cdot E\left(M_{2}, p k\right) \bmod n^{2}\right) \\=D\left(\left(g^{M_{1}} R_{1}^{n}\right)\left(g^{M_{2}} R_{2}^{n}\right) \bmod n^{2}\right) \\=D\left(E\left(M_{1}+M_{2}, p k\right)\right) \\=M_{1}+M_{2}\end{array}</script><p><strong>(2) paillier 算法的乘法同态证明过程如下:</strong></p><script type="math/tex; mode=display">\begin{aligned}& D\left(E\left(M_{1}, p k\right)^{M_{2}} \bmod n^{2}\right) \\=& D\left(\left(g^{M_{1}} R_{1}^{n}\right)^{M_{2}} \bmod n^{2}\right) \\=& D\left(E\left(M_{1} M_{2}, p k\right)\right) \\=& M_{1} M_{2}\end{aligned}</script><h2 id="Paillier算法实现"><a href="#Paillier算法实现" class="headerlink" title="Paillier算法实现"></a>Paillier算法实现</h2><p>这里采用现成的库进行演示，源码里面封装好了加密解密过程，并创建了加密后的对象，重写了相关的运算；</p><p>感兴趣可以看以下：</p><p><a href="https://python-paillier.readthedocs.io/en/stable/phe.html">源码分析</a></p><p><a href="https://python-paillier.readthedocs.io/en/stable/phe.html">https://python-paillier.readthedocs.io/en/stable/phe.html</a></p><p><a href="https://python-paillier.readthedocs.io/en/develop/index.html">用法介绍</a></p><p><a href="https://python-paillier.readthedocs.io/en/develop/index.html">https://python-paillier.readthedocs.io/en/develop/index.html</a></p><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> phe <span class="token keyword">import</span> paillier <span class="token comment"># 开源库</span><span class="token keyword">import</span> time <span class="token comment"># 做性能测试</span><span class="token comment"># 测试paillier参数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"默认私钥大小："</span><span class="token punctuation">,</span>paillier<span class="token punctuation">.</span>DEFAULT_KEYSIZE<span class="token punctuation">)</span> <span class="token comment">#2048</span><span class="token comment"># 生成公私钥</span>public_key<span class="token punctuation">,</span>private_key <span class="token operator">=</span> paillier<span class="token punctuation">.</span>generate_paillier_keypair<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 测试需要加密的数据</span>message_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3.1415926</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4.6e-12</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"原始数据："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>message_list<span class="token punctuation">)</span><span class="token comment"># 加密操作</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始加密"</span><span class="token punctuation">)</span>time_start_enc <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>encrypted_message_list <span class="token operator">=</span> <span class="token punctuation">[</span>public_key<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token keyword">for</span> m <span class="token keyword">in</span> message_list<span class="token punctuation">]</span>time_end_enc <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密耗时ms："</span><span class="token punctuation">,</span>time_end_enc<span class="token operator">-</span>time_start_enc<span class="token punctuation">)</span>encrypted_message_list_ciphertext <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>encrypted_message_list_len <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> num <span class="token keyword">in</span> encrypted_message_list<span class="token punctuation">:</span>    encrypted_message_list_ciphertext<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">.</span>ciphertext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    encrypted_message_list_len<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">.</span>ciphertext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密后封装类:"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>encrypted_message_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密后数据："</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>encrypted_message_list_ciphertext<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密后数据长度"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>encrypted_message_list_len<span class="token punctuation">)</span><span class="token comment"># 解密操作</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始解密"</span><span class="token punctuation">)</span>time_start_dec <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>decrypted_message_list <span class="token operator">=</span> <span class="token punctuation">[</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> encrypted_message_list<span class="token punctuation">]</span>time_end_dec <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"解密耗时ms："</span><span class="token punctuation">,</span>time_end_dec<span class="token operator">-</span>time_start_dec<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"解密数据:"</span><span class="token punctuation">,</span>decrypted_message_list<span class="token punctuation">)</span><span class="token comment"># 测试加法和乘法同态</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"测试同态："</span><span class="token punctuation">)</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token operator">=</span> encrypted_message_list <span class="token comment"># a,b,c分别为对应密文</span>a_sum <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">5</span> <span class="token comment"># 密文加明文</span>a_sub <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token number">3</span> <span class="token comment"># 密文加明文的相反数</span>b_mul <span class="token operator">=</span> b <span class="token operator">*</span> <span class="token number">1</span> <span class="token comment"># 密文乘明文,数乘</span>c_div <span class="token operator">=</span> c <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">10.0</span> <span class="token comment"># 密文乘明文的倒数</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a:"</span><span class="token punctuation">,</span>a<span class="token punctuation">.</span>ciphertext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 密文a的纯文本形式</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a_sum："</span><span class="token punctuation">,</span>a_sum<span class="token punctuation">.</span>ciphertext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 密文a_sum的纯文本形式</span><span class="token comment"># print(a_sum.ciphertext(False))</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a+5="</span><span class="token punctuation">,</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>a_sum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a-3"</span><span class="token punctuation">,</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>a_sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"b*1="</span><span class="token punctuation">,</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>b_mul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"c/-10.0="</span><span class="token punctuation">,</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>c_div<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">##密文加密文</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"密文加密文"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"明文相加"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">+</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"密文相加再解密"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>private_key<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#报错，不支持a*b，因为通过密文加实现了明文加的目的，这和原理设计是不一致的，只支持密文加！</span><span class="token comment">#print((private_key.decrypt(a)+private_key.decrypt(b))==private_key.decrypt(a*b))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">默认私钥大小： <span class="token number">2048</span>原始数据：<span class="token punctuation">[</span><span class="token number">3.1415926</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.6e-12</span><span class="token punctuation">]</span>开始加密加密耗时ms： <span class="token number">0.04004788398742676</span>加密后封装类<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">phe<span class="token punctuation">.</span>paillier<span class="token punctuation">.</span></span>EncryptedNumber</span> object at 0x000002A5A5626520<span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">phe<span class="token punctuation">.</span>paillier<span class="token punctuation">.</span></span>EncryptedNumber</span> object at 0x000002A5A5648400<span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name"><span class="token namespace">phe<span class="token punctuation">.</span>paillier<span class="token punctuation">.</span></span>EncryptedNumber</span> object at 0x000002A5A7234C70<span class="token punctuation">&gt;</span></span><span class="token punctuation">]</span>加密后数据：<span class="token punctuation">[</span><span class="token number">524291991382170452217704475980691776837614405188522037968068175026564759427912320918307453096000382119350489461565751654667188742927175709616936014994449725543996253181424504133113093704476842502121509404600704704401020343657955051139488993394696510864569944395376107274831208305297772744375254428029352127714153970661925734298887549106462250028475185047600901566232815901730690679594599732103375886312485088441992712816214151517489650303414853949493050648291376095351556437141922062712607363860043601898555564600998987018381122670560202868977113629267250394289271307071768894375207856525112730764648552403804056635121599918143847892529515739827570196829130981763379171478096053156763491864533735562542904363358041636200671073380326111231382706038175694844342345290261787254748389348410687268685858444786488671767893206001963801449392389648930342085919849556045695572133259745582479963206406380994047951250058959853589560058962477910483298184902450736920563613951952547910853893303937322618704979371386401229968669808155025000319713893612636379277847559556088628875403182870219822406238306335177716502535762098493866878014836214249807055797477782352753227476858275742534314681553372057747251377368724755085915645471865275377623886459</span><span class="token punctuation">,</span> <span class="token number">269416424940886258693607260919488899845323764158616743749562006350639334858860427630659801338175678237124059137369627102051692452708091412719454022760515608223168361771711511747659126348989200942282546213019031501276065278364500888142766122517486053501206909354206670771945142628130707930654117834933893563876174302284605869037968954680433036310127553156824506084239452451725133622811971552446088378848338372034890331747119906390948627406273834264276845477660299119138603749781908689329085253292439523208528310438945333432983538267254740717013631946838120879332465184659686000301180662539102218024205358009140930273691260050183731830759440852865440742561544056141841979048430743911163852158845831858580757386884886402388858888211858821791968248589222950428572193200605881706047318018918551026896635566765386440926309183799721788073420579647226409581581112359939183851016788169669633614025777403325802025116007374430448105053688356467589927500134144872912575227027663354970924471933252614007929165708738565059332030526084180726286433089665082262477021640930039185640779877964368351443207035365443809983778188070146916089108323645588170174174728982137244143439173569978383981968082501105831184832488139182969566677450260491360575645497</span><span class="token punctuation">,</span> <span class="token number">672086925542542340573658739233885056856091941371617257703258915736298300514171772636717108421375759472775458681276207475314687398083503106638117450737504893446605614216462813245601521825257222263727854788570044544981360850404970798986701963648802587870534152356529103294070868611321598972813206914606402653822445499954546528904242307905640120763114515468142099265611607887434612059052136900124495714592832523096078291984447819361584916677431878078166876060621264099494393637800047438781631353465174659844223331831729620531227301878054036564312918320946913594427253369637429340625001431712787325849640427716021850287819329842030461887139273564044212158986457725931102311159223582956676354648689347560064482793345002710056633043449671992874058955133835052485898106259930732407094339688659178264393215356629538972278971996772194186706655152384274844763263037100159537155046907187267094350979373364485631280863316542813593637073721800360632785281837538907801122409752631040556982597895243396500510624242181556717122746237272452063078477963523780388052869203131444811420155833305683886280761177152245962801086818868886001963847219304047857088892198781366886214250037109057272433786423187397743994951389815335116762978030925823681501191227</span><span class="token punctuation">]</span>加密后数据长度<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">4095</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">]</span>开始解密解密耗时ms： <span class="token number">0.011508464813232422</span>解密数据<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">3.1415926</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.6e-12</span><span class="token punctuation">]</span>测试同态：a<span class="token punctuation">:</span> <span class="token number">524291991382170452217704475980691776837614405188522037968068175026564759427912320918307453096000382119350489461565751654667188742927175709616936014994449725543996253181424504133113093704476842502121509404600704704401020343657955051139488993394696510864569944395376107274831208305297772744375254428029352127714153970661925734298887549106462250028475185047600901566232815901730690679594599732103375886312485088441992712816214151517489650303414853949493050648291376095351556437141922062712607363860043601898555564600998987018381122670560202868977113629267250394289271307071768894375207856525112730764648552403804056635121599918143847892529515739827570196829130981763379171478096053156763491864533735562542904363358041636200671073380326111231382706038175694844342345290261787254748389348410687268685858444786488671767893206001963801449392389648930342085919849556045695572133259745582479963206406380994047951250058959853589560058962477910483298184902450736920563613951952547910853893303937322618704979371386401229968669808155025000319713893612636379277847559556088628875403182870219822406238306335177716502535762098493866878014836214249807055797477782352753227476858275742534314681553372057747251377368724755085915645471865275377623886459</span>a_sum： <span class="token number">686026057510668402198729529701398130487725892325120350107258858703000628394068430612657769324986603416644938335795820890307072662538266909997202117683220641308735213572050226337867774207817310841556158455807011552545974475386077162321520504724985369834186250304162793975927697000460540565103483088892238091762855439515505577886055744549810066342100910160301621261743077071035960506400137065394303693062344245187629710575801042400997114831938224754537404763598045450890532495004626519071924476370914642667645233099517147731478705357321337254748195824380948906621449475488611041801519373990853362602579063897475163781066858928422310347362831335991511030855049159740387484201203191787747864002004317761675058306130255425119984559419920327532428512052855668048944102692892310846264610279368032384556664873925439573974950559921319109021823269867563353600374953023362427101749847552150775441209919198440622421840061099060091101769517927134498353834366155997666506978793180259855560104635354714421261649146728922935957994992724614422522665735071363435479251523465815214714900577264972228123517783100734952986902759935486966144430287055751370182598754010346717994255584673126513810338682404314543438589329778114069891709941774479624148579380</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token operator">=</span> <span class="token number">8.1415926</span>a<span class="token operator">-</span><span class="token number">3</span> <span class="token number">0.14159260000000007</span>b<span class="token operator">*</span><span class="token number">1</span><span class="token operator">=</span> <span class="token number">100</span>c<span class="token operator">/</span><span class="token operator">-</span><span class="token number">10.0</span><span class="token operator">=</span> <span class="token number">4.6e-13</span>密文加密文明文相加<span class="token number">103.1415926</span>密文相加再解密<span class="token number">103.1415926</span><span class="token class-name">Process</span> finished <span class="token keyword">with</span> exit code <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同态加密扩展"><a href="#同态加密扩展" class="headerlink" title="同态加密扩展"></a>同态加密扩展</h2><p>同态加密是密码学领域自1978年以来的经典难题，也是实现数据隐私计算的关键技术，在云计算、区块链、隐私计算等领域均存在着广泛的应用需求和一些可行的应用方案。</p><p>这里介绍一下我感兴趣的联邦学习（夹带私货）</p><h3 id="联邦学习"><a href="#联邦学习" class="headerlink" title="联邦学习"></a>联邦学习</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>联邦学习（Federated Learning）是一种新兴的人工智能基础技术，在 2016 年由谷歌最先提出，原本用于解决安卓手机终端用户在本地更新模型的问题，其设计目标是在保障大数据交换时的信息安全、保护终端数据和个人数据隐私、保证合法合规的前提下，在多参与方或多计算结点之间开展高效率的机器学习。其中，联邦学习可使用的机器学习算法不局限于神经网络，还包括随机森林等重要算法。联邦学习有望成为下一代人工智能协同算法和协作网络的基础。</p><h4 id="联邦学习的系统构架"><a href="#联邦学习的系统构架" class="headerlink" title="联邦学习的系统构架"></a>联邦学习的系统构架</h4><p> 以包含两个数据拥有方（即企业 A 和 B）的场景为例介绍联邦学习的系统构架。该构架可扩展至包含多个数据拥有方的场景。假设企业 A 和 B 想联合训练一个机器学习模型，它们的业务系统分别拥有各自用户的相关数据。此外，企业 B 还拥有模型需要预测的标签数据。出于数据隐私保护和安全考虑，A 和 B 无法直接进行数据交换，可使用联邦学习系统建立模型。联邦学习系统构架由三部分构成，如图所示。</p><p>第一部分：加密样本对齐。由于两家企业的用户群体并非完全重合，系统利用基于加密的用户样本对齐技术，在 A 和 B 不公开各自数据的前提下确认双方的共有用户，并且不暴露不互相重叠的用户，以便联合这些用户的特征进行建模。</p><p>第二部分：加密模型训练。在确定共有用户群体后，就可以利用这些数据训练机器学习模型。为了保证训练过程中数据的保密性，需要借助第三方协作者 C 进行加密训练。以线性回归模型为例，训练过程可分为以下 4 步（如图  所示）： </p><p>第①步：协作者 C 把公钥分发给 A 和 B，用以对训练过程中需要交换的数据进行加密。</p><p>第②步：A 和 B 之间以加密形式交互用于计算梯度的中间结果。</p><p>第③步：A 和 B 分别基于加密的梯度值进行计算，同时 B 根据其标签数据计算损失，并把结果汇总给 C。C 通过汇总结果计算总梯度值并将其解密。</p><p>第④步：C 将解密后的梯度分别回传给 A 和 B，A 和 B 根据梯度更新各自模型的参数。</p><p>迭代上述步骤直至损失函数收敛，这样就完成了整个训练过程。在样本对齐及模型训练过程中，A 和 B 各自的数据均保留在本地，且训练中的数据交互也不会导致数据隐私泄露。因此，双方在联邦学习的帮助下得以实现合作训练模型。</p><p>第三部分：效果激励。联邦学习的一大特点就是它解决了为什么不同机构要加入联邦共同建模的问题，即建立模型以后模型的效果会在实际应用中表现出来，并记录在永久数据记录机制（如区块链）上。提供数据多的机构所获得的模型效果会更好，模型效果取决于数据提供方对自己和他人的贡献。这些模型的效果在联邦机制上会分发给各个机构反馈，并继续激励更多机构加入这一数据联邦。以上三部分的实施，既考虑了在多个机构间共同建模的隐私保护和效果，又考虑了以一个共识机制奖励贡献数据多的机构。所以，联邦学习是一个「闭环」的学习机制。</p><h4 id="联邦学习优势"><a href="#联邦学习优势" class="headerlink" title="联邦学习优势"></a>联邦学习优势</h4><ol><li>数据隔离，数据不会泄露到外部，满足用户隐私保护和数据安全的需求；</li><li>能够保证模型质量无损，不会出现负迁移，保证联邦模型比割裂的独立模型效果好；</li><li>参与者地位对等，能够实现公平合作；</li><li>能够保证参与各方在保持独立性的情况下，进行信息与模型参数的加密交换，并同时获得成长。</li></ol><p>参考网站</p><p><a href="https://cn.fedai.org/">FedAI 中文站</a></p><p><a href="https://cn.fedai.org/">https://cn.fedai.org/</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="论文："><a href="#论文：" class="headerlink" title="论文："></a>论文：</h3><p>[1]廖祥宇. 基于paillier算法的谓词加密密文索引方案[D].湖北民族大学,2021.DOI:10.27764/d.cnki.ghbmz.2021.000096.</p><p>[2]张乐峰. 基于同态加密的空间众包隐私保护研究[D].中南财经政法大学,2019.</p><p>[3]崔建京,龙军,闵尔学,于洋,殷建平.同态加密在加密机器学习中的应用研究综述[J].计算机科学,2018,45(04):46-52.</p><h3 id="博客："><a href="#博客：" class="headerlink" title="博客："></a>博客：</h3><p><a href="https://blog.csdn.net/qq_34793644/article/details/118760670?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.1">https://blog.csdn.net/qq_34793644/article/details/118760670?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.1</a></p><p><a href="https://blog.csdn.net/qq_40589204/article/details/116310125?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link">https://blog.csdn.net/qq_40589204/article/details/116310125?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p><p><a href="https://blog.csdn.net/qq_33885461/article/details/86555560?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link">https://blog.csdn.net/qq_33885461/article/details/86555560?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link</a></p><h3 id="知乎："><a href="#知乎：" class="headerlink" title="知乎："></a>知乎：</h3><p><a href="https://www.zhihu.com/question/27645858">https://www.zhihu.com/question/27645858</a></p><p><a href="https://zhuanlan.zhihu.com/p/77478956">https://zhuanlan.zhihu.com/p/77478956</a></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><a href="https://github.com/FederatedAI/DOC-CHN/blob/master/%E6%9C%89%E5%A5%96%E5%BE%81%E9%9B%86%E6%B4%BB%E5%8A%A8/%E6%95%99%E7%A8%8B%E7%B1%BB/Paillier%20Cryptosystem%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5.pdf">https://github.com/FederatedAI/DOC-CHN/blob/master/%E6%9C%89%E5%A5%96%E5%BE%81%E9%9B%86%E6%B4%BB%E5%8A%A8/%E6%95%99%E7%A8%8B%E7%B1%BB/Paillier%20Cryptosystem%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5.pdf</a></p><p><a href="https://github.com/wdxtub/federated-learning-note">https://github.com/wdxtub/federated-learning-note</a></p><p><a href="https://python-paillier.readthedocs.io/en/stable/phe.html">https://python-paillier.readthedocs.io/en/stable/phe.html</a></p><p><a href="https://python-paillier.readthedocs.io/en/develop/index.html">https://python-paillier.readthedocs.io/en/develop/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 同态加密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 密码学 </tag>
            
            <tag> 同态加密 </tag>
            
            <tag> 联邦学习 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法理论复习</title>
      <link href="/2021/11/18/suan-fa-li-lun-fu-xi/"/>
      <url>/2021/11/18/suan-fa-li-lun-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="算法理论复习"><a href="#算法理论复习" class="headerlink" title="算法理论复习"></a>算法理论复习</h1><blockquote><p>本文参考：胡神笔记：<a href="https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/">https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</a></p></blockquote><h2 id="1-算法概叙"><a href="#1-算法概叙" class="headerlink" title="1.算法概叙"></a>1.算法概叙</h2><blockquote><p>算法复杂性和算法复杂性的计算O记，以及倍率计算</p></blockquote><h3 id="1-1-算法概念"><a href="#1-1-算法概念" class="headerlink" title="1.1 算法概念"></a>1.1 算法概念</h3><h4 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h4><p>一系列将问题的输入转换为输出的计算或操作步骤。</p><h4 id="1-1-2-性质"><a href="#1-1-2-性质" class="headerlink" title="1.1.2 性质"></a>1.1.2 性质</h4><ul><li>输入          有外部提供的量作为算法的输入。</li><li>输出          算法产生至少一个量作为输出。</li><li>确定性        组成算法的每条指令是清晰、无歧义的。</li><li>有限性        算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。</li></ul><h3 id="1-2-算法复杂性"><a href="#1-2-算法复杂性" class="headerlink" title="1.2 算法复杂性"></a>1.2 算法复杂性</h3><p><strong>算法的复杂性(C):</strong></p><p>算法执行所需的时间和空间的数量。</p><script type="math/tex; mode=display">T=T(N, I)=\sum_{i=1}^{k} t_{i} e_{i}(N, I)</script><p><strong>平均情况</strong></p><script type="math/tex; mode=display">T_{\text {avg }}(N)=\sum_{I \in D_{N}} P(I) T(N, I)=\sum_{I \in D_{N}} P(I) \sum_{i=1}^{k} t_{i} e_{i}(N, I)</script><p><strong>渐进性态</strong></p><script type="math/tex; mode=display">\frac{T(N)-\overset{\thicksim}{T}(N)}{T(N)} \rightarrow 0</script><p><strong>大O表示法(算法运行时间的上限 )</strong></p><p>就是逼近的一个上界，可以那泰勒的上界来理解。</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050100.png" alt="image-20211115191500303"></p><p><strong>大W表示法(算法运行时间的下限）</strong></p><p>下界</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050194.png" alt="image-20211115191635671"></p><p>算法复杂度排序：</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050247.png" alt="时间复杂度，不同数据规模的差异"></p><h3 id="1-3-NP问题判断"><a href="#1-3-NP问题判断" class="headerlink" title="1.3 NP问题判断"></a>1.3 NP问题判断</h3><p>这部分不考，但既然学算法，应该了解一下这些NP难题</p><p>NP(Nondeterministic Polynomially，非确定性多项式)类问题是指一个复杂问题不能确定是否在多项式时间内找到答案，但是可以在多项式时间内验证答案是否正确。</p><p>P问题是一个判定问题类，这些问题可以用一个确定性算法在多项式时间内判定或解出。</p><p>NP问题是指可以在多项式时间内被非确定机解决的问题。通常它们的时间复杂度都是指数变量。</p><h2 id="2-递归与分治"><a href="#2-递归与分治" class="headerlink" title="2.递归与分治"></a>2.递归与分治</h2><h3 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h3><p><strong>递归定义</strong> 用函数自身定义的函数</p><p><strong>递归函数两个要素</strong> 边界条件与递归方程</p><p><strong>递归算法转化为非递归算法</strong></p><ol><li>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</li><li>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</li></ol><h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>对于数据n，最大加数不大于m的划分个数记作$q(n,m)$</p><script type="math/tex; mode=display">q(n,m) = \left\{\begin{matrix}1  & n = 1,m = 1\\ q(n,n) &n<m \\ 1+q(n,n-1) &n = m \\ q(n,m-1)+q(n-m,m) &n>m>1\end{matrix}\right.</script><h3 id="2-2-分治"><a href="#2-2-分治" class="headerlink" title="2.2 分治"></a>2.2 分治</h3><p>  <strong>分治法的设计思想是</strong>：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>  <strong>分治策略是</strong>：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p><strong>分治法所能解决的问题一般具有以下几个特征：</strong></p><p>1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p><p>算法模板</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Divide<span class="token operator">-</span>and<span class="token operator">-</span><span class="token function">Conquer</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token operator">|</span>P<span class="token operator">|</span>≤n0then <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">ADHOC</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span>将P分解为较小的子问题 P1 <span class="token punctuation">,</span>P2 <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>Pk<span class="token keyword">for</span> i←<span class="token number">1</span> to k<span class="token keyword">do</span> yi ← Divide<span class="token operator">-</span>and<span class="token operator">-</span><span class="token function">Conquer</span><span class="token punctuation">(</span>Pi<span class="token punctuation">)</span> <span class="token comment">//递归解决Pi</span>T ← <span class="token function">MERGE</span><span class="token punctuation">(</span>y1<span class="token punctuation">,</span>y2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>yk<span class="token punctuation">)</span> <span class="token comment">//合并子问题</span><span class="token keyword">return</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-二分搜索"><a href="#2-3-二分搜索" class="headerlink" title="2.3 二分搜索"></a>2.3 二分搜索</h3><p><strong>问题描述</strong> 给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p><p>参考：<a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF</a></p><p>俩种思路。</p><h3 id="2-4-合并排序和快速排序"><a href="#2-4-合并排序和快速排序" class="headerlink" title="2.4 合并排序和快速排序"></a>2.4 合并排序和快速排序</h3><p><strong>问题描述</strong> 数组排序</p><h4 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度</p><script type="math/tex; mode=display">\begin{array}  {X}  T(n) = O(nlogn) =\left\{\begin{matrix}O(1)  & n=1\\2T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.\end{array}</script><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span> <span class="token comment">//p、r为数组下标</span>x <span class="token operator">=</span> A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>   <span class="token comment">//将最后一个元素作为主元素</span>i <span class="token operator">=</span> p<span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// i指向的是比主元素小的位置，</span><span class="token keyword">for</span>  j <span class="token operator">=</span> p  to  r<span class="token operator">-</span><span class="token number">1</span>     <span class="token comment">//从第一个元素开始到倒数第二个元素结束，比较确定主元素的位置</span><span class="token keyword">do</span>  <span class="token keyword">if</span>  A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> xthen  i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>       <span class="token comment">//如果比主元素小，则把i=i+1的位置上的元素和j位置发现小元素互换</span>exchange A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">-&gt;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>exchange A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token operator">-&gt;</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>   <span class="token comment">//最终确定主元的位置</span><span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span>   <span class="token comment">//返回主元的位置</span>End<span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token keyword">if</span> p<span class="token operator">&lt;</span>rq <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token comment">//确定划分位置</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token comment">//子数组A[p...q-1]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>     <span class="token comment">//子数组A[q+1...r]</span>End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤</strong></p><ol><li><p>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</p></li><li><p>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</p></li><li><p>合并</p></li></ol><p>最坏情况，已经排好，$O(n^2)$<br>        最好情况，每次划分大小都是$\frac{n}{2}$，$O(nlogn)$</p><h3 id="2-5-大整数乘法"><a href="#2-5-大整数乘法" class="headerlink" title="2.5 大整数乘法"></a>2.5 大整数乘法</h3><p><strong>问题描述</strong> XY是n位二进制整数，计算他们的乘积XY</p><script type="math/tex; mode=display">\begin{array}  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \\   XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \\  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \\\end{array}</script><p>复杂度</p><script type="math/tex; mode=display">T(n) = O(n^{log3}) =\left\{\begin{matrix}O(1)  & n=1\\3T(\frac{n}{2} ) + O(n) & n>1 \\\end{matrix}\right.</script><h3 id="2-6-线性时间选择"><a href="#2-6-线性时间选择" class="headerlink" title="2.6 线性时间选择"></a>2.6 线性时间选择</h3><p>无序排列中求n个元素中第k小的元素（主要求中位数）。(类似快排)</p><p><strong>解释</strong></p><p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p><p>最坏情况，分成两个1和n-1的子问题，$O(n^2)$</p><p>最好情况，每次都产生$\frac{n}{2}$大小的子问题，$O(n)$</p><p>例题看书比较好。</p><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h2><h3 id="3-1-动态规划原理"><a href="#3-1-动态规划原理" class="headerlink" title="3.1 动态规划原理"></a>3.1 动态规划原理</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>这里俩性质：<strong>最优子结构性质</strong>和<strong>子问题重叠性质</strong></p><ol><li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li><li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li></ol><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">编程方法：动态规划的解题步骤对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！1、确定dp数组（dp table）以及下标的含义2、确定递推公式3、dp数组如何初始化4、确定遍历顺序5、举例推导dp数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态规划算法设计步骤</strong></p><ul><li><strong>分析最优解的性质，并刻划其结构特征；</strong> </li><li><strong>递归地定义最优值</strong></li><li><strong>以自底向上的方式计算出最优值；</strong></li><li><strong>根据计算最优值时得到的信息，构造最优解。</strong></li></ul><h3 id="3-2-矩阵连乘"><a href="#3-2-矩阵连乘" class="headerlink" title="3.2 矩阵连乘"></a>3.2 矩阵连乘</h3><p><strong>问题描述</strong> 每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。</p><script type="math/tex; mode=display">m[i][j]=\left\{\begin{array}{cc}0 & i=j \\\min_{i\leq{k}<j} \{m[i][k]+m[k+1][j]+p_{i-1}p_kp_j\} & i<j\end{array}\right.</script><p><strong>解释</strong> 矩阵连乘积从$A_i$到$A_j$定义为<code>A[i:j]</code>，<code>A[i:j]</code>最少的乘法次数定义为<code>m[i,j]</code>，最优断开位置k记为<code>𝑠[i,j]=k</code>，</p><p>$T(n)=O(n^3)$</p><blockquote><p><strong>例题</strong></p><p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p></blockquote><h3 id="3-3-最长公共子序列"><a href="#3-3-最长公共子序列" class="headerlink" title="3.3 最长公共子序列"></a>3.3 最长公共子序列</h3><p><strong>问题描述：</strong>给定两个序列$X=\{x_1,x_2,\cdots,x_m\}$和$Y=\{y_1,y_2,\cdots,y_n\}$，要求找出$X$和$Y$的一个最长公共子序列。</p><script type="math/tex; mode=display">c[i][j]=\left\{\begin{array}{cc}0 & i=0, j=0 \\c[i-1][j-1]+1 & i, j>0 ; x_{i}=y_{j} \\\max \{c[i-1][j], c[i][j-1]\} & i, j>0 ; x_{i} \neq y_{j}\end{array}\right.</script><script type="math/tex; mode=display">b[i][j]=\left\{\begin{array}{cc} 1 & c[i][j] = c[i-1][j-1] \\2 & c[i][j] = c[i-1][j] \\3 & c[i][j] = c[i][j-1]\end{array}\right.</script><p><strong>解释</strong> <code>c[i,j]</code>记录序列$X_i$和$Y_j$的最长公共子序列长度，<code>b[i,j]</code>可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到<code>c[0，0]</code>为止。</p><p><strong>补充</strong> 两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列.</p><blockquote><p><strong>例题</strong></p><p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p></blockquote><h3 id="3-4-图像压缩"><a href="#3-4-图像压缩" class="headerlink" title="3.4 图像压缩"></a>3.4 图像压缩</h3><p><strong>问题描述</strong> 数字化图像是n×n的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p><ol><li>线性化：图片拉直，转换为$1×n^2$向量</li><li>分段：分成连续的m段，每段像素存储位数相同，每段最多含256个像素点</li><li>存放信息：第$i$段长度（8bit），第$i$段中像素存储位数（3bit）</li></ol><script type="math/tex; mode=display">\begin{matrix}s[i]=\min\limits_{1 \leq k \leq \min \{i,256\}}\{s[i-k]+k*bmax(i-k+1,i)  \}+11\\bmax(i,j)=\max\limits_{i\leq k \leq j}\{a[k]\}\end{matrix}</script><p><strong>解释</strong></p><p>假设<code>s[i]</code>是序列$\{p_1,p_2,…,p_i\}$的最优解，<code>a[i]</code>是第$i$个像素点的位数。</p><ol><li>假设$p_i$自成一段，则<code>s[i]=s[i-1]+保存pi的代价</code></li><li>取<code>s[i]</code>为min时对应的元素个数为k，<code>s[i]=s[i-k]+保存最后k个像素的代价</code></li><li>保存最后k个像素的代价=<code>k*max{k个灰度值二进制位数}+11</code></li></ol><blockquote><p><strong>例题</strong></p><p>求像素序列4，6，5，7，129，138，1的最优分段。</p></blockquote><h3 id="3-5-电路布线"><a href="#3-5-电路布线" class="headerlink" title="3.5 电路布线"></a>3.5 电路布线</h3><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交</p><script type="math/tex; mode=display">\begin{matrix}\scriptsize 当i=1时, \qquad Size(i,j) = \left\{\begin{matrix}0 && j<\pi(1)\\1 && j \geq \pi (1)\end{matrix}\right. \\\scriptsize当i>1时,\qquadSize(i,j) = \left\{\begin{matrix}Size(i-1,j) && j<\pi(i)\\\max \{ Size(i-1,j),Size(i-1,\pi(i)-1)+1\} && j \geq \pi (i)\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong> <code>MNS(i,j)</code>表示上面序号小于$i$，连接到下面的序号都小于$j$的不相交的集合，最后要求<code>MNS(n,n)</code>。如果$j=\pi(i)$，如果$(i,\pi(i))$不在MNS中，将i点删除没有影响，就是<code>size(i,j)=size(i-1,j)</code>，如果$(i,\pi(i))$在MNS中，就是<code>size(i,j)=size(i-1,pi(i)-1)+1</code></p><blockquote><p><strong>例题</strong></p><p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p></blockquote><h3 id="3-6-流水线调度"><a href="#3-6-流水线调度" class="headerlink" title="3.6 流水线调度"></a>3.6 流水线调度</h3><p><strong>问题描述</strong> n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业$i$所需的时间分别为$a_i$ 和$b_i$。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>分为$N_1,N_2$集合存放 <script type="math/tex">N_1 = \{a_i\leq b_i\} ,N_2 = \{a_i > b_i\}</script></li><li>$N_1$中作业按照$a_i$升序排序，$N_2$中作业按照$b_i$降序排序</li><li>$N_1$连接$N_2$，计算时间</li></ol><blockquote><p><strong>例题</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">任务</th><th style="text-align:center">J1</th><th style="text-align:center">J2</th><th style="text-align:center">J3</th><th style="text-align:center">J4</th><th style="text-align:center">J5</th><th style="text-align:center">J6</th></tr></thead><tbody><tr><td style="text-align:center">工序1</td><td style="text-align:center">30</td><td style="text-align:center">120</td><td style="text-align:center">50</td><td style="text-align:center">20</td><td style="text-align:center">90</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">工序2</td><td style="text-align:center">80</td><td style="text-align:center">100</td><td style="text-align:center">90</td><td style="text-align:center">60</td><td style="text-align:center">30</td><td style="text-align:center">10</td></tr></tbody></table></div></blockquote><h3 id="3-7-0-1背包与完全背包"><a href="#3-7-0-1背包与完全背包" class="headerlink" title="3.7 0-1背包与完全背包"></a>3.7 0-1背包与完全背包</h3><script type="math/tex; mode=display">\begin{matrix}m(i,j) = \left\{\begin{matrix}m(i-1,j) && 0 \leq j<w_i\\ \max \{ m(i-1,j),m(i-1,j-w_i)+v_i\} && j \geq w_i\end{matrix}\right.\\\\m(0,j) = \left\{\begin{matrix}0 && 0 \leq j<w_0\\ v_0 && j \geq w_0\end{matrix}\right.\end{matrix}</script><p><strong>解释</strong> <code>m[i][j]</code>表示可选择物品$i, i+1, …, n$时，背包容量为$j$装入的最大价值</p><blockquote><p><strong>例题</strong></p><p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p></blockquote><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4.贪心算法"></a>4.贪心算法</h2><blockquote><p>听老师说是活题，那么建议参考：<a href="https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>刷点力扣涨涨见识</p></blockquote><h3 id="4-1贪心原理"><a href="#4-1贪心原理" class="headerlink" title="4.1贪心原理"></a>4.1贪心原理</h3><p><strong>思想</strong> 在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p><p><strong>基本要素</strong></p><ol><li><strong>最优子结构性质</strong> 问题的最优解包含其子问题的最优解</li><li><strong>贪心选择性质</strong> 问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li></ol><p><strong>贪心算法一般分为如下四步：</strong></p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h3 id="4-2-活动安排"><a href="#4-2-活动安排" class="headerlink" title="4.2 活动安排"></a>4.2 活动安排</h3><p>思考如下具有11个活动安排的问题？</p><p>在活动集合中选择最大的相容活动子集合</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>任务</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>start</td><td>0</td><td>4</td><td>4</td><td>5</td><td>3</td><td>1</td><td>8</td><td>6</td><td>8</td><td>12</td><td>2</td></tr><tr><td>end</td><td>3</td><td>6</td><td>5</td><td>6</td><td>8</td><td>4</td><td>11</td><td>10</td><td>12</td><td>14</td><td>13</td></tr></tbody></table></div><pre class="line-numbers language-react" data-language="react"><code class="language-react">start开始时间，end结束时间，按任务按结束时间非减续排列优先选取结束时间早的，判断是否相容直到任务最后一个结束。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-哈夫曼编码"><a href="#4-3-哈夫曼编码" class="headerlink" title="4.3 哈夫曼编码"></a>4.3 哈夫曼编码</h3><p><strong>前缀码</strong> 对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p><p><strong>问题描述</strong> 找到使平均码长达到最小的前缀码编码方案</p><p><strong>策略</strong> 频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。$ T(n)=O(nlogn)$</p><p><strong>证明贪心选择性质</strong></p><p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p><p><strong>证明最优子结构性质</strong></p><p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率$f(z)=f(x)+f(y)$的字符，则证明树$T’=T-\{x,y\}$表示字符集$C’=C-\{x,y\} \bigcup \{z\}$的一个最优前缀码即可。</p><blockquote><p>问题：</p><p>设在1000个字母的文章中各字母出现的频率为a:83, b:14, c:28, d:38, e:131, f:29, g:20, h:53，求最优编码。</p></blockquote><h3 id="4-3-最短路径"><a href="#4-3-最短路径" class="headerlink" title="4.3 最短路径"></a>4.3 最短路径</h3><p>书上的吧，懒的写了，这个看这个就行了</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050411.png" alt="image-20211118194505196"></p><h3 id="4-4-最小生成树"><a href="#4-4-最小生成树" class="headerlink" title="4.4 最小生成树"></a>4.4 最小生成树</h3><p>参考数据结构，这个太简单了</p><h3 id="4-5-0-1背包（可分割）"><a href="#4-5-0-1背包（可分割）" class="headerlink" title="4.5 0-1背包（可分割）"></a>4.5 0-1背包（可分割）</h3><p><strong>贪心策略</strong></p><ol><li>计算每种物品的单价（性价比）$\frac{v_i}{w_i}$</li><li>按物品单价从大到小排序</li><li>优先选取物品单价高的，直到背包装满。</li></ol><blockquote><p>$n=3,c=20,W=\{18,15,10\},V=\{25,24,15\}$</p></blockquote><p><strong>补充几种贪心策略</strong>（但是都不能保证得到最优解）</p><ol><li>选择可以装入背包的价值最大的物品</li><li>选择可装入背包的重量最小的物品</li><li>选择可装入背包的$\frac{v_i}{w_i}$最大的物品（一般用来做回溯法或者分支限界的限界函数）</li></ol><h3 id="3-6最优装载"><a href="#3-6最优装载" class="headerlink" title="3.6最优装载"></a>3.6最优装载</h3><p><strong>策略</strong> 重量最轻的先装$ T(n)=O(nlogn)$</p><p>策略：</p><ol><li>见货物重量按从小到大排序</li><li>优先选取重量下的物品，直到无法装下为主</li></ol><h2 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5.回溯法"></a>5.回溯法</h2><h3 id="5-1-回溯原理"><a href="#5-1-回溯原理" class="headerlink" title="5.1 回溯原理"></a>5.1 回溯原理</h3><p>这里很矛盾，书上的回溯有一点点离谱，感觉是极端的剪枝，考试还得按课本来。</p><p><strong>算法框架</strong></p><ol><li><p>子集树算法框架<br>当所给的问题是从 个元素的集合 中找出 满足性质的子集时，相应的解空间树称为子集树</p></li><li><p>排列树算法框架<br>当所给问题是确定 个元素满足某种性质的排列时，相应的解空间树称为排列树</p></li></ol><p><strong>剪枝函数</strong></p><ol><li><p>用约束函数在扩展结点处剪去不满足约束的子树；</p></li><li><p>用限界函数剪去得不到最优解的子树</p></li></ol><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><h4 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h4><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">{</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-装载问题"><a href="#5-2-装载问题" class="headerlink" title="5.2 装载问题"></a>5.2 装载问题</h3><p><strong>问题描述</strong> n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 $i$的重量为$w_i$。要求找到装载方案将这n个货箱装上这2艘轮船</p><p><strong>解释</strong> 若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p><blockquote><p><strong>例题</strong></p><p>n=4,c1=12,W={8,6,2,3}</p></blockquote><h3 id="5-3-0-1背包"><a href="#5-3-0-1背包" class="headerlink" title="5.3 0-1背包"></a>5.3 0-1背包</h3><p><strong>解释</strong> 子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。$cw$是背包当前重量，$M-cw$是背包剩余的空间，$cp$是当前总收益，$rp$是贪心算法剩余的物品收益，$bestw$记录当前最优价值，也就是判断$bp=cp+cp&gt;bestw$是右节点的限界函数。（此外，回溯法解0/1背包的前置条件是物品已按$\frac{p_i}{w_i}$非增次序排序）</p><blockquote><p><strong>例题</strong></p><p>M=110，w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p></blockquote><h2 id="6-分枝限定"><a href="#6-分枝限定" class="headerlink" title="6.分枝限定"></a>6.分枝限定</h2><p>和回溯无限接近，搞清楚优先队列的优先级就可以</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUMT算法实验</title>
      <link href="/2021/11/17/suan-fa-shi-yan/"/>
      <url>/2021/11/17/suan-fa-shi-yan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者： lowly</p><p>仅供学习交流</p></blockquote><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h1 id="问题-A-排列问题"><a href="#问题-A-排列问题" class="headerlink" title="问题 A: 排列问题"></a>问题 A: 排列问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>回溯法，这里采用回溯进行遍历枚举。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;string path;vector&lt;string&gt; result;vector&lt;int&gt; used;void backtrack(string str){if(path.size() == str.size()){result.push_back(path);return;}for(int i=0;i&lt;str.size();i++){if(used[i]){continue;}used[i] = 1;path.push_back(str[i]);backtrack(str);path.pop_back();used[i] = 0;}}int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());used.resize(str.size(),0);backtrack(str);for(auto s : result){cout &lt;&lt; s &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-B-快速幂"><a href="#问题-B-快速幂" class="headerlink" title="问题 B: 快速幂"></a>问题 B: 快速幂</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s2.loli.net/2021/12/09/1JwR9CvtIPZaGhK.jpg" alt="20180914130647_85638-16364329703111"></p><h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">332893414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里是快速幂的技巧，采用化二进制判断迭代。</p><p>这里代码思路没问题，但得用long long类型</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 100000007;long long mypow(long long n,long long m){long long ans = 1;while(m){if(m &amp; 1){ans = ans * n % mod;}m = m &gt;&gt; 1;n = (n * n) % mod;}return ans;}int main(){int n;while(cin &gt;&gt; n){long long ans = 0;for(int i=1;i&lt;=n;i++){ans = (ans + mypow(i,i)) % mod;}cout &lt;&lt; ans+1 &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());do{cout &lt;&lt; str &lt;&lt; " ";}while(next_permutation(str.begin(),str.end()));return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-C-求第k小"><a href="#问题-C-求第k小" class="headerlink" title="问题 C: 求第k小"></a>问题 C: 求第k小</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p><h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 21 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><a href="https://blog.51cto.com/svenman/1851716">https://blog.51cto.com/svenman/1851716</a></p><p>qsort排序 <a href="https://blog.csdn.net/weixin_41096569/article/details/104771864">https://blog.csdn.net/weixin_41096569/article/details/104771864</a></p><p>不知道为什么c++算法的sort会超时，用c的就可以 过</p><p>这里有一点qsort使用配合数组，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-使用qsort"><a href="#方法一-使用qsort" class="headerlink" title="方法一 使用qsort"></a>方法一 使用qsort</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int compare (const void * a, const void * b){  return ( *(int*)a - *(int*)b );}int nums[1000011];int main(){int n,k;cin &gt;&gt; n &gt;&gt; k;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}//sort(nums.begin(),nums.end());qsort(nums,n,sizeof(int),compare);cout &lt;&lt; nums[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二-手写sort"><a href="#方法二-手写sort" class="headerlink" title="方法二 手写sort"></a>方法二 手写sort</h3><p>这里输入cin会超时（离谱）就这一点点差距。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std; int a[1000001];   int partition(int a[],int p,int r){    int x=a[r];    int middle=p;    int j;    for(j=p;j&lt;r;j++)    {        if(a[j]&lt;x)        {            if(j!=middle)              swap(a[middle],a[j]);            middle++;        }     }    swap(a[middle],a[j]);    return middle;}   void select(int a[],int p,int r){    if(p&lt;r)    {        int q=partition(a,p,r);        select(a,p,q-1);        select(a,q+1,r);        }}   int main(){    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)        scanf("%d",&amp;a[i]);    select(a,0,n-1);    cout&lt;&lt;a[k-1]&lt;&lt;endl;    return 0;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三-发现数组sort能过"><a href="#方法三-发现数组sort能过" class="headerlink" title="方法三 发现数组sort能过"></a>方法三 发现数组sort能过</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main(){int n,k;cin&gt;&gt;n&gt;&gt;k;for(int i=0;i&lt;n;i++){cin &gt;&gt; a[i];}sort(a,a+n);cout &lt;&lt; a[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-D-内部收益率"><a href="#问题-D-内部收益率" class="headerlink" title="问题 D: 内部收益率"></a>问题 D: 内部收益率</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s2.loli.net/2021/12/09/1y6omwJNc32jPTg.jpg" alt="20180914131556_63531"></p><h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p><img src="https://s2.loli.net/2021/12/09/npyQKqVgtLfka7N.jpg" alt="20180914131642_82198"></p><h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p><h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">1-1 22-8 6 90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">1.000.50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>二分搜索，模拟逼近</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;while((cin &gt;&gt; n) &amp;&amp; n){vector&lt;int&gt; cf(n+1,0);for(int i=0;i&lt;= n;i++){cin &gt;&gt; cf[i];}double min, max, ans, mid;min = -1.0;        max = 1000000;        while(max - min &gt; 1e-6){ans = cf[0];            mid = (max-min) / 2 + min;            for(int i=1;i&lt;=n;i++){ans += cf[i] / pow(1 + mid, i);}            if(ans &gt; 0)            min = mid;            else            max = mid;}printf("%.2lf\n",mid);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-E-跳台阶"><a href="#问题-E-跳台阶" class="headerlink" title="问题 E: 跳台阶"></a>问题 E: 跳台阶</h1><blockquote><p>时间限制: 1 Sec </p><p>内存限制: 128 MB </p></blockquote><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p><h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p><p>所得到的结果模1000000007</p><h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>可以看成初等的动态规划</p><p>dp数组存储</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-直接dp存储"><a href="#方法一-直接dp存储" class="headerlink" title="方法一 直接dp存储"></a>方法一 直接dp存储</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}vector&lt;long long&gt; dp(n+1,0);dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[i] = (dp[i-1] + dp[i-2]) % mod;}cout &lt;&lt; dp[n] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二-改进只需要维护3个dp就行了"><a href="#方法二-改进只需要维护3个dp就行了" class="headerlink" title="方法二 改进只需要维护3个dp就行了"></a>方法二 改进只需要维护3个dp就行了</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}int dp[3];dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[2] = (dp[0] + dp[1]) % mod;dp[0] = dp[1];dp[1] = dp[2];}cout &lt;&lt; dp[2] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h1 id="问题-A-沙子的质量"><a href="#问题-A-沙子的质量" class="headerlink" title="问题 A: 沙子的质量"></a>问题 A: 沙子的质量</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p><h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p><h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p><h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">41 3 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里和矩阵连乘差不多</p><p>这里cost（）也就是合并有<code>sum[j]-sum[i]</code>给出</p><p>这里外层遍历是长度，合并的长度</p><p>然后计算出i，j也就是合并区间</p><p>k是中间循环查找min</p><p>这里记得一个是sum初始化，一个是dp <code>i==j</code>时<code>dp=0</code>初始化<code>dp[i][j] = INT_MAX</code></p><p>参考</p><p><img src="https://s2.loli.net/2021/12/09/xJLWMnc2kqmHg1p.png" alt="image-20211107221323477"></p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);vector&lt;int&gt; sum(n+1,0);vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));//先输入数组for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}//初始化sum，方便求i,j之间的代价for(int i=0;i&lt;n;i++){sum[i+1] = sum[i] + nums[i];}//这是是遍历长度，2开始，1为0；for(int len = 2;len&lt;=n;len++){//这里初始化i，j,这里要右端点小于n，防止越界，斜方向遍历for(int i=0;i+len-1 &lt; n;i++){int j = i+len-1;dp[i][j] = INT_MAX;for(int k=i;k&lt;j;k++){dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]);}}}cout &lt;&lt; dp[0][n-1] &lt;&lt;endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-B-最长公共子序列"><a href="#问题-B-最长公共子序列" class="headerlink" title="问题 B: 最长公共子序列"></a>问题 B: 最长公共子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p><h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p><h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p><h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abccd aecd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){string str1,str2;cin &gt;&gt; str1 &gt;&gt; str2;int m = str1.size();int n = str2.size();vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));for(int i=1;i&lt;=m;i++){for(int j=1;j&lt;=n;j++){if(str1[i-1] == str2[j-1]){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = max(dp[i-1][j],dp[i][j-1]);}}}cout &lt;&lt; dp[m][n] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-C-三角形的路径权"><a href="#问题-C-三角形的路径权" class="headerlink" title="问题 C: 三角形的路径权"></a>问题 C: 三角形的路径权</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>如输入样例所示出了一个数字三角形。请编一个程序计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。每一步可沿左斜线向下或右斜线向下走；1&lt; 三角形行数&lt; 25；三角形中的数字为整数&lt; 1000；</p><h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为N，表示有N行 后面N行表示三角形每条路的路径权。</p><h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出路径所经过的数字的总和最大的答案。</p><h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">573 88 1 02 7 4 44 5 2 6 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>逆向，自底向上</p><p>i == N 时 <code>dp[i][j] = mp[i][j]</code></p><p>其他 ：<code>dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+mp[i][j]</code></p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;vector&lt;int&gt;&gt; mp(n,vector&lt;int&gt;(n,-1));for(int i=0;i&lt;n;i++){for(int j=0;j&lt;=i;j++){cin &gt;&gt; mp[i][j];}}vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(n+1,0));for(int i=n-1;i&gt;=0;i--){for(int j=0;j&lt;=i;j++){if(i == n-1){dp[i][j] = mp[i][j];}else{dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+mp[i][j];}}}cout &lt;&lt; dp[0][0] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-D-跳跃游戏二"><a href="#问题-D-跳跃游戏二" class="headerlink" title="问题 D: 跳跃游戏二"></a>问题 D: 跳跃游戏二</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组，假定你的初始位置为数组第一个下标。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标，并且使用最少的跳跃次数。例如：A = [2,3,1,1,4]，到达最后一个下标的最少跳跃次数为 2。（先跳跃11步，从下标0到1，然后跳跃3步，到达最后一个下标。一共两次）</p><h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个正整数n(1≤n≤100)，接下来的一行，输入n个整数，表示数组A。</p><h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>最后输出最少的跳跃次数。</p><h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">53 1 1 1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这里可以拿dp动态规划</p><p>但我选择更简单的贪心算法，求最大覆盖范围</p><p>看几次就可以覆盖终点</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-贪心算法"><a href="#方法一-贪心算法" class="headerlink" title="方法一 贪心算法"></a>方法一 贪心算法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}int curDistance = 0;    // 当前覆盖的最远距离下标int ans = 0;            // 记录走的最大步数int nextDistance = 0;   // 下一步覆盖的最远距离下标for(int i=0;i&lt;n-1;i++){nextDistance = max(nums[i]+i,nextDistance);if(i == curDistance){curDistance = nextDistance;ans++;}}cout &lt;&lt; ans &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-E-字母排序"><a href="#问题-E-字母排序" class="headerlink" title="问题 E: 字母排序"></a>问题 E: 字母排序</h1><p>时间限制: 1 Sec</p><p> 内存限制: 128 MB</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>XXXX年突然有外星人造访，但大家语言不通，不过科学家们经过研究发现外星人用26个英文字母组成的单词中最长不降子序列的长度来表述数字，且英文字母的排列顺序不同，现给出其排列顺序，再给出外星人说的每个数字（其实是每个英文单词，用空格隔开），翻译出外星人所说的数字（连续输出，最后加回车）。(因为是最长不降子序列，所以数字中没有0，也就是说外星人的数字是大于0的数字)。例如，我们正常的字母排列顺序是abcdefg…….xyz，代表a&lt; b&lt; c&lt; …..&lt; x&lt; y&lt; z abcd efg hhh ihg四个字符串的最长不降子序列的长度分别为4 3 3 1。</p><h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>第1，2行为字符串 含义如题描述。1≤第二行长度≤255。</p><h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>输出答案，含义如题描述</p><h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abcdefghijklmnopqrstuvwxyzabcd efg hhh ihg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4331<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){string str;cin &gt;&gt; str;    //这里map映射，因为是26的字母不分大小写，如果混合使用，统一转成小写就好了，map用红黑树，unordered_map应用哈希unordered_map&lt;char,int&gt; map;for(int i=0;i&lt;str.size();i++){map[str[i]] = i;}while(cin &gt;&gt; str){//里面就是最简单最大子序列//这里初始化为1vector&lt;int&gt; dp(str.size(),1);int ans = 0;for(int i=0;i&lt;str.size();i++){for(int j=0;j&lt;i;j++){if(map[str[i]] &gt;= map[str[j]]){dp[i] = max(dp[i],dp[j]+1);}if(ans &lt; dp[i]){ans = dp[i];}}}cout &lt;&lt; ans;}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h1 id="问题-A-Homework"><a href="#问题-A-Homework" class="headerlink" title="问题 A: Homework"></a>问题 A: Homework</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p><p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p><p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p><p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p><h2 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h2><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p><h2 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h2><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p><p>提示：float 的精度可能不够，你应该使用 double 类型。</p><h2 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 204 105 2210 31 20 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">37.00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>贪心算法，寻找性价比最高的</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;double&gt;a,vector&lt;double&gt; b){return a[2] &gt; b[2];}int main(){int m,n;while(cin &gt;&gt; m &gt;&gt; n){if(m == 0 &amp;&amp; n ==0){break;}vector&lt;vector&lt;double&gt;&gt; homework(m,vector&lt;double&gt;(3,0));for(int i=0;i&lt;m;i++){cin &gt;&gt; homework[i][0] &gt;&gt; homework[i][1];homework[i][2] = homework[i][1] / homework[i][0];}sort(homework.begin(),homework.end(),cmp);double ans = 0; for(int i=0;i&lt;n;i++){if(n &gt; homework[i][0]){ans += homework[i][1];n -= homework[i][0];}else{ans += homework[i][2] * n;break;}}printf("%.2lf\n",ans);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-B-区间包含问题"><a href="#问题-B-区间包含问题" class="headerlink" title="问题 B: 区间包含问题"></a>问题 B: 区间包含问题</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p><h2 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据，对于每组测试数据：</p><p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p><p>接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。</p><p>接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。</p><h2 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p><p>数据过大请使用快速输入输出。</p><h2 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 31 32 41 41 21 21 31 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">112<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>就是右端点小排序</p><p>优先选取满足小区间</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){return a[1] &lt; b[1];}int main(){int n, m;while(cin &gt;&gt; n &gt;&gt; m){vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));for(int i=0;i&lt;n;i++){cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];}sort(point.begin(),point.end(),cmp);while(m--){int left,right;cin &gt;&gt; left &gt;&gt; right;int ans = 0;for(int i=0;i&lt;n;i++){if(point[i][1] &gt; right){break;}if(left &lt;= point[i][0]){left = point[i][1];ans++;}}cout &lt;&lt; ans &lt;&lt; endl;}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-C-最长子序列"><a href="#问题-C-最长子序列" class="headerlink" title="问题 C: 最长子序列"></a>问题 C: 最长子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p><p>例如：</p><p>数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p><h2 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个不超过1000的整数n。</p><p>第二行输入n个整数A[i]。</p><h2 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，表示最大的和。</p><h2 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">31 1 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}int sum = 0;int ans = INT_MIN;for(int i=0;i&lt;n;i++){sum += nums[i];if(sum &gt; ans){ans = sum;}if(sum &lt; 0){sum = 0;}}cout &lt;&lt; ans &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-D-三值排序"><a href="#问题-D-三值排序" class="headerlink" title="问题 D: 三值排序"></a>问题 D: 三值排序</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>排序是一种很频繁的计算任务。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种1，2和3。我们用交换的方法把他排成升序的。</p><p>写一个程序计算出，计算出的一个包括1、2、3三种值的数字序列，排成升序所需的最少交换次数。</p><h2 id="输入-13"><a href="#输入-13" class="headerlink" title="输入"></a>输入</h2><p>输入第1行为类别的数量N（1≤N≤1000）</p><p>输入第2行到第N+1行，每行包括一个数字（1或2或3）。</p><h2 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h2><p>输出包含一行，为排成升序所需的最少交换次数。</p><h2 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">9221333231<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>交换次序的，</p><p>这个不太懂，背吧</p><h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;int sum[4] = {0,0,0,0};vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];sum[nums[i]]++;}int x = 0,y = 0,z=0;for(int i=0;i&lt;sum[1];i++){if(nums[i] != 1){x++;}}for(int i=sum[1];i&lt;sum[1]+sum[2];i++){if(nums[i] == 3){y++;}}for(int i=sum[1]+sum[2];i&lt;n;i++){if(nums[i] == 2){z++;}}cout &lt;&lt; x + max(y,z) &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-E-法师康的工人"><a href="#问题-E-法师康的工人" class="headerlink" title="问题 E: 法师康的工人"></a>问题 E: 法师康的工人</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。</p><p>你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。</p><p>·最长的至少有一个工人在工作的时间段</p><p>·最长的无人工作的时间段（从有人工作开始计）</p><h2 id="输入-14"><a href="#输入-14" class="headerlink" title="输入"></a>输入</h2><p>输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。</p><h2 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h2><p>输出为一行，用空格分隔开两个我们所求的数。</p><h2 id="样例输入-14"><a href="#样例输入-14" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3200 1000700 11001500 2100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-14"><a href="#样例输出-14" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">900 400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){if(a[0] == b[0])return a[1] &lt; b[1];return a[0] &lt; b[0];}int main(){int n;cin &gt;&gt; n;vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));for(int i=0;i&lt;n;i++){cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];}sort(point.begin(),point.end(),cmp);int maxx = 0;int minn = 0;int start,end;start = point[0][0];end = point[0][1];for(int i=1;i&lt;n;i++){if(point[i][0] &lt;= end){end =max(point[i][1],end);maxx = max(maxx,end - start);}else{start = point[i][0];minn = max(minn,start - end);end = point[i][1];}}cout &lt;&lt; maxx &lt;&lt; " " &lt;&lt; minn &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h1><h1 id="问题-A-进制转换"><a href="#问题-A-进制转换" class="headerlink" title="问题 A: 进制转换"></a>问题 A: 进制转换</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个十进制正整数，然后输出它所对应的八进制数。</p><h2 id="输入-15"><a href="#输入-15" class="headerlink" title="输入"></a>输入</h2><p>输入一个十进制正整数n(1≤n≤10<em>6</em>) 。</p><h2 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h2><p>输出n对应的八进制数，输出在一行。</p><h2 id="样例输入-15"><a href="#样例输入-15" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出-15"><a href="#样例输出-15" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-c语言-o强转"><a href="#方法一-c语言-o强转" class="headerlink" title="方法一 c语言%o强转"></a>方法一 c语言%o强转</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;printf("%o\n",n);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二-存储"><a href="#方法二-存储" class="headerlink" title="方法二 %/存储"></a>方法二 %/存储</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; num;while(n){num.push_back(n%8);n /= 8;}for(int i=num.size()-1;i&gt;=0;i--){cout &lt;&lt; num[i];}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-B-排列问题"><a href="#问题-B-排列问题" class="headerlink" title="问题 B: 排列问题"></a>问题 B: 排列问题</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h2 id="输入-16"><a href="#输入-16" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h2 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h2 id="样例输入-16"><a href="#样例输入-16" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出-16"><a href="#样例输出-16" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;string path;vector&lt;string&gt; result;vector&lt;int&gt; used;void backtrack(string str){if(path.size() == str.size()){result.push_back(path);return;}for(int i=0;i&lt;str.size();i++){if(used[i]){continue;}used[i] = 1;path.push_back(str[i]);backtrack(str);path.pop_back();used[i] = 0;}}int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());used.resize(str.size(),0);backtrack(str);for(auto s : result){cout &lt;&lt; s &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-C-快速幂"><a href="#问题-C-快速幂" class="headerlink" title="问题 C: 快速幂"></a>问题 C: 快速幂</h1><p>时间限制: 1 Sec</p><p>内存限制: 128 MB</p><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="%E7%BB%BC%E5%90%88%E7%89%88.assets/20180914130647_85638-16364329703111.png" alt="img"></p><h2 id="输入-17"><a href="#输入-17" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p><h2 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h2><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p><h2 id="样例输入-17"><a href="#样例输入-17" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-17"><a href="#样例输出-17" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">332893414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 100000007;long long mypow(long long x,long long m){long long ans = 1;while(m){if(m &amp; 1){ans = (ans * x) % mod;}m &gt;&gt;= 1;x = (x * x) %mod;}return ans;}int main(){int n;while(cin &gt;&gt; n){long long ans = 1;for(int i=1;i&lt;=n;i++){ans =(ans + mypow(i,i)) % mod;}cout &lt;&lt; ans &lt;&lt;endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-D-求第k小"><a href="#问题-D-求第k小" class="headerlink" title="问题 D: 求第k小"></a>问题 D: 求第k小</h1><p>时间限制: 1 Sec</p><p>内存限制: 128 MB</p><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h2 id="输入-18"><a href="#输入-18" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h2 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p><h2 id="样例输入-18"><a href="#样例输入-18" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 21 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-18"><a href="#样例输出-18" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int nums[1000002];int main(){int n,k;cin &gt;&gt; n &gt;&gt; k;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}sort(nums,nums+n);cout &lt;&lt; nums[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-E-沙子的质量"><a href="#问题-E-沙子的质量" class="headerlink" title="问题 E: 沙子的质量"></a>问题 E: 沙子的质量</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p><h2 id="输入-19"><a href="#输入-19" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p><h2 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p><h2 id="样例输入-19"><a href="#样例输入-19" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">41 3 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-19"><a href="#样例输出-19" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}vector&lt;int&gt; sum(n+1,0);for(int i=0;i&lt;n;i++){sum[i+1] = sum[i] + nums[i]; }vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,INT_MAX));for(int i=0;i&lt;n;i++){dp[i][i] = 0;}for(int len=2;len&lt;=n;len++){for(int i=0;i + len -1 &lt; n;i++){int j = i + len -1;for(int k=i;k&lt;j;k++){dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j] + sum[j+1]-sum[i]);}}}cout &lt;&lt; dp[0][n-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-F-最长公共子序列"><a href="#问题-F-最长公共子序列" class="headerlink" title="问题 F: 最长公共子序列"></a>问题 F: 最长公共子序列</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p><h2 id="输入-20"><a href="#输入-20" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p><h2 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p><h2 id="样例输入-20"><a href="#样例输入-20" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abccd aecd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出-20"><a href="#样例输出-20" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){string str1,str2;cin &gt;&gt; str1 &gt;&gt; str2;int m = str1.size();int n = str2.size();vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));for(int i=1;i&lt;=m;i++){for(int j=1;j&lt;=n;j++){if(str1[i-1] == str2[j-1]){dp[i][j] = dp[i-1][j-1] + 1;}else{dp[i][j] = max(dp[i][j-1],dp[i-1][j]);}}}cout &lt;&lt; dp[m][n] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-G-sort"><a href="#问题-G-sort" class="headerlink" title="问题 G: sort"></a>问题 G: sort</h1><p>时间限制: 1 Sec </p><p>内存限制: 64 MB</p><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你n个整数，请按从大到小的顺序输出其中前m大的数。</p><h2 id="输入-21"><a href="#输入-21" class="headerlink" title="输入"></a>输入</h2><p>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</p><h2 id="输出-21"><a href="#输出-21" class="headerlink" title="输出"></a>输出</h2><p>对每组测试数据按从大到小的顺序输出前m大的数。</p><h2 id="样例输入-21"><a href="#样例输入-21" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 33 -35 92 213 -644<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-21"><a href="#样例输出-21" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">213 92 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int nums[1000001];bool cmp(int a,int b){return a &gt; b;}int main(){int n,m;cin &gt;&gt; n &gt;&gt; m;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}sort(nums,nums+n,cmp);for(int i=0;i&lt;m;i++){cout &lt;&lt; nums[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-H-Joseph"><a href="#问题-H-Joseph" class="headerlink" title="问题 H: Joseph"></a>问题 H: Joseph</h1><p>时间限制: 1 Sec </p><p>内存限制: 32 MB</p><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>The Joseph’s problem is notoriously known. For those who are not familiar with the original problem: from among n people, numbered 1, 2, . . ., n, standing in circle every mth is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give us the message about the incident. For example when n = 6 and m = 5 then the people will be executed in the order 5, 4, 6, 2, 3 and 1 will be saved. </p><p>Suppose that there are k good guys and k bad guys. In the circle the first k are good guys and the last k bad guys. You have to determine such minimal m that all the bad guys will be executed before the first good guy.</p><p>约瑟夫问题是臭名昭著的。对于那些不熟悉原问题的人来说：从n个人中，编号为1，2，…，n，每隔m月站成一圈就要被处死，只有最后剩下的人的生命才能得到挽救。约瑟夫很聪明地选择了最后剩下的人的位置，从而保住了他的性命，给我们带来了关于这个事件的信息。例如，当n=6，m=5时，那么人们将按5、4、6、2、3的顺序被处决，1人将获救。</p><p>假设有k个好人和k个坏人。在这个圈子里，前k个是好人，后k个是坏人。你必须确定这样一个最小的m，使所有的坏人都在第一个好人之前被处决。</p><h2 id="输入-22"><a href="#输入-22" class="headerlink" title="输入"></a>输入</h2><p>The input file consists of separate lines containing k. The last line in the input file contains 0. You can suppose that 0 &lt; k &lt; 14.</p><p>输入文件由包含 k 的单独行组成。输入文件的最后一行包含 0。您可以假设 0 &lt; k &lt; 14。</p><h2 id="输出-22"><a href="#输出-22" class="headerlink" title="输出"></a>输出</h2><p>The output file will consist of separate lines containing m corresponding to k in the input file</p><p>输出文件将由包含与输入文件中的 k 对应的 m 的单独行组成</p><h2 id="样例输入-22"><a href="#样例输入-22" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">340<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-22"><a href="#样例输出-22" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">530<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;bool check(int m,int k){int res = 0;for(int i=1;i&lt;=k;i++){res = (res + m -1) % (2*k-i+1);if(res &lt; k){return false;}}return true;}int main(){int k;while((cin &gt;&gt; k) &amp;&amp; k){for(int i=k+1;;i++){if(check(i,k) == true){cout &lt;&lt; i &lt;&lt; endl;break;}}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-I-Factstone-Benchmark"><a href="#问题-I-Factstone-Benchmark" class="headerlink" title="问题 I: Factstone Benchmark"></a>问题 I: Factstone Benchmark</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>Amtel has announced that it will release a 128-bit computer chip by 2010, a 256-bit computer by 2020, and so on, continuing its strategy of doubling the word-size every ten years. (Amtel released a 64-bit computer in 2000, a 32-bit computer in 1990, a 16-bit computer in 1980, an 8-bit computer in 1970, and a 4-bit computer, its first, in 1960.)</p><p>Amtel will use a new benchmark - the <em>Factstone</em> - to advertise the vastly improved capacity of its new chips. The <em>Factstone</em> rating is defined to be the largest integer <em>n</em> such that <em>n!</em> can be represented as an unsigned integer in a computer word.</p><p>Given a year <em>1960 ≤ y ≤ 2160</em>, what will be the <em>Factstone</em> rating of Amtel’s most recently released chip?</p><p>Amtel公司已经宣布，它将在2010年之前发布128位计算机芯片，在2020年之前发布256位计算机，以此类推，继续其每十年将字数增加一倍的战略。(Amtel在2000年发布了64位计算机，1990年发布了32位计算机，1980年发布了16位计算机，1970年发布了8位计算机，1960年发布了其第一款4位计算机）。</p><p>Amtel公司将使用一种新的基准—Factstone—来宣传其新芯片的巨大改进的能力。Factstone评级被定义为最大的整数n，使n！可以在计算机字中表示为一个无符号整数。</p><p>考虑到1960≤y≤2160年，Amtel最近发布的芯片的Factstone等级将是多少？</p><h2 id="输入-23"><a href="#输入-23" class="headerlink" title="输入"></a>输入</h2><p>There are several test cases. For each test case, there is one line of input containing <em>y</em>. A line containing 0 follows the last test case.</p><p>有几个测试用例。对于每个测试用例，有一行包含 y 的输入。包含 0 的行跟随最后一个测试用例</p><h2 id="输出-23"><a href="#输出-23" class="headerlink" title="输出"></a>输出</h2><p>For each test case, output a line giving the Factstone rating. </p><p>对于每个测试用例，输出一行给出Factstone等级。</p><h2 id="样例输入-23"><a href="#样例输入-23" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">196019810<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-23"><a href="#样例输出-23" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">38<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int n;while((cin &gt;&gt; n) &amp;&amp; n){double  a = log2(4.0);for (int i = 1960; i &lt;= n; i += 10)a *= 2;double  f = 0;int i = 0;while(f &lt; a){++i;f += log2(double(i));}cout &lt;&lt; i - 1 &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-J-Ants"><a href="#问题-J-Ants" class="headerlink" title="问题 J: Ants"></a>问题 J: Ants</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>An army of ants walk on a horizontal pole of length <em>l</em> cm, each with a constant speed of 1 cm/s. When a walking ant reaches an end of the pole, it immediatelly falls off it. When two ants meet they turn back and start walking in opposite directions. We know the original positions of ants on the pole, unfortunately, we do not know the directions in which the ants are walking. Your task is to compute the earliest and the latest possible times needed for all ants to fall off the pole. </p><p>一群蚂蚁走在一根长为 l cm 的水平杆上，每支蚂蚁以 1 cm/s 的恒定速度行走。当一只行走的蚂蚁到达杆子的末端时，它会立即从杆子上掉下来。当两只蚂蚁相遇时，它们会转身向相反的方向走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆子上掉下来所需的最早和最晚时间。</p><h2 id="输入-24"><a href="#输入-24" class="headerlink" title="输入"></a>输入</h2><p>The first line of input contains one integer giving the number of cases that follow. The data for each case start with two integer numbers: the length of the pole (in cm) and <em>n</em>, the number of ants residing on the pole. These two numbers are followed by <em>n</em> integers giving the position of each ant on the pole as the distance measured from the left end of the pole, in no particular order. All input integers are not bigger than 1000000 and they are separated by whitespace. </p><p>输入的第一行包含一个整数，给出后面的案例数。每个案例的数据都以两个整数开始：杆的长度（以厘米为单位）和 n，杆上的蚂蚁数量。这两个数字后跟 n 个整数，表示每只蚂蚁在杆子上的位置，即从杆子左端测量的距离，没有特定的顺序。所有输入的整数都不大于 1000000，并且它们以空格分隔。</p><h2 id="输出-24"><a href="#输出-24" class="headerlink" title="输出"></a>输出</h2><p>For each case of input, output two numbers separated by a single space. The first number is the earliest possible time when all ants fall off the pole (if the directions of their walks are chosen appropriately) and the second number is the latest possible such time.</p><p>对于输入的每种情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆子上掉下来的最早时间（如果它们的行走方向选择得当），第二个数字是最晚的时间。</p><h2 id="样例输入-24"><a href="#样例输入-24" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">210 32 6 7214 711 12 7 13 176 23 191<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-24"><a href="#样例输出-24" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4 838 207<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><p><code>Min=max(Min,min(a[i],L-a[i]));</code></p><p><code>Max=max(Max,max(a[i],L-a[i]));</code></p><h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int t;cin &gt;&gt; t;while(t--){int l,n;cin &gt;&gt; l &gt;&gt; n;vector&lt;int&gt; ants(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; ants[i];}int Max = 0, Min = 0;for(int i=0;i&lt;n;i++){Min = max(Min,min(ants[i],l-ants[i]));Max = max(Max,max(ants[i],l-ants[i]));}cout &lt;&lt; Min &lt;&lt; " " &lt;&lt; Max &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-K-Matches-Game"><a href="#问题-K-Matches-Game" class="headerlink" title="问题 K: Matches Game"></a>问题 K: Matches Game</h1><p>时间限制: 1 Sec </p><p>内存限制: 64 MB</p><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>Here is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not. </p><p>这是一个简单的游戏。在这场比赛中，有几堆比赛和两名球员。两个玩家轮流玩。在每一回合中，可以选择一堆并从堆中带走任意数量的火柴（当然，被带走的火柴数量不能为零，也不能大于所选堆中的火柴数量）。如果在轮到玩家之后，没有剩余比赛，则该玩家为赢家。假设两个玩家都非常清楚。你的工作是判断先玩的玩家能否赢得比赛。</p><h2 id="输入-25"><a href="#输入-25" class="headerlink" title="输入"></a>输入</h2><p>The input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 &lt;= M &lt;=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.</p><p>输入由几行组成，每行都有一个测试用例。在一行的开头，有一个整数M（1 &lt;= M &lt;=20），就是桩的数量。然后是M个正整数，不大于10000000。这M个整数代表每堆匹配的数量。</p><h2 id="输出-25"><a href="#输出-25" class="headerlink" title="输出"></a>输出</h2><p>For each test case, output “Yes” in a single line, if the player who play first will win, otherwise output “No”.</p><p>对于每个测试用例，单行输出“Yes”，如果先玩的玩家获胜，否则输出“No”。</p><h2 id="样例输入-25"><a href="#样例输入-25" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 45 453 3 6 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-25"><a href="#样例输出-25" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">NoYes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><p>这题有问题，我一直感觉学算法，优化应该在熟悉证明上，在算法复杂度上进行优化，而不是在语言效率，底层输入输出上。</p><h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><h3 id="c-过不了"><a href="#c-过不了" class="headerlink" title="c++过不了"></a>c++过不了</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int m;while(~scanf("%d",&amp;m)){int flag = 0;long long x;for(int i=0;i&lt;m;i++){cin &gt;&gt; x;flag ^= x;}if(flag) cout &lt;&lt; "Yes" &lt;&lt; endl;elsecout &lt;&lt; "No" &lt;&lt; endl; }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="c就能过"><a href="#c就能过" class="headerlink" title="c就能过"></a>c就能过</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            flag<span class="token operator">^=</span>x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Yes\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-L-sort2"><a href="#问题-L-sort2" class="headerlink" title="问题 L: sort2"></a>问题 L: sort2</h1><p>时间限制: 1 Sec</p><p>内存限制: 64 MB</p><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你n个整数，请按从大到小的顺序输出其中前m大的数。</p><h2 id="输入-26"><a href="#输入-26" class="headerlink" title="输入"></a>输入</h2><p>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个都处于区间[-500000,500000]的整数，<strong><em>整数可能会重复出现\</em></strong>。</p><h2 id="输出-26"><a href="#输出-26" class="headerlink" title="输出"></a>输出</h2><p>对每组测试数据按从大到小的顺序输出前m大的数。</p><h2 id="样例输入-26"><a href="#样例输入-26" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">10 51 2 3 4 5 6 7 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-26"><a href="#样例输出-26" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">9 8 7 7 6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><h3 id="直接sort超时"><a href="#直接sort超时" class="headerlink" title="直接sort超时"></a>直接sort超时</h3><h3 id="map超时"><a href="#map超时" class="headerlink" title="map超时"></a>map超时</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int nums[1000001];int main(){int n,m;cin &gt;&gt; n &gt;&gt; m;map&lt;int,int&gt; mp;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];if(mp.find(nums[i]) != mp.end()){mp[nums[i]]++;}mp.insert(pair&lt;int,int&gt;(nums[i],1));}int i = 0;for(auto num : mp){while(num.second){nums[i] = num.first;num.second--;i++;}}for(int i=n-1;i&gt;n-m-1;i--){cout &lt;&lt; nums[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int offset = 500000;int Hash[1000001] = {0};int main(){int m,n;while(cin &gt;&gt; n &gt;&gt; m){for(int i=0;i&lt;n;i++){int x;cin &gt;&gt; x;Hash[x+offset]++;}for(int i=offset;i&gt;=-offset &amp;&amp; m &gt; 0;i--){while(Hash[i+offset] &gt; 0 &amp;&amp; m &gt; 0){cout &lt;&lt; i &lt;&lt; " ";Hash[i+offset]--;m--;}}cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><h1 id="问题-A-单词排序"><a href="#问题-A-单词排序" class="headerlink" title="问题 A: 单词排序"></a>问题 A: 单词排序</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。</p><h2 id="输入-27"><a href="#输入-27" class="headerlink" title="输入"></a>输入</h2><p>输入包含两行。</p><p>第一行仅包括一个正整数N(0&lt;N≤26)。</p><p>第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。</p><p>单个单词长度不超过1010。</p><h2 id="输出-27"><a href="#输出-27" class="headerlink" title="输出"></a>输出</h2><p>输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。</p><h2 id="样例输入-27"><a href="#样例输入-27" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4city boy tree student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-27"><a href="#样例输出-27" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">boy city student tree <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;string&gt; strs;for(int i=0;i&lt;n;i++){string str;cin &gt;&gt; str;strs.push_back(str);}sort(strs.begin(),strs.end());for(int i=0;i&lt;n;i++){cout &lt;&lt; strs[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-B-求数组的最长递减子序列"><a href="#问题-B-求数组的最长递减子序列" class="headerlink" title="问题 B: 求数组的最长递减子序列"></a>问题 B: 求数组的最长递减子序列</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p><h2 id="输入-28"><a href="#输入-28" class="headerlink" title="输入"></a>输入</h2><p>输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p><h2 id="输出-28"><a href="#输出-28" class="headerlink" title="输出"></a>输出</h2><p>输出最长递减子序列，数字之间有一个空格。</p><h2 id="样例输入-28"><a href="#样例输入-28" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">89 4 3 2 5 4 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-28"><a href="#样例输出-28" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">9 5 4 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>求个数很简单，但最后输出的是序列数组，这个比较麻烦。</p><p>前面求出dp动态数组和最大值，顺便记录最大值的下表和值</p><p>以及每一步的前面的下表，方便后面循环查找。</p><h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}vector&lt;int&gt; dp(n,1);vector&lt;int&gt; track(n,-1);int result = 0;int rp = -1;for(int i=0;i&lt;n;i++){for(int j=0;j&lt;i;j++){if((nums[i] &lt; nums[j]) &amp;&amp; dp[j]+1 &gt; dp[i]){dp[i] = dp[j] + 1;track[i] = j;}if(dp[i] &gt; result){result = dp[i];rp = i;}}}vector&lt;int&gt; ans;for(int i=result;i&gt;0;i--){ans.push_back(nums[rp]);if(track[rp] == -1)break;rp = track[rp];}for(int i=ans.size()-1;i&gt;=0;i--){cout &lt;&lt; ans[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-C-矩形滑雪场"><a href="#问题-C-矩形滑雪场" class="headerlink" title="问题 C: 矩形滑雪场"></a>问题 C: 矩形滑雪场</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。</p><h2 id="输入-29"><a href="#输入-29" class="headerlink" title="输入"></a>输入</h2><p>第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。</p><h2 id="输出-29"><a href="#输出-29" class="headerlink" title="输出"></a>输出</h2><p>仅一行:输出1个整数，表示可以滑行的最大长度。</p><h2 id="样例输入-29"><a href="#样例输入-29" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-29"><a href="#样例输出-29" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><p>有点难，dfs搜索应该可以</p><p>这里还是那动态规划，把这个看成大型的二维的最长递减序列。</p><h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> #include&lt;bits/stdc++.h&gt;using namespace std;struct node{int x;int y;int n;};bool cmp(node a,node b){    return a.n&lt;b.n;}//node nums[100005];int main(){int m,n;cin &gt;&gt; m &gt;&gt; n;vector&lt;node&gt; nums(m*n);int index = 0;for(int i=0;i&lt;m;i++){for(int j=0;j&lt;n;j++){cin &gt;&gt; nums[index].n;nums[index].x = i;nums[index].y = j;index++;}}sort(nums.begin(),nums.end(),cmp);//大型的最长递减子序列int result = 0;vector&lt;int&gt; dp(index,1);for(int i=0;i&lt;index;i++){for(int j=0;j&lt;i;j++){//这里判断条件改成前后左右if(((nums[i].x==nums[j].x &amp;&amp; abs(nums[i].y-nums[j].y)==1) || (nums[i].y==nums[j].y &amp;&amp; abs(nums[i].x-nums[j].x)==1)) &amp;&amp; nums[i].n &gt; nums[j].n){dp[i] = max(dp[i],dp[j]+1);}if(dp[i] &gt; result){result = dp[i];}}}cout &lt;&lt; result &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;struct node{int x,y,h;};bool cmp(node a,node b){return a.h &lt; b.h;}node nums[999999];int main(){int r,c;cin &gt;&gt; r &gt;&gt; c;int n = 0;for(int i=0;i&lt;r;i++){for(int j=0;j&lt;c;j++){cin &gt;&gt; nums[n].h;nums[n].x = i;nums[n].y = j;n++; }}sort(nums,nums+n,cmp);vector&lt;int&gt; dp(n,1);int result = 0;for(int i=0;i&lt;n;i++){for(int j=0;j&lt;i;j++){if((nums[i].h &gt; nums[j].h) &amp;&amp; (abs(nums[i].x-nums[j].x) + abs(nums[i].y-nums[j].y)) == 1){dp[i] = max(dp[i],dp[j]+1);}if(dp[i] &gt; result){result = dp[i];}}}cout &lt;&lt; result &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-D-Homework"><a href="#问题-D-Homework" class="headerlink" title="问题 D: Homework"></a>问题 D: Homework</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p><p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p><p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p><p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p><h2 id="输入-30"><a href="#输入-30" class="headerlink" title="输入"></a>输入</h2><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p><h2 id="输出-30"><a href="#输出-30" class="headerlink" title="输出"></a>输出</h2><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p><p>提示：float 的精度可能不够，你应该使用 double 类型。</p><h2 id="样例输入-30"><a href="#样例输入-30" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 204 105 2210 31 20 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-30"><a href="#样例输出-30" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">37.00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;double&gt;a,vector&lt;double&gt; b){return a[2] &gt; b[2];}int main(){int m,n;while(cin &gt;&gt; m &gt;&gt; n){if(m == 0 &amp;&amp; n ==0){break;}vector&lt;vector&lt;double&gt;&gt; homework(m,vector&lt;double&gt;(3,0));for(int i=0;i&lt;m;i++){cin &gt;&gt; homework[i][0] &gt;&gt; homework[i][1];homework[i][2] = homework[i][1] / homework[i][0];}sort(homework.begin(),homework.end(),cmp);double ans = 0; for(int i=0;i&lt;n;i++){if(n &gt; homework[i][0]){ans += homework[i][1];n -= homework[i][0];}else{ans += homework[i][2] * n;break;}}printf("%.2lf\n",ans);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-E-区间包含问题"><a href="#问题-E-区间包含问题" class="headerlink" title="问题 E: 区间包含问题"></a>问题 E: 区间包含问题</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p><h2 id="输入-31"><a href="#输入-31" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据，对于每组测试数据：</p><p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p><p>接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。</p><p>接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。</p><h2 id="输出-31"><a href="#输出-31" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p><p>数据过大请使用快速输入输出。</p><h2 id="样例输入-31"><a href="#样例输入-31" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 31 32 41 41 21 21 31 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-31"><a href="#样例输出-31" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">112<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><p>就是右端点小排序</p><p>优先选取满足小区间</p><h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){return a[1] &lt; b[1];}int main(){int n, m;while(cin &gt;&gt; n &gt;&gt; m){vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));for(int i=0;i&lt;n;i++){cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];}sort(point.begin(),point.end(),cmp);while(m--){int left,right;cin &gt;&gt; left &gt;&gt; right;int ans = 0;for(int i=0;i&lt;n;i++){if(point[i][1] &gt; right){break;}if(left &lt;= point[i][0]){left = point[i][1];ans++;}}cout &lt;&lt; ans &lt;&lt; endl;}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-F-最长子序列"><a href="#问题-F-最长子序列" class="headerlink" title="问题 F: 最长子序列"></a>问题 F: 最长子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p><p>例如：</p><p>数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p><h2 id="输入-32"><a href="#输入-32" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个不超过1000的整数n。</p><p>第二行输入n个整数A[i]。</p><h2 id="输出-32"><a href="#输出-32" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，表示最大的和。</p><h2 id="样例输入-32"><a href="#样例输入-32" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">31 1 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="样例输出-32"><a href="#样例输出-32" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;cin &gt;&gt; n;vector&lt;int&gt; nums(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}int sum = 0;int ans = INT_MIN;for(int i=0;i&lt;n;i++){sum += nums[i];if(sum &gt; ans){ans = sum;}if(sum &lt; 0){sum = 0;}}cout &lt;&lt; ans &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-G-元素整除问题"><a href="#问题-G-元素整除问题" class="headerlink" title="问题 G: 元素整除问题"></a>问题 G: 元素整除问题</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。</p><h2 id="输入-33"><a href="#输入-33" class="headerlink" title="输入"></a>输入</h2><p>输入20个整数</p><h2 id="输出-33"><a href="#输出-33" class="headerlink" title="输出"></a>输出</h2><p>按输入顺序输出符合要求的数字，每行输出一个整数。</p><h2 id="样例输入-33"><a href="#样例输入-33" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="样例输出-33"><a href="#样例输出-33" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">46891012141516182021<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std; int main(){    vector&lt;int&gt; nums(20,0);    for(int i=0;i&lt;20;i++){        cin &gt;&gt; nums[i];    }    for(int i=0;i&lt;20;i++){        bool flag = false;        for(int j=0;j&lt;20;j++){            if(i == j){                continue;            }            if((nums[i] % nums[j]) == 0){                flag = true;            }        }        if(flag){            cout &lt;&lt; nums[i] &lt;&lt;endl;        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-H-渊子赛马"><a href="#问题-H-渊子赛马" class="headerlink" title="问题 H: 渊子赛马"></a>问题 H: 渊子赛马</h1><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p><h2 id="输入-34"><a href="#输入-34" class="headerlink" title="输入"></a>输入</h2><p>输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。</p><h2 id="输出-34"><a href="#输出-34" class="headerlink" title="输出"></a>输出</h2><p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。</p><h2 id="样例输入-34"><a href="#样例输入-34" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">52 3 3 4 51 2 3 4 542 2 1 22 2 3 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-34"><a href="#样例输出-34" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">YESNO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><p>贪心吧</p><p>先分别排序，看<code>a[i] &gt; b[j]</code>  如果大于那就赢了一把，敌方换马，如果一直没赢，因为从大到小排序，证明后面也赢不了。</p><p>切记记录失败次数。</p><h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){int n;while((cin &gt;&gt; n) &amp;&amp; n){vector&lt;int&gt; a(n,0);vector&lt;int&gt; b(n,0);for(int i=0;i&lt;n;i++){cin &gt;&gt; a[i];}for(int i=0;i&lt;n;i++){cin &gt;&gt; b[i];}sort(a.begin(),a.end());sort(b.begin(),b.end());int cnt1 =0, cnt2 = 0;int j = 0;for(int i=0;i&lt;n;i++){if(a[i] &gt; b[j]){cnt1++;j++;}else{cnt2++;}}if(cnt1 &gt; cnt2){cout &lt;&lt; "YES" &lt;&lt; endl;}else{cout &lt;&lt; "NO" &lt;&lt; endl;}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-I-The-Hardest-Problem-Ever"><a href="#问题-I-The-Hardest-Problem-Ever" class="headerlink" title="问题 I: The Hardest Problem Ever"></a>问题 I: The Hardest Problem Ever</h1><p>时间限制: 1 Sec </p><p>内存限制: 32 MB</p><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>Julius Caesar lived in a time of danger and intrigue. The hardest situation Caesar ever faced was keeping himself alive. In order for him to survive, he decided to create one of the first ciphers. This cipher was so incredibly sound, that no one could figure it out without knowing how it worked. </p><p>You are a sub captain of Caesar’s army. It is your job to decipher the messages sent by Caesar and provide to your general. The code is simple. For each letter in a plaintext message, you shift it five places to the right to create the secure message (i.e., if the letter is ‘A’, the cipher text would be ‘F’). Since you are creating plain text out of Caesar’s messages, you will do the opposite: </p><p>Cipher text<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z </p><p>Plain text<br>V W X Y Z A B C D E F G H I J K L M N O P Q R S T U </p><p>Only letters are shifted in this cipher. Any non-alphabetical character should remain the same, and all alphabetical characters will be upper case.</p><p>朱利叶斯·凯撒生活在一个充满危险和阴谋的时代。凯撒面临的最艰难的情况是让自己活着。为了让他活下来，他决定创造第一个密码。这个密码非常可靠，如果不知道它是如何工作的，就没有人能猜出它。</p><p>你是凯撒军队的副队长。你的工作是破译凯撒发送的信息并提供给你的将军。代码很简单。对于明文消息中的每个字母，您将其向右移动五位以创建安全消息（即，如果字母是“A”，则密文将是“F”）。由于您是从 Caesar 的消息中创建纯文本，因此您将执行相反的操作：</p><p>密文</p><p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>纯文本</p><p>V W X Y Z A B C D E F G H I J K L M N O P Q R S T U</p><p>在这个密码中只有字母被移位。任何非字母字符都应保持不变，所有字母字符都将大写。</p><h2 id="输入-35"><a href="#输入-35" class="headerlink" title="输入"></a>输入</h2><p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets. All characters will be uppercase. </p><p>A single data set has 3 components: </p><ol><li>Start line - A single line, “START” </li><li>Cipher message - A single line containing from one to two hundred characters, inclusive, comprising a single message from Caesar </li><li>End line - A single line, “END” </li></ol><p>Following the final data set will be a single line, “ENDOFINPUT”. </p><p>此问题的输入将包含最多 100 个数据集的（非空）系列。每个数据集将根据以下描述进行格式化，并且不会有分隔数据集的空行。所有字符都将大写。</p><p>单个数据集有 3 个组成部分：</p><p>起始行 - 单行，“START”</p><p>密码消息 - 一行包含 1 到 200 个字符（含），包含来自 Caesar 的单个消息</p><p>结束行 - 单行，“END”</p><p>在最终数据集之后将是一行，“ENDOFINPUT”。</p><h2 id="输出-35"><a href="#输出-35" class="headerlink" title="输出"></a>输出</h2><p>For each data set, there will be exactly one line of output. This is the original message by Caesar.</p><p>对于每个数据集，只会有一行输出。这是凯撒的原始信息。</p><h2 id="样例输入-35"><a href="#样例输入-35" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">STARTNS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJXENDSTARTN BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJENDSTARTIFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJENDENDOFINPUT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-35"><a href="#样例输出-35" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSESI WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROMEDANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><p>凯撒加密，难度上没啥，就是控制输入输出得调试。</p><h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){string str;while(1){cin &gt;&gt; str;if(str == "ENDOFINPUT"){break;}else if(str == "START"){cin &gt;&gt; str;string s;getline(cin,s);s = str + s;string c;for(int i=0;i &lt; s.size();i++){if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z'){c.push_back((s[i] - 'A'+26-5)%26 + 'A');}else{c.push_back(s[i]);}}cout &lt;&lt; c &lt;&lt; endl;}else if(str == "END"){continue;}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="问题-J-Rock-Paper-Scissors-Tournament"><a href="#问题-J-Rock-Paper-Scissors-Tournament" class="headerlink" title="问题 J: Rock-Paper-Scissors Tournament"></a>问题 J: Rock-Paper-Scissors Tournament</h1><p>时间限制: 3 Sec </p><p>内存限制: 64 MB</p><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>Rock-Paper-Scissors is game for two players, A and B, who each choose, independently of the other, one of rock, paper, or scissors. A player chosing paper wins over a player chosing rock; a player chosing scissors wins over a player chosing paper; a player chosing rock wins over a player chosing scissors. A player chosing the same thing as the other player neither wins nor loses.<br>A tournament has been organized in which each of n players plays k rock-scissors-paper games with each of the other players - k<em>n</em>(n-1)/2 games in total. Your job is to compute the win average for each player, defined as w / (w + l) where w is the number of games won, and l is the number of games lost, by the player. </p><p>Rock-Paper-Scissors 是 A 和 B 两个玩家的游戏，他们各自独立地选择石头、纸或剪刀之一。选择纸的玩家胜过选择石头的玩家；选择剪刀的玩家胜过选择纸的玩家；选择石头的玩家胜过选择剪刀的玩家。与其他玩家选择相同事物的玩家既不会赢也不会输。</p><p>已经组织了一个锦标赛，其中 n 个玩家中的每一个与其他每个玩家玩 k 个石头剪刀布游戏 - 总共 k<em>n</em>(n-1)/2 个游戏。您的工作是计算每个玩家的平均获胜次数，定义为 w / (w + l)，其中 w 是该玩家赢得的游戏数量，l 是该玩家输掉的游戏数量。</p><h2 id="输入-36"><a href="#输入-36" class="headerlink" title="输入"></a>输入</h2><p>Input consists of several test cases. The first line of input for each case contains 1 &lt;= n &lt;= 100 1 &lt;= k &lt;= 100 as defined above. For each game, a line follows containing p1, m1, p2, m2. 1 &lt;= p1 &lt;= n and 1 &lt;= p2 &lt;= n are distinct integers identifying two players; m1 and m2 are their respective moves (“rock”, “scissors”, or “paper”). A line containing 0 follows the last test case.</p><p>输入由几个测试用例组成。每个案例的第一行输入包含 1 &lt;= n &lt;= 100 1 &lt;= k &lt;= 100，如上所定义。对于每个游戏，后面有一行包含 p1、m1、p2、m2。 1 &lt;= p1 &lt;= n 和 1 &lt;= p2 &lt;= n 是识别两个玩家的不同整数； m1 和 m2 是它们各自的移动（“石头”、“剪刀”或“纸”）。包含 0 的行跟随最后一个测试用例。</p><h2 id="输出-36"><a href="#输出-36" class="headerlink" title="输出"></a>输出</h2><p>Output one line each for player 1, player 2, and so on, through player n, giving the player’s win average rounded to three decimal places. If the win average is undefined, output “-“. Output an empty line between cases.</p><p>为玩家 1、玩家 2 等输出一行，通过玩家 n，将玩家的胜利平均值四舍五入到小数点后三位。如果未定义获胜平均值，则输出“-”。在案例之间输出一个空行。</p><h2 id="样例输入-36"><a href="#样例输入-36" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 41 rock 2 paper1 scissors 2 paper1 rock 2 rock2 rock 1 scissors2 11 rock 2 paper0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-36"><a href="#样例输出-36" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">0.3330.6670.0001.000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><h1 id="问题-K-Balloon-Robot"><a href="#问题-K-Balloon-Robot" class="headerlink" title="问题 K: Balloon Robot"></a>问题 K: Balloon Robot</h1><p>时间限制: 1 Sec </p><p>内存限制: 64 MB</p><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>The 2017 China Collegiate Programming Contest Qinhuangdao Site is coming! There will be (n) teams participating in the contest, and the contest will be held on a huge round table with (m) seats numbered from 1 to (m) in clockwise order around it. The (i)-th team will be seated on the (s_i)-th seat.</p><p>BaoBao, an enthusiast for competitive programming, has made (p) predictions of the contest result before the contest. Each prediction is in the form of ((a_i,b_i)), which means the (a_i)-th team solves a problem during the (b_i)-th time unit.</p><p>As we know, when a team solves a problem, a balloon will be rewarded to that team. The participants will be unhappy if the balloons take almost centuries to come. If a team solves a problem during the (t_a)-th time unit, and the balloon is sent to them during the (t_b)-th time unit, then the unhappiness of the team will increase by (t_b-t_a). In order to give out balloons timely, the organizers of the contest have bought a balloon robot.</p><p>At the beginning of the contest (that is to say, at the beginning of the 1st time unit), the robot will be put on the (k)-th seat and begin to move around the table. If the robot moves past a team which has won themselves some balloons after the robot’s last visit, it will give all the balloons they deserve to the team. During each unit of time, the following events will happen <strong>in order</strong>:</p><ol><li>The robot moves to the next seat. That is to say, if the robot is currently on the (i)-th ((1 \le i &lt; m)) seat, it will move to the ((i+1))-th seat; If the robot is currently on the (m)-th seat, it will move to the 1st seat.</li><li>The participants solve some problems according to BaoBao’s prediction.</li><li>The robot gives out balloons to the team seated on its current position if needed.</li></ol><p>BaoBao is interested in minimizing the total unhappiness of all the teams. Your task is to select the starting position (k) of the robot and calculate the minimum total unhappiness of all the teams according to BaoBao’s predictions.</p><h2 id="输入-37"><a href="#输入-37" class="headerlink" title="输入"></a>输入</h2><p>There are multiple test cases. The first line of the input contains an integer T, indicating the number of test cases. For each test case:</p><p>The first line contains three integers (n), (m) and (p) ((1 \le n \le 10^5), (n \le m \le 10^9), (1 \le p \le 10^5)), indicating the number of participating teams, the number of seats and the number of predictions.</p><p>The second line contains (n) integers (s_1, s_2, \dots, s_n) ((1 \le s_i \le m), and (s_i \ne s_j) for all (i \ne j)), indicating the seat number of each team.</p><p>The following (p) lines each contains two integers (a_i) and (b_i) ((1 \le a_i \le n), (1 \le b_i \le 10^9)), indicating that the (a_i)-th team solves a problem at time (b_i) according to BaoBao’s predictions.</p><p>It is guaranteed that neither the sum of (n) nor the sum of (p) over all test cases will exceed (5 \times 10^5).</p><h2 id="输出-37"><a href="#输出-37" class="headerlink" title="输出"></a>输出</h2><p>For each test case output one integer, indicating the minimum total unhappiness of all the teams according to BaoBao’s predictions.</p><h2 id="样例输入-37"><a href="#样例输入-37" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">42 3 31 21 12 11 42 3 51 21 12 11 21 31 43 7 53 5 71 52 13 31 52 52 100 21 511 5002 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="样例输出-37"><a href="#样例输出-37" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">14550<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/15/hello-world/"/>
      <url>/2021/11/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="欢迎访问我的博客"><a href="#欢迎访问我的博客" class="headerlink" title="欢迎访问我的博客"></a>欢迎访问我的博客</h2><p>欢迎访问，这里预计不定期更新一些最近的思路和一些奇奇怪怪的想法，当然也包括日常emo，欢迎吐槽。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
