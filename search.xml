<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法理论复习</title>
      <link href="/2021/11/18/suan-fa-li-lun-fu-xi/"/>
      <url>/2021/11/18/suan-fa-li-lun-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="算法理论复习"><a href="#算法理论复习" class="headerlink" title="算法理论复习"></a>算法理论复习</h1><blockquote><p>本文参考：胡神笔记：<a href="https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/">https://junyaohu.github.io/2021/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</a></p></blockquote><h2 id="1-算法概叙"><a href="#1-算法概叙" class="headerlink" title="1.算法概叙"></a>1.算法概叙</h2><blockquote><p>算法复杂性和算法复杂性的计算O记，以及倍率计算</p></blockquote><h3 id="1-1-算法概念"><a href="#1-1-算法概念" class="headerlink" title="1.1 算法概念"></a>1.1 算法概念</h3><h4 id="1-1-1-概念"><a href="#1-1-1-概念" class="headerlink" title="1.1.1 概念"></a>1.1.1 概念</h4><p>一系列将问题的输入转换为输出的计算或操作步骤。</p><h4 id="1-1-2-性质"><a href="#1-1-2-性质" class="headerlink" title="1.1.2 性质"></a>1.1.2 性质</h4><ul><li>输入          有外部提供的量作为算法的输入。</li><li>输出          算法产生至少一个量作为输出。</li><li>确定性        组成算法的每条指令是清晰、无歧义的。</li><li>有限性        算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。</li></ul><h3 id="1-2-算法复杂性"><a href="#1-2-算法复杂性" class="headerlink" title="1.2 算法复杂性"></a>1.2 算法复杂性</h3><p><strong>算法的复杂性(C):</strong></p><p>算法执行所需的时间和空间的数量。<br>$$<br>T=T(N, I)=\sum_{i=1}^{k} t_{i} e_{i}(N, I)<br>$$</p><p><strong>平均情况</strong><br>$$<br>T_{\text {avg }}(N)=\sum_{I \in D_{N}} P(I) T(N, I)=\sum_{I \in D_{N}} P(I) \sum_{i=1}^{k} t_{i} e_{i}(N, I)<br>$$</p><p><strong>渐进性态</strong></p><p>$$<br>\frac{T(N)-\overset{\thicksim}{T}(N)}{T(N)} \rightarrow 0<br>$$<br><strong>大O表示法(算法运行时间的上限 )</strong></p><p>就是逼近的一个上界，可以那泰勒的上界来理解。</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050100.png" alt="image-20211115191500303"></p><p><strong>大W表示法(算法运行时间的下限）</strong></p><p>下界</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050194.png" alt="image-20211115191635671"></p><p>算法复杂度排序：</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050247.png" alt="时间复杂度，不同数据规模的差异"></p><h3 id="1-3-NP问题判断"><a href="#1-3-NP问题判断" class="headerlink" title="1.3 NP问题判断"></a>1.3 NP问题判断</h3><p>这部分不考，但既然学算法，应该了解一下这些NP难题</p><p>NP(Nondeterministic Polynomially，非确定性多项式)类问题是指一个复杂问题不能确定是否在多项式时间内找到答案，但是可以在多项式时间内验证答案是否正确。</p><p>P问题是一个判定问题类，这些问题可以用一个确定性算法在多项式时间内判定或解出。</p><p>NP问题是指可以在多项式时间内被非确定机解决的问题。通常它们的时间复杂度都是指数变量。</p><h2 id="2-递归与分治"><a href="#2-递归与分治" class="headerlink" title="2.递归与分治"></a>2.递归与分治</h2><h3 id="2-1-递归"><a href="#2-1-递归" class="headerlink" title="2.1 递归"></a>2.1 递归</h3><p><strong>递归定义</strong> 用函数自身定义的函数</p><p><strong>递归函数两个要素</strong> 边界条件与递归方程</p><p><strong>递归算法转化为非递归算法</strong></p><ol><li>直接转化法：直接用循环结构的算法替代递归算法，不需要使用栈</li><li>用栈模拟系统的运行过程，通过分析只保存必须保存的信息，从而用非递归算法替代递归算法，需要使用栈</li></ol><h4 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h4><p>对于数据n，最大加数不大于m的划分个数记作$q(n,m)$<br>$$<br>q(n,m) = \left{\begin{matrix}<br>1  &amp; n = 1,m = 1\<br> q(n,n) &amp;n&lt;m \<br> 1+q(n,n-1) &amp;n = m \<br> q(n,m-1)+q(n-m,m) &amp;n&gt;m&gt;1<br>\end{matrix}\right.<br>$$</p><h3 id="2-2-分治"><a href="#2-2-分治" class="headerlink" title="2.2 分治"></a>2.2 分治</h3><p>  <strong>分治法的设计思想是</strong>：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>  <strong>分治策略是</strong>：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p><strong>分治法所能解决的问题一般具有以下几个特征：</strong></p><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ol><p>算法模板</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Divide<span class="token operator">-</span>and<span class="token operator">-</span><span class="token function">Conquer</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token operator">|</span>P<span class="token operator">|</span>≤n0then <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token function">ADHOC</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">)</span>将P分解为较小的子问题 P1 <span class="token punctuation">,</span>P2 <span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>Pk<span class="token keyword">for</span> i←<span class="token number">1</span> to k<span class="token keyword">do</span> yi ← Divide<span class="token operator">-</span>and<span class="token operator">-</span><span class="token function">Conquer</span><span class="token punctuation">(</span>Pi<span class="token punctuation">)</span> <span class="token comment">//递归解决Pi</span>T ← <span class="token function">MERGE</span><span class="token punctuation">(</span>y1<span class="token punctuation">,</span>y2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>yk<span class="token punctuation">)</span> <span class="token comment">//合并子问题</span><span class="token keyword">return</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-二分搜索"><a href="#2-3-二分搜索" class="headerlink" title="2.3 二分搜索"></a>2.3 二分搜索</h3><p><strong>问题描述</strong> 给定已按升序排好序的n个元素a[1:n]，现要在这n个元素中找出一特定元素x</p><p>参考：<a href="https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">https://www.programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF</a></p><p>俩种思路。</p><h3 id="2-4-合并排序和快速排序"><a href="#2-4-合并排序和快速排序" class="headerlink" title="2.4 合并排序和快速排序"></a>2.4 合并排序和快速排序</h3><p><strong>问题描述</strong> 数组排序</p><h4 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>Merge<span class="token operator">-</span><span class="token function">sort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token function">Merge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度<br>$$<br>\begin{array}<br>  {X}<br>  T(n) = O(nlogn) =\left{\begin{matrix}<br>O(1)  &amp; n=1\<br>2T(\frac{n}{2} ) + O(n) &amp; n&gt;1 \<br>\end{matrix}\right.<br>\end{array}<br>$$</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span> <span class="token comment">//p、r为数组下标</span>x <span class="token operator">=</span> A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>   <span class="token comment">//将最后一个元素作为主元素</span>i <span class="token operator">=</span> p<span class="token operator">-</span><span class="token number">1</span> <span class="token comment">// i指向的是比主元素小的位置，</span><span class="token keyword">for</span>  j <span class="token operator">=</span> p  to  r<span class="token operator">-</span><span class="token number">1</span>     <span class="token comment">//从第一个元素开始到倒数第二个元素结束，比较确定主元素的位置</span><span class="token keyword">do</span>  <span class="token keyword">if</span>  A<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> xthen  i <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span>       <span class="token comment">//如果比主元素小，则把i=i+1的位置上的元素和j位置发现小元素互换</span>exchange A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token operator">-&gt;</span> A<span class="token punctuation">[</span>j<span class="token punctuation">]</span>exchange A<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token operator">-&gt;</span>A<span class="token punctuation">[</span>r<span class="token punctuation">]</span>   <span class="token comment">//最终确定主元的位置</span><span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span>   <span class="token comment">//返回主元的位置</span>End<span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token keyword">if</span> p<span class="token operator">&lt;</span>rq <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>r<span class="token punctuation">)</span>    <span class="token comment">//确定划分位置</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token comment">//子数组A[p...q-1]</span><span class="token function">QuickSort</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span>     <span class="token comment">//子数组A[q+1...r]</span>End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>步骤</strong></p><ol><li><p>分解：以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任意一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]，下标q在划分过程中确定</p></li><li><p>递归求解：通过递归调用快速排序算法分别对a[p:q-1]和a[q+1:r]进行排序</p></li><li><p>合并</p></li></ol><p>最坏情况，已经排好，$O(n^2)$<br>        最好情况，每次划分大小都是$\frac{n}{2}$，$O(nlogn)$</p><h3 id="2-5-大整数乘法"><a href="#2-5-大整数乘法" class="headerlink" title="2.5 大整数乘法"></a>2.5 大整数乘法</h3><p><strong>问题描述</strong> XY是n位二进制整数，计算他们的乘积XY<br>$$<br>\begin{array}<br>  {X}X=A2^{\frac{n}{2}}+B, Y=C2^{\frac{n}{2}}+D \<br>  XY = AC2^n+(AD+BC)2^{\frac{n}{2} }+BD  \<br>  =AC2^n+((A-B)(D-C)+AC+BD)2^{\frac{n}{2}}+BD \<br>\end{array}<br>$$<br>复杂度<br>$$<br>T(n) = O(n^{log3}) =\left{\begin{matrix}<br>O(1)  &amp; n=1\<br>3T(\frac{n}{2} ) + O(n) &amp; n&gt;1 \<br>\end{matrix}\right.<br>$$</p><h3 id="2-6-线性时间选择"><a href="#2-6-线性时间选择" class="headerlink" title="2.6 线性时间选择"></a>2.6 线性时间选择</h3><p>无序排列中求n个元素中第k小的元素（主要求中位数）。(类似快排)</p><p><strong>解释</strong></p><p>根据随机产生的基准点，将元素分为2组，基准点包含在第1组中；如果k&lt;=j，则第k小元素落在a段，为a段的第k小元素；如果k&gt;j，则a段的所有元素都比第k小元素还要小，第k小元素落在b段，为b段中的第k-j小元素（-j的含义是去掉a段的元素总个数）</p><p>最坏情况，分成两个1和n-1的子问题，$O(n^2)$</p><p>最好情况，每次都产生$\frac{n}{2}$大小的子问题，$O(n)$</p><p>例题看书比较好。</p><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h2><h3 id="3-1-动态规划原理"><a href="#3-1-动态规划原理" class="headerlink" title="3.1 动态规划原理"></a>3.1 动态规划原理</h3><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>这里俩性质：<strong>最优子结构性质</strong>和<strong>子问题重叠性质</strong></p><ol><li>最优子结构性质（分析问题是否满足最优性原理（用反证法）：①先假设由问题的最优解导出的子问题的解不是最优的；②再证明在这个假设下可构造出比原问题最优解更好的解，从而导致矛盾）</li><li>子问题重叠性质（子问题不相互独立，重复出现，只在第一次遇到时加以求解，并把答案保存起来，以后再遇到时不必重新求解）</li></ol><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">编程方法：动态规划的解题步骤对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！1、确定dp数组（dp table）以及下标的含义2、确定递推公式3、dp数组如何初始化4、确定遍历顺序5、举例推导dp数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>动态规划算法设计步骤</strong></p><ul><li><strong>分析最优解的性质，并刻划其结构特征；</strong> </li><li><strong>递归地定义最优值</strong></li><li><strong>以自底向上的方式计算出最优值；</strong></li><li><strong>根据计算最优值时得到的信息，构造最优解。</strong></li></ul><h3 id="3-2-矩阵连乘"><a href="#3-2-矩阵连乘" class="headerlink" title="3.2 矩阵连乘"></a>3.2 矩阵连乘</h3><p><strong>问题描述</strong> 每计算出一个元素，需要q次乘法，最终得到的矩阵是p×r矩阵，有p×r个元素，因此，计算C需要的乘法次数为q×p×r。每次要选择较小的q×p×r。给定n个矩阵｛A1,A2,…,An｝，其中Ai与Ai+1是可乘的，且i=1,2⋯,n-1,如何确定计算矩阵连乘积的计算次序，使得计算矩阵连乘的数乘次数最少。<br>$$<br>m[i][j]=\left{\begin{array}{cc}<br>0 &amp; i=j \<br>\min_{i\leq{k}&lt;j} {m[i][k]+m[k+1][j]+p_{i-1}p_kp_j} &amp; i&lt;j<br>\end{array}\right.<br>$$<br><strong>解释</strong> 矩阵连乘积从$A_i$到$A_j$定义为<code>A[i:j]</code>，<code>A[i:j]</code>最少的乘法次数定义为<code>m[i,j]</code>，最优断开位置k记为<code>𝑠[i,j]=k</code>，</p><p>$T(n)=O(n^3)$</p><blockquote><p><strong>例题</strong></p><p>计算矩阵连乘积A[1:6]的最少数乘次数，其中各矩阵的维数分别为p=[30,35,15,5,10,20,25]</p></blockquote><h3 id="3-3-最长公共子序列"><a href="#3-3-最长公共子序列" class="headerlink" title="3.3 最长公共子序列"></a>3.3 最长公共子序列</h3><p><strong>问题描述：</strong>给定两个序列$X={x_1,x_2,\cdots,x_m}$和$Y={y_1,y_2,\cdots,y_n}$，要求找出$X$和$Y$的一个最长公共子序列。<br>$$<br>c[i][j]=\left{\begin{array}{cc}<br>0 &amp; i=0, j=0 \<br>c[i-1][j-1]+1 &amp; i, j&gt;0 ; x_{i}=y_{j} \<br>\max {c[i-1][j], c[i][j-1]} &amp; i, j&gt;0 ; x_{i} \neq y_{j}<br>\end{array}\right.<br>$$</p><p>$$<br>b[i][j]=\left{\begin{array}{cc}<br>1 &amp; c[i][j] = c[i-1][j-1] \<br>2 &amp; c[i][j] = c[i-1][j] \<br>3 &amp; c[i][j] = c[i][j-1]<br>\end{array}\right.<br>$$</p><p><strong>解释</strong> <code>c[i,j]</code>记录序列$X_i$和$Y_j$的最长公共子序列长度，<code>b[i,j]</code>可以记录是哪种类型。在c表中从最右下角的那个元素开始，看b表中对应位置的值，如果为1，则在c表中从当前位置往左上角走；如果为2，则在c表中从当前位置往正上方走；如果为3，则在c表中从当前位置沿水平方向往后退一位；依次类推，直到c表中箭头退到<code>c[0，0]</code>为止。</p><p><strong>补充</strong> 两个序列的最长公共子序列不唯一，不影响最长公共子序列的长度；但是可能会产生不一样的公共子序列.</p><blockquote><p><strong>例题</strong></p><p>给定两个序列为X=ABCBDAB和Y=BDCABA，求最长公共子序列。</p></blockquote><h3 id="3-4-图像压缩"><a href="#3-4-图像压缩" class="headerlink" title="3.4 图像压缩"></a>3.4 图像压缩</h3><p><strong>问题描述</strong> 数字化图像是n×n的像素阵列。假定每个像素有一个0~255的灰度值，存储一个像素需8位。为了减少存储空间，采用变长模式，即不同像素用不同位数来存储。</p><ol><li>线性化：图片拉直，转换为$1×n^2$向量</li><li>分段：分成连续的m段，每段像素存储位数相同，每段最多含256个像素点</li><li>存放信息：第$i$段长度（8bit），第$i$段中像素存储位数（3bit）</li></ol><p>$$<br>\begin{matrix}<br>s[i]=\min\limits_{1 \leq k \leq \min {i,256}}{s[i-k]+k*bmax(i-k+1,i)  }+11<br>\bmax(i,j)=\max\limits_{i\leq k \leq j}{a[k]}<br>\end{matrix}<br>$$</p><p><strong>解释</strong></p><p>假设<code>s[i]</code>是序列${p_1,p_2,…,p_i}$的最优解，<code>a[i]</code>是第$i$个像素点的位数。</p><ol><li>假设$p_i$自成一段，则<code>s[i]=s[i-1]+保存pi的代价</code></li><li>取<code>s[i]</code>为min时对应的元素个数为k，<code>s[i]=s[i-k]+保存最后k个像素的代价</code></li><li>保存最后k个像素的代价=<code>k*max{k个灰度值二进制位数}+11</code></li></ol><blockquote><p><strong>例题</strong></p><p>求像素序列4，6，5，7，129，138，1的最优分段。</p></blockquote><h3 id="3-5-电路布线"><a href="#3-5-电路布线" class="headerlink" title="3.5 电路布线"></a>3.5 电路布线</h3><p><strong>问题描述</strong> 确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线且不相交<br>$$<br>\begin{matrix}<br>\scriptsize<br> 当i=1时, \qquad Size(i,j) = \left{\begin{matrix}<br>0 &amp;&amp; j&lt;\pi(1)<br>\1 &amp;&amp; j \geq \pi (1)<br>\end{matrix}\right. \<br>\scriptsize<br>当i&gt;1时,\qquad<br>Size(i,j) = \left{\begin{matrix}<br>Size(i-1,j) &amp;&amp; j&lt;\pi(i)<br>\\max { Size(i-1,j),Size(i-1,\pi(i)-1)+1} &amp;&amp; j \geq \pi (i)<br>\end{matrix}\right.<br>\end{matrix}<br>$$</p><p><strong>解释</strong> <code>MNS(i,j)</code>表示上面序号小于$i$，连接到下面的序号都小于$j$的不相交的集合，最后要求<code>MNS(n,n)</code>。如果$j=\pi(i)$，如果$(i,\pi(i))$不在MNS中，将i点删除没有影响，就是<code>size(i,j)=size(i-1,j)</code>，如果$(i,\pi(i))$在MNS中，就是<code>size(i,j)=size(i-1,pi(i)-1)+1</code></p><blockquote><p><strong>例题</strong></p><p>已知[(1 8)(2 7)(3 4)(4 2)(5 5)(6 1)(7 9)(8 3)(9 10)(10 6)]，求最大不相交情况</p></blockquote><h3 id="3-6-流水线调度"><a href="#3-6-流水线调度" class="headerlink" title="3.6 流水线调度"></a>3.6 流水线调度</h3><p><strong>问题描述</strong> n个作业要在两台机器M1和M2上进行加工。每个作业加工的顺序都是先在M1上加工，然后在M2加工。M1和M2加工作业$i$所需的时间分别为$a_i$ 和$b_i$。确定n个作业的最优加工顺序，使得加工完成所需的时间最少。</p><p><strong>算法</strong></p><ol><li>分为$N_1,N_2$集合存放 $$N_1 = {a_i\leq b_i} ,N_2 = {a_i &gt; b_i}$$</li><li>$N_1$中作业按照$a_i$升序排序，$N_2$中作业按照$b_i$降序排序</li><li>$N_1$连接$N_2$，计算时间</li></ol><blockquote><p><strong>例题</strong></p><table><thead><tr><th align="center">任务</th><th align="center">J1</th><th align="center">J2</th><th align="center">J3</th><th align="center">J4</th><th align="center">J5</th><th align="center">J6</th></tr></thead><tbody><tr><td align="center">工序1</td><td align="center">30</td><td align="center">120</td><td align="center">50</td><td align="center">20</td><td align="center">90</td><td align="center">110</td></tr><tr><td align="center">工序2</td><td align="center">80</td><td align="center">100</td><td align="center">90</td><td align="center">60</td><td align="center">30</td><td align="center">10</td></tr></tbody></table></blockquote><h3 id="3-7-0-1背包与完全背包"><a href="#3-7-0-1背包与完全背包" class="headerlink" title="3.7 0-1背包与完全背包"></a>3.7 0-1背包与完全背包</h3><p>$$<br>\begin{matrix}<br>m(i,j) = \left{\begin{matrix}<br>m(i-1,j) &amp;&amp; 0 \leq j&lt;w_i<br>\ \max { m(i-1,j),m(i-1,j-w_i)+v_i} &amp;&amp; j \geq w_i<br>\end{matrix}\right.<br>\<br>\<br>m(0,j) = \left{\begin{matrix}<br>0 &amp;&amp; 0 \leq j&lt;w_0<br>\ v_0 &amp;&amp; j \geq w_0<br>\end{matrix}\right.<br>\end{matrix}<br>$$</p><p><strong>解释</strong> <code>m[i][j]</code>表示可选择物品$i, i+1, …, n$时，背包容量为$j$装入的最大价值</p><blockquote><p><strong>例题</strong></p><p>n=5,c=10,W={2,2,6,5,4},V={6,3,5,4,6}</p></blockquote><h2 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4.贪心算法"></a>4.贪心算法</h2><blockquote><p>听老师说是活题，那么建议参考：<a href="https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</a></p><p>刷点力扣涨涨见识</p></blockquote><h3 id="4-1贪心原理"><a href="#4-1贪心原理" class="headerlink" title="4.1贪心原理"></a>4.1贪心原理</h3><p><strong>思想</strong> 在贪婪算法中采用逐步构造最优解的方法。在每个阶段，都作出一个看上去最优的决策。它并不一定对所有问题都成功，因为不从整体最优加以考虑，贪心解法可能不是全局最优解，但是对某些问题特别简单、有效。</p><p><strong>基本要素</strong></p><ol><li><strong>最优子结构性质</strong> 问题的最优解包含其子问题的最优解</li><li><strong>贪心选择性质</strong> 问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到，当前的选择和子问题的解无关，只和以往做出的选择有关</li></ol><p><strong>贪心算法一般分为如下四步：</strong></p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><h3 id="4-2-活动安排"><a href="#4-2-活动安排" class="headerlink" title="4.2 活动安排"></a>4.2 活动安排</h3><p>思考如下具有11个活动安排的问题？</p><p>在活动集合中选择最大的相容活动子集合</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>任务</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td></tr><tr><td>start</td><td>0</td><td>4</td><td>4</td><td>5</td><td>3</td><td>1</td><td>8</td><td>6</td><td>8</td><td>12</td><td>2</td></tr><tr><td>end</td><td>3</td><td>6</td><td>5</td><td>6</td><td>8</td><td>4</td><td>11</td><td>10</td><td>12</td><td>14</td><td>13</td></tr></tbody></table><pre class="line-numbers language-react" data-language="react"><code class="language-react">start开始时间，end结束时间，按任务按结束时间非减续排列优先选取结束时间早的，判断是否相容直到任务最后一个结束。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-哈夫曼编码"><a href="#4-3-哈夫曼编码" class="headerlink" title="4.3 哈夫曼编码"></a>4.3 哈夫曼编码</h3><p><strong>前缀码</strong> 对每一个字符规定一个0,1串作为其代码，并要求任一字符的代码都不是其它字符代码的前缀，这种编码称为前缀码。</p><p><strong>问题描述</strong> 找到使平均码长达到最小的前缀码编码方案</p><p><strong>策略</strong> 频率小的字符，深度大。队列Q以f(c)为键值存放二叉树各结点，通过贪心选择，将最小频率的两个二叉树合并，然后将新树（频率为上述两个二叉树频率之和）插入Q中。$ T(n)=O(nlogn)$</p><p><strong>证明贪心选择性质</strong></p><p>设x和y是字符集C中具有最小频率的两个字符，证明存在C的最优前缀码，使x和y具有最长、相同的码长且仅最后一位编码不同。设二叉树T表示C的任意一个最优前缀码方案。只要证明可以对T做适当修改后，得到一棵新的二叉树T’， 新树中，x和y是最深叶子且为兄弟。同时，新树也是C的最优前缀码方案。</p><p><strong>证明最优子结构性质</strong></p><p>设T表示C的一个最优前缀码方案。x和y是树T中的叶子节点且为兄弟。z是它们的父亲。若将z看做是具有频率$f(z)=f(x)+f(y)$的字符，则证明树$T’=T-{x,y}$表示字符集$C’=C-{x,y} \bigcup {z}$的一个最优前缀码即可。</p><blockquote><p>问题：</p><p>设在1000个字母的文章中各字母出现的频率为a:83, b:14, c:28, d:38, e:131, f:29, g:20, h:53，求最优编码。</p></blockquote><h3 id="4-3-最短路径"><a href="#4-3-最短路径" class="headerlink" title="4.3 最短路径"></a>4.3 最短路径</h3><p>书上的吧，懒的写了，这个看这个就行了</p><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111182050411.png" alt="image-20211118194505196"></p><h3 id="4-4-最小生成树"><a href="#4-4-最小生成树" class="headerlink" title="4.4 最小生成树"></a>4.4 最小生成树</h3><p>参考数据结构，这个太简单了</p><h3 id="4-5-0-1背包（可分割）"><a href="#4-5-0-1背包（可分割）" class="headerlink" title="4.5 0-1背包（可分割）"></a>4.5 0-1背包（可分割）</h3><p><strong>贪心策略</strong></p><ol><li>计算每种物品的单价（性价比）$\frac{v_i}{w_i}$</li><li>按物品单价从大到小排序</li><li>优先选取物品单价高的，直到背包装满。</li></ol><blockquote><p>$n=3,c=20,W={18,15,10},V={25,24,15}$</p></blockquote><p><strong>补充几种贪心策略</strong>（但是都不能保证得到最优解）</p><ol><li>选择可以装入背包的价值最大的物品</li><li>选择可装入背包的重量最小的物品</li><li>选择可装入背包的$\frac{v_i}{w_i}$最大的物品（一般用来做回溯法或者分支限界的限界函数）</li></ol><h3 id="3-6最优装载"><a href="#3-6最优装载" class="headerlink" title="3.6最优装载"></a>3.6最优装载</h3><p><strong>策略</strong> 重量最轻的先装$ T(n)=O(nlogn)$</p><p>策略：</p><ol><li>见货物重量按从小到大排序</li><li>优先选取重量下的物品，直到无法装下为主</li></ol><h2 id="5-回溯法"><a href="#5-回溯法" class="headerlink" title="5.回溯法"></a>5.回溯法</h2><h3 id="5-1-回溯原理"><a href="#5-1-回溯原理" class="headerlink" title="5.1 回溯原理"></a>5.1 回溯原理</h3><p>这里很矛盾，书上的回溯有一点点离谱，感觉是极端的剪枝，考试还得按课本来。</p><p><strong>算法框架</strong></p><ol><li><p>子集树算法框架<br>当所给的问题是从 个元素的集合 中找出 满足性质的子集时，相应的解空间树称为子集树</p></li><li><p>排列树算法框架<br>当所给问题是确定 个元素满足某种性质的排列时，相应的解空间树称为排列树</p></li></ol><p><strong>剪枝函数</strong></p><ol><li><p>用约束函数在扩展结点处剪去不满足约束的子树；</p></li><li><p>用限界函数剪去得不到最优解的子树</p></li></ol><p><strong>回溯法解决的问题都可以抽象为树形结构</strong>，所有回溯法的问题都可以抽象为树形结构！</p><p>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</p><p>递归就要有终止条件，所以必然是一颗高度有限的树（N叉树）。</p><h4 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h4><p>回溯法的性能如何呢，这里要和大家说清楚了，<strong>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法</strong>。</p><p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>        存放结果<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">{</span>        处理节点<span class="token punctuation">;</span>        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>        回溯，撤销处理结果    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-装载问题"><a href="#5-2-装载问题" class="headerlink" title="5.2 装载问题"></a>5.2 装载问题</h3><p><strong>问题描述</strong> n个集装箱要装到2艘载重量分别为c1,c2的货轮，其中集装箱 $i$的重量为$w_i$。要求找到装载方案将这n个货箱装上这2艘轮船</p><p><strong>解释</strong> 若装载问题有解, 采用如下策略可得一个最优装载方案：将第一艘轮船尽可能装满，将剩余的货箱装到第二艘轮船上。将第一艘船尽可能装满类似0-1背包问题</p><blockquote><p><strong>例题</strong></p><p>n=4,c1=12,W={8,6,2,3}</p></blockquote><h3 id="5-3-0-1背包"><a href="#5-3-0-1背包" class="headerlink" title="5.3 0-1背包"></a>5.3 0-1背包</h3><p><strong>解释</strong> 子集树。只要左儿子节点是一个可行结点，搜索就进入左子树（不超过背包重量）（约束剪枝）。在右子树中有可能包含最优解是才进入右子树搜索，否则将右子树剪去（利用单价贪心求解价值上限）（限界剪枝）。$cw$是背包当前重量，$M-cw$是背包剩余的空间，$cp$是当前总收益，$rp$是贪心算法剩余的物品收益，$bestw$记录当前最优价值，也就是判断$bp=cp+cp&gt;bestw$是右节点的限界函数。（此外，回溯法解0/1背包的前置条件是物品已按$\frac{p_i}{w_i}$非增次序排序）</p><blockquote><p><strong>例题</strong></p><p>M=110，w=(1,11,21,23,33,43,45,55)，v=(11,21,31,33,43,53,55,65)</p></blockquote><h2 id="6-分枝限定"><a href="#6-分枝限定" class="headerlink" title="6.分枝限定"></a>6.分枝限定</h2><h3 id="6-1-分支限定原理"><a href="#6-1-分支限定原理" class="headerlink" title="6.1 分支限定原理"></a>6.1 分支限定原理</h3><h3 id="6-2-装载问题"><a href="#6-2-装载问题" class="headerlink" title="6.2 装载问题"></a>6.2 装载问题</h3><h3 id="6-3-0-1背包"><a href="#6-3-0-1背包" class="headerlink" title="6.3 0-1背包"></a>6.3 0-1背包</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法实验</title>
      <link href="/2021/11/17/suan-fa-shi-yan/"/>
      <url>/2021/11/17/suan-fa-shi-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><blockquote><p>这其实是为了测试博客，内容随意了。。</p></blockquote><h2 id="问题-A-排列问题"><a href="#问题-A-排列问题" class="headerlink" title="问题 A: 排列问题"></a>问题 A: 排列问题</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>回溯法，这里采用回溯进行遍历枚举。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;string path;vector&lt;string&gt; result;vector&lt;int&gt; used;void backtrack(string str){if(path.size() == str.size()){result.push_back(path);return;}for(int i=0;i&lt;str.size();i++){if(used[i]){continue;}used[i] = 1;path.push_back(str[i]);backtrack(str);path.pop_back();used[i] = 0;}}int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());used.resize(str.size(),0);backtrack(str);for(auto s : result){cout &lt;&lt; s &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-B-快速幂"><a href="#问题-B-快速幂" class="headerlink" title="问题 B: 快速幂"></a>问题 B: 快速幂</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://gitee.com/lowlyLi/picgo/raw/master/img/202111172252507.png" alt="20180914130647_85638-16364329703111"></p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">332893414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这里是快速幂的技巧，采用化二进制判断迭代。</p><p>这里代码思路没问题，但得用long long类型</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 100000007;long long mypow(long long n,long long m){long long ans = 1;while(m){if(m &amp; 1){ans = ans * n % mod;}m = m &gt;&gt; 1;n = (n * n) % mod;}return ans;}int main(){int n;while(cin &gt;&gt; n){long long ans = 0;for(int i=1;i&lt;=n;i++){ans = (ans + mypow(i,i)) % mod;}cout &lt;&lt; ans+1 &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;int main(){string str;cin &gt;&gt; str;str.pop_back();sort(str.begin(),str.end());do{cout &lt;&lt; str &lt;&lt; " ";}while(next_permutation(str.begin(),str.end()));return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-C-求第k小"><a href="#问题-C-求第k小" class="headerlink" title="问题 C: 求第k小"></a>问题 C: 求第k小</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>输出一行，输出第k小数。</p><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">5 21 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><a href="https://blog.51cto.com/svenman/1851716">https://blog.51cto.com/svenman/1851716</a></p><p>qsort排序 <a href="https://blog.csdn.net/weixin_41096569/article/details/104771864">https://blog.csdn.net/weixin_41096569/article/details/104771864</a></p><p>不知道为什么c++算法的sort会超时，用c的就可以 过</p><p>这里有一点qsort使用配合数组，</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort (void* base, size_t num, size_t size,            int (*compar)(const void*,const void*));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="方法一-使用qsort"><a href="#方法一-使用qsort" class="headerlink" title="方法一 使用qsort"></a>方法一 使用qsort</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int compare (const void * a, const void * b){  return ( *(int*)a - *(int*)b );}int nums[1000011];int main(){int n,k;cin &gt;&gt; n &gt;&gt; k;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];}//sort(nums.begin(),nums.end());qsort(nums,n,sizeof(int),compare);cout &lt;&lt; nums[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二-手写sort"><a href="#方法二-手写sort" class="headerlink" title="方法二 手写sort"></a>方法二 手写sort</h4><p>这里输入cin会超时（离谱）就这一点点差距。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std; int a[1000001];   int partition(int a[],int p,int r){    int x=a[r];    int middle=p;    int j;    for(j=p;j&lt;r;j++)    {        if(a[j]&lt;x)        {            if(j!=middle)              swap(a[middle],a[j]);            middle++;        }     }    swap(a[middle],a[j]);    return middle;}   void select(int a[],int p,int r){    if(p&lt;r)    {        int q=partition(a,p,r);        select(a,p,q-1);        select(a,q+1,r);        }}   int main(){    int n,k;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)        scanf("%d",&amp;a[i]);    select(a,0,n-1);    cout&lt;&lt;a[k-1]&lt;&lt;endl;    return 0;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法三-发现数组sort能过"><a href="#方法三-发现数组sort能过" class="headerlink" title="方法三 发现数组sort能过"></a>方法三 发现数组sort能过</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int a[1000000];int main(){int n,k;cin&gt;&gt;n&gt;&gt;k;for(int i=0;i&lt;n;i++){cin &gt;&gt; a[i];}sort(a,a+n);cout &lt;&lt; a[k-1] &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-D-内部收益率"><a href="#问题-D-内部收益率" class="headerlink" title="问题 D: 内部收益率"></a>问题 D: 内部收益率</h2><p>时间限制: 1 Sec </p><p>内存限制: 128 MB</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="%E5%AE%9E%E9%AA%8C1.assets/20180914131556_63531.png" alt="img"></p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p><img src="%E5%AE%9E%E9%AA%8C1.assets/20180914131642_82198.png" alt="img"></p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">1-1 22-8 6 90<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">1.000.50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>二分搜索，模拟逼近</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;int main(){int n;while((cin &gt;&gt; n) &amp;&amp; n){vector&lt;int&gt; cf(n+1,0);for(int i=0;i&lt;= n;i++){cin &gt;&gt; cf[i];}double min, max, ans, mid;min = -1.0;        max = 1000000;        while(max - min &gt; 1e-6){ans = cf[0];            mid = (max-min) / 2 + min;            for(int i=1;i&lt;=n;i++){ans += cf[i] / pow(1 + mid, i);}            if(ans &gt; 0)            min = mid;            else            max = mid;}printf("%.2lf\n",mid);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题-E-跳台阶"><a href="#问题-E-跳台阶" class="headerlink" title="问题 E: 跳台阶"></a>问题 E: 跳台阶</h2><blockquote><p>时间限制: 1 Sec </p><p>内存限制: 128 MB </p></blockquote><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p><p>所得到的结果模1000000007</p><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h3><pre class="line-numbers language-none"><code class="language-none">34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h3><pre class="line-numbers language-none"><code class="language-none">35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>可以看成初等的动态规划</p><p>dp数组存储</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><h4 id="方法一-直接dp存储"><a href="#方法一-直接dp存储" class="headerlink" title="方法一 直接dp存储"></a>方法一 直接dp存储</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}vector&lt;long long&gt; dp(n+1,0);dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[i] = (dp[i-1] + dp[i-2]) % mod;}cout &lt;&lt; dp[n] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方法二-改进只需要维护3个dp就行了"><a href="#方法二-改进只需要维护3个dp就行了" class="headerlink" title="方法二 改进只需要维护3个dp就行了"></a>方法二 改进只需要维护3个dp就行了</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod = 1000000007;int main(){int n;while(cin &gt;&gt; n){if(n &lt;= 1){cout &lt;&lt; n &lt;&lt; endl;continue;}int dp[3];dp[0] = 1;dp[1] = 1;for(int i=2;i&lt;=n;i++){dp[2] = (dp[0] + dp[1]) % mod;dp[0] = dp[1];dp[1] = dp[2];}cout &lt;&lt; dp[2] &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    int flag=0;    long long x;    for(int i=1;i&lt;=n;i++)    {        scanf("%lld",&amp;x);        flag^=x;    }    if(flag)   printf("Yes\n");    else    printf("No\n");}return 0;</code></pre><p>}</p><pre class="line-numbers language-none"><code class="language-none"># 问题 L: sort2时间限制: 1 Sec内存限制: 64 MB## 题目描述给你n个整数，请按从大到小的顺序输出其中前m大的数。## 输入每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个都处于区间[-500000,500000]的整数，***整数可能会重复出现\***。## 输出对每组测试数据按从大到小的顺序输出前m大的数。## 样例输入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>10 5<br>1 2 3 4 5 6 7 7 8 9</p><pre class="line-numbers language-none"><code class="language-none">## 样例输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>9 8 7 7 6</p><pre class="line-numbers language-none"><code class="language-none">## 思路## 代码### 直接sort超时### map超时```c++#include &lt;bits/stdc++.h&gt;using namespace std;int nums[1000001];int main(){int n,m;cin &gt;&gt; n &gt;&gt; m;map&lt;int,int&gt; mp;for(int i=0;i&lt;n;i++){cin &gt;&gt; nums[i];if(mp.find(nums[i]) != mp.end()){mp[nums[i]]++;}mp.insert(pair&lt;int,int&gt;(nums[i],1));}int i = 0;for(auto num : mp){while(num.second){nums[i] = num.first;num.second--;i++;}}for(int i=n-1;i&gt;n-m-1;i--){cout &lt;&lt; nums[i] &lt;&lt; " ";}cout &lt;&lt; endl;return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int offset = 500000;int Hash[1000001] = {0};int main(){int m,n;while(cin &gt;&gt; n &gt;&gt; m){for(int i=0;i&lt;n;i++){int x;cin &gt;&gt; x;Hash[x+offset]++;}for(int i=offset;i&gt;=-offset &amp;&amp; m &gt; 0;i--){while(Hash[i+offset] &gt; 0 &amp;&amp; m &gt; 0){cout &lt;&lt; i &lt;&lt; " ";Hash[i+offset]--;m--;}}cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/15/hello-world/"/>
      <url>/2021/11/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="欢迎访问我的博客"><a href="#欢迎访问我的博客" class="headerlink" title="欢迎访问我的博客"></a>欢迎访问我的博客</h2><p>欢迎访问，这里预计不定期更新一些最近的思路和一些奇奇怪怪的想法，当然也包括日常emo，欢迎吐槽。</p>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
