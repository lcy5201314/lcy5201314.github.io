<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="CUMT算法实验, 秋月日常">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>CUMT算法实验 | 秋月日常</title>
    <link rel="icon" type="image/png" href="/meizi.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="秋月日常" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/qiuyue.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">秋月日常</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/qiuyue.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">秋月日常</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/lcy5201314/lcy5201314.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/lcy5201314/lcy5201314.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">CUMT算法实验</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AE%97%E6%B3%95/">
                                <span class="chip bg-color">算法</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                算法
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-17
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-12-09
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16k
                </div>
                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>作者： lowly</p>
<p>仅供学习交流</p>
</blockquote>
<h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h1 id="问题-A-排列问题"><a href="#问题-A-排列问题" class="headerlink" title="问题 A: 排列问题"></a>问题 A: 排列问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>回溯法，这里采用回溯进行遍历枚举。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

string path;
vector&lt;string&gt; result;
vector&lt;int&gt; used;

void backtrack(string str){
	if(path.size() == str.size()){
		result.push_back(path);
		return;
	}
	for(int i=0;i&lt;str.size();i++){
		if(used[i]){
			continue;
		}
		used[i] = 1;
		path.push_back(str[i]);
		backtrack(str);
		path.pop_back();
		used[i] = 0;
	}
}

int main(){
	string str;
	cin &gt;&gt; str;
	str.pop_back();
	sort(str.begin(),str.end());
	used.resize(str.size(),0);
	backtrack(str);
	for(auto s : result){
		cout &lt;&lt; s &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-B-快速幂"><a href="#问题-B-快速幂" class="headerlink" title="问题 B: 快速幂"></a>问题 B: 快速幂</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s2.loli.net/2021/12/09/1JwR9CvtIPZaGhK.jpg" alt="20180914130647_85638-16364329703111"></p>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
4
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">33
289
3414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这里是快速幂的技巧，采用化二进制判断迭代。</p>
<p>这里代码思路没问题，但得用long long类型</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

const long long mod = 100000007;

long long mypow(long long n,long long m){
	long long ans = 1;
	while(m){
		if(m &amp; 1){
			ans = ans * n % mod;
		}
		m = m &gt;&gt; 1;
		n = (n * n) % mod;
	}
	return ans;
}


int main(){
	int n;
	while(cin &gt;&gt; n){
		long long ans = 0;
		for(int i=1;i&lt;=n;i++){
			ans = (ans + mypow(i,i)) % mod;
		}
		cout &lt;&lt; ans+1 &lt;&lt; endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	string str;
	cin &gt;&gt; str;
	str.pop_back();
	sort(str.begin(),str.end());
	do{
		cout &lt;&lt; str &lt;&lt; " ";
	}while(next_permutation(str.begin(),str.end()));
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-C-求第k小"><a href="#问题-C-求第k小" class="headerlink" title="问题 C: 求第k小"></a>问题 C: 求第k小</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h2 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p>
<h2 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 2
1 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/svenman/1851716">https://blog.51cto.com/svenman/1851716</a></p>
<p>qsort排序 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41096569/article/details/104771864">https://blog.csdn.net/weixin_41096569/article/details/104771864</a></p>
<p>不知道为什么c++算法的sort会超时，用c的就可以 过</p>
<p>这里有一点qsort使用配合数组，</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort (void* base, size_t num, size_t size,
            int (*compar)(const void*,const void*));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-使用qsort"><a href="#方法一-使用qsort" class="headerlink" title="方法一 使用qsort"></a>方法一 使用qsort</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int compare (const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}
int nums[1000011];
int main(){
	int n,k;
	cin &gt;&gt; n &gt;&gt; k;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	//sort(nums.begin(),nums.end());
	qsort(nums,n,sizeof(int),compare);
	cout &lt;&lt; nums[k-1] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="方法二-手写sort"><a href="#方法二-手写sort" class="headerlink" title="方法二 手写sort"></a>方法二 手写sort</h3><p>这里输入cin会超时（离谱）就这一点点差距。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int a[1000001];
   
int partition(int a[],int p,int r)
{
    int x=a[r];
    int middle=p;
    int j;
    for(j=p;j&lt;r;j++)
    {
        if(a[j]&lt;x)
        {
            if(j!=middle)
              swap(a[middle],a[j]);
            middle++;
        } 
    }
    swap(a[middle],a[j]);
    return middle;
}
   
void select(int a[],int p,int r)
{
    if(p&lt;r)
    {
        int q=partition(a,p,r);
        select(a,p,q-1);
        select(a,q+1,r);    
    }
}
   
int main()
{
    int n,k;
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=0;i&lt;n;i++)
        scanf("%d",&amp;a[i]);
    select(a,0,n-1);
    cout&lt;&lt;a[k-1]&lt;&lt;endl;
    return 0;   
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="方法三-发现数组sort能过"><a href="#方法三-发现数组sort能过" class="headerlink" title="方法三 发现数组sort能过"></a>方法三 发现数组sort能过</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int a[1000000];

int main(){
	int n,k;
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
	}
	sort(a,a+n);
	cout &lt;&lt; a[k-1] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-D-内部收益率"><a href="#问题-D-内部收益率" class="headerlink" title="问题 D: 内部收益率"></a>问题 D: 内部收益率</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s2.loli.net/2021/12/09/1y6omwJNc32jPTg.jpg" alt="20180914131556_63531"></p>
<h2 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h2><p><img src="https://s2.loli.net/2021/12/09/npyQKqVgtLfka7N.jpg" alt="20180914131642_82198"></p>
<h2 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h2><p>对于每组数据，输出仅一行，即项目的IRR，四舍五入保留小数点后两位。</p>
<h2 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">1
-1 2
2
-8 6 9
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">1.00
0.50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>二分搜索，模拟逼近</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	while((cin &gt;&gt; n) &amp;&amp; n){
		vector&lt;int&gt; cf(n+1,0);
		for(int i=0;i&lt;= n;i++){
			cin &gt;&gt; cf[i];
		}
		double min, max, ans, mid;
		min = -1.0;
        max = 1000000;
        while(max - min &gt; 1e-6){
			ans = cf[0];
            mid = (max-min) / 2 + min;
            for(int i=1;i&lt;=n;i++){
				ans += cf[i] / pow(1 + mid, i);
			}
            if(ans &gt; 0)
            	min = mid;
            else
            	max = mid;
		}
		printf("%.2lf\n",mid);
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-E-跳台阶"><a href="#问题-E-跳台阶" class="headerlink" title="问题 E: 跳台阶"></a>问题 E: 跳台阶</h1><blockquote>
<p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB </p>
</blockquote>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例。每组测试样例包含一个整数n。(1&lt;=n&lt;=100)</p>
<h2 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h2><p>每组测试样例输出一行，表示青蛙跳上n级台阶的跳法数量.</p>
<p>所得到的结果模1000000007</p>
<h2 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>可以看成初等的动态规划</p>
<p>dp数组存储</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-直接dp存储"><a href="#方法一-直接dp存储" class="headerlink" title="方法一 直接dp存储"></a>方法一 直接dp存储</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long mod = 1000000007;
int main(){
	int n;
	while(cin &gt;&gt; n){
		if(n &lt;= 1){
			cout &lt;&lt; n &lt;&lt; endl;
			continue;
		}
		vector&lt;long long&gt; dp(n+1,0);
		dp[0] = 1;
		dp[1] = 1;
		for(int i=2;i&lt;=n;i++){
			dp[i] = (dp[i-1] + dp[i-2]) % mod;
		}
		cout &lt;&lt; dp[n] &lt;&lt; endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="方法二-改进只需要维护3个dp就行了"><a href="#方法二-改进只需要维护3个dp就行了" class="headerlink" title="方法二 改进只需要维护3个dp就行了"></a>方法二 改进只需要维护3个dp就行了</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const long long mod = 1000000007;

int main(){
	int n;
	while(cin &gt;&gt; n){
		if(n &lt;= 1){
			cout &lt;&lt; n &lt;&lt; endl;
			continue;
		}
		int dp[3];
		dp[0] = 1;
		dp[1] = 1;
		for(int i=2;i&lt;=n;i++){
			dp[2] = (dp[0] + dp[1]) % mod;
			dp[0] = dp[1];
			dp[1] = dp[2];
		}
		cout &lt;&lt; dp[2] &lt;&lt; endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h1 id="问题-A-沙子的质量"><a href="#问题-A-沙子的质量" class="headerlink" title="问题 A: 沙子的质量"></a>问题 A: 沙子的质量</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h2 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h2 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p>
<h2 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4
1 3 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里和矩阵连乘差不多</p>
<p>这里cost（）也就是合并有<code>sum[j]-sum[i]</code>给出</p>
<p>这里外层遍历是长度，合并的长度</p>
<p>然后计算出i，j也就是合并区间</p>
<p>k是中间循环查找min</p>
<p>这里记得一个是sum初始化，一个是dp <code>i==j</code>时<code>dp=0</code>初始化<code>dp[i][j] = INT_MAX</code></p>
<p>参考</p>
<p><img src="https://s2.loli.net/2021/12/09/xJLWMnc2kqmHg1p.png" alt="image-20211107221323477"></p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	vector&lt;int&gt; sum(n+1,0);
	vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,0));
	//先输入数组
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	//初始化sum，方便求i,j之间的代价
	for(int i=0;i&lt;n;i++){
		sum[i+1] = sum[i] + nums[i];
	}
	//这是是遍历长度，2开始，1为0；
	for(int len = 2;len&lt;=n;len++){
		//这里初始化i，j,这里要右端点小于n，防止越界，斜方向遍历
		for(int i=0;i+len-1 &lt; n;i++){
			int j = i+len-1;
			dp[i][j] = INT_MAX;
			for(int k=i;k&lt;j;k++){
				dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]);
			}
		}
	}
	cout &lt;&lt; dp[0][n-1] &lt;&lt;endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-B-最长公共子序列"><a href="#问题-B-最长公共子序列" class="headerlink" title="问题 B: 最长公共子序列"></a>问题 B: 最长公共子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p>
<h2 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h2 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p>
<h2 id="样例输入-6"><a href="#样例输入-6" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abccd aecd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出-6"><a href="#样例输出-6" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	string str1,str2;
	cin &gt;&gt; str1 &gt;&gt; str2;
	int m = str1.size();
	int n = str2.size();
	vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));
	for(int i=1;i&lt;=m;i++){
		for(int j=1;j&lt;=n;j++){
			if(str1[i-1] == str2[j-1]){
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else{
				dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
			}
		}
	}
	cout &lt;&lt; dp[m][n] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-C-三角形的路径权"><a href="#问题-C-三角形的路径权" class="headerlink" title="问题 C: 三角形的路径权"></a>问题 C: 三角形的路径权</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>如输入样例所示出了一个数字三角形。请编一个程序计算从顶至底的某处的一条路径，使该路径所经过的数字的总和最大。每一步可沿左斜线向下或右斜线向下走；1&lt; 三角形行数&lt; 25；三角形中的数字为整数&lt; 1000；</p>
<h2 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h2><p>输入第一行为N，表示有N行 后面N行表示三角形每条路的路径权。</p>
<h2 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h2><p>输出路径所经过的数字的总和最大的答案。</p>
<h2 id="样例输入-7"><a href="#样例输入-7" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-7"><a href="#样例输出-7" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">30<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>逆向，自底向上</p>
<p>i == N 时 <code>dp[i][j] = mp[i][j]</code></p>
<p>其他 ：<code>dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+mp[i][j]</code></p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;int&gt;&gt; mp(n,vector&lt;int&gt;(n,-1));
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;=i;j++){
			cin &gt;&gt; mp[i][j];
		}
	}
	vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(n+1,0));
	for(int i=n-1;i&gt;=0;i--){
		for(int j=0;j&lt;=i;j++){
			if(i == n-1){
				dp[i][j] = mp[i][j];
			}
			else{
				dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+mp[i][j];
			}
		}
	}
	cout &lt;&lt; dp[0][0] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-D-跳跃游戏二"><a href="#问题-D-跳跃游戏二" class="headerlink" title="问题 D: 跳跃游戏二"></a>问题 D: 跳跃游戏二</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组，假定你的初始位置为数组第一个下标。数组中的每个元素代表你在那个位置能够跳跃的最大长度。你的目标是到达最后一个下标，并且使用最少的跳跃次数。例如：A = [2,3,1,1,4]，到达最后一个下标的最少跳跃次数为 2。（先跳跃11步，从下标0到1，然后跳跃3步，到达最后一个下标。一共两次）</p>
<h2 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个正整数n(1≤n≤100)，接下来的一行，输入n个整数，表示数组A。</p>
<h2 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h2><p>最后输出最少的跳跃次数。</p>
<h2 id="样例输入-8"><a href="#样例输入-8" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5
3 1 1 1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-8"><a href="#样例输出-8" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这里可以拿dp动态规划</p>
<p>但我选择更简单的贪心算法，求最大覆盖范围</p>
<p>看几次就可以覆盖终点</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-贪心算法"><a href="#方法一-贪心算法" class="headerlink" title="方法一 贪心算法"></a>方法一 贪心算法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	int curDistance = 0;    // 当前覆盖的最远距离下标
	int ans = 0;            // 记录走的最大步数
	int nextDistance = 0;   // 下一步覆盖的最远距离下标
	for(int i=0;i&lt;n-1;i++){
		nextDistance = max(nums[i]+i,nextDistance);
		if(i == curDistance){
			curDistance = nextDistance;
			ans++;
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-E-字母排序"><a href="#问题-E-字母排序" class="headerlink" title="问题 E: 字母排序"></a>问题 E: 字母排序</h1><p>时间限制: 1 Sec</p>
<p> 内存限制: 128 MB</p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>XXXX年突然有外星人造访，但大家语言不通，不过科学家们经过研究发现外星人用26个英文字母组成的单词中最长不降子序列的长度来表述数字，且英文字母的排列顺序不同，现给出其排列顺序，再给出外星人说的每个数字（其实是每个英文单词，用空格隔开），翻译出外星人所说的数字（连续输出，最后加回车）。(因为是最长不降子序列，所以数字中没有0，也就是说外星人的数字是大于0的数字)。例如，我们正常的字母排列顺序是abcdefg…….xyz，代表a&lt; b&lt; c&lt; …..&lt; x&lt; y&lt; z abcd efg hhh ihg四个字符串的最长不降子序列的长度分别为4 3 3 1。</p>
<h2 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h2><p>第1，2行为字符串 含义如题描述。1≤第二行长度≤255。</p>
<h2 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h2><p>输出答案，含义如题描述</p>
<h2 id="样例输入-9"><a href="#样例输入-9" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abcdefghijklmnopqrstuvwxyz
abcd efg hhh ihg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-9"><a href="#样例输出-9" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4331<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	string str;
	cin &gt;&gt; str;
    //这里map映射，因为是26的字母不分大小写，如果混合使用，统一转成小写就好了，map用红黑树，unordered_map应用哈希
	unordered_map&lt;char,int&gt; map;
	for(int i=0;i&lt;str.size();i++){
		map[str[i]] = i;
	}
	while(cin &gt;&gt; str){
		//里面就是最简单最大子序列
		//这里初始化为1
		vector&lt;int&gt; dp(str.size(),1);
		int ans = 0;
		for(int i=0;i&lt;str.size();i++){
			for(int j=0;j&lt;i;j++){
				if(map[str[i]] &gt;= map[str[j]]){
					dp[i] = max(dp[i],dp[j]+1);
				}
				if(ans &lt; dp[i]){
					ans = dp[i];
				}
			}
		}
		cout &lt;&lt; ans;
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h1 id="问题-A-Homework"><a href="#问题-A-Homework" class="headerlink" title="问题 A: Homework"></a>问题 A: Homework</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p>
<p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p>
<p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p>
<p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p>
<h2 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h2><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p>
<h2 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h2><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p>
<p>提示：float 的精度可能不够，你应该使用 double 类型。</p>
<h2 id="样例输入-10"><a href="#样例输入-10" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 20
4 10
5 22
10 3
1 2
0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-10"><a href="#样例输出-10" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">37.00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>贪心算法，寻找性价比最高的</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool cmp(vector&lt;double&gt;a,vector&lt;double&gt; b){
	return a[2] &gt; b[2];
}

int main(){
	int m,n;
	while(cin &gt;&gt; m &gt;&gt; n){
		if(m == 0 &amp;&amp; n ==0){
			break;
		}
		vector&lt;vector&lt;double&gt;&gt; homework(m,vector&lt;double&gt;(3,0));
		for(int i=0;i&lt;m;i++){
			cin &gt;&gt; homework[i][0] &gt;&gt; homework[i][1];
			homework[i][2] = homework[i][1] / homework[i][0];
		}
		sort(homework.begin(),homework.end(),cmp);
		double ans = 0; 
		for(int i=0;i&lt;n;i++){
			if(n &gt; homework[i][0]){
				ans += homework[i][1];
				n -= homework[i][0];
			}
			else{
				ans += homework[i][2] * n;
				break;
			}
		}
		printf("%.2lf\n",ans);
		
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-B-区间包含问题"><a href="#问题-B-区间包含问题" class="headerlink" title="问题 B: 区间包含问题"></a>问题 B: 区间包含问题</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p>
<h2 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据，对于每组测试数据：</p>
<p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p>
<p>接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。</p>
<p>接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。</p>
<h2 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p>
<p>数据过大请使用快速输入输出。</p>
<h2 id="样例输入-11"><a href="#样例输入-11" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 3
1 3
2 4
1 4
1 2
1 2
1 3
1 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-11"><a href="#样例输出-11" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">1
1
2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>就是右端点小排序</p>
<p>优先选取满足小区间</p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	return a[1] &lt; b[1];
}

int main(){
	int n, m;
	while(cin &gt;&gt; n &gt;&gt; m){
		vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));
		for(int i=0;i&lt;n;i++){
			cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];
		}
		sort(point.begin(),point.end(),cmp);
		while(m--){
			int left,right;
			cin &gt;&gt; left &gt;&gt; right;
			int ans = 0;
			for(int i=0;i&lt;n;i++){
				if(point[i][1] &gt; right){
					break;
				}
				if(left &lt;= point[i][0]){
					left = point[i][1];
					ans++;
				}
			}
			cout &lt;&lt; ans &lt;&lt; endl;
		}
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-C-最长子序列"><a href="#问题-C-最长子序列" class="headerlink" title="问题 C: 最长子序列"></a>问题 C: 最长子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p>
<h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p>
<p>例如：</p>
<p>数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p>
<h2 id="输入-12"><a href="#输入-12" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个不超过1000的整数n。</p>
<p>第二行输入n个整数A[i]。</p>
<h2 id="输出-12"><a href="#输出-12" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，表示最大的和。</p>
<h2 id="样例输入-12"><a href="#样例输入-12" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
1 1 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-12"><a href="#样例输出-12" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	int sum = 0;
	int ans = INT_MIN;
	for(int i=0;i&lt;n;i++){
		sum += nums[i];
		if(sum &gt; ans){
			ans = sum;
		}
		if(sum &lt; 0){
			sum = 0;
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-D-三值排序"><a href="#问题-D-三值排序" class="headerlink" title="问题 D: 三值排序"></a>问题 D: 三值排序</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>排序是一种很频繁的计算任务。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种1，2和3。我们用交换的方法把他排成升序的。</p>
<p>写一个程序计算出，计算出的一个包括1、2、3三种值的数字序列，排成升序所需的最少交换次数。</p>
<h2 id="输入-13"><a href="#输入-13" class="headerlink" title="输入"></a>输入</h2><p>输入第1行为类别的数量N（1≤N≤1000）</p>
<p>输入第2行到第N+1行，每行包括一个数字（1或2或3）。</p>
<h2 id="输出-13"><a href="#输出-13" class="headerlink" title="输出"></a>输出</h2><p>输出包含一行，为排成升序所需的最少交换次数。</p>
<h2 id="样例输入-13"><a href="#样例输入-13" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">9
2
2
1
3
3
3
2
3
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-13"><a href="#样例输出-13" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>交换次序的，</p>
<p>这个不太懂，背吧</p>
<h2 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	int sum[4] = {0,0,0,0};
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
		sum[nums[i]]++;
	}
	int x = 0,y = 0,z=0;
	for(int i=0;i&lt;sum[1];i++){
		if(nums[i] != 1){
			x++;
		}
	}
	for(int i=sum[1];i&lt;sum[1]+sum[2];i++){
		if(nums[i] == 3){
			y++;
		}
	}
	for(int i=sum[1]+sum[2];i&lt;n;i++){
		if(nums[i] == 2){
			z++;
		}
	}
	cout &lt;&lt; x + max(y,z) &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-E-法师康的工人"><a href="#问题-E-法师康的工人" class="headerlink" title="问题 E: 法师康的工人"></a>问题 E: 法师康的工人</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。</p>
<p>你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。</p>
<p>·最长的至少有一个工人在工作的时间段</p>
<p>·最长的无人工作的时间段（从有人工作开始计）</p>
<h2 id="输入-14"><a href="#输入-14" class="headerlink" title="输入"></a>输入</h2><p>输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。</p>
<h2 id="输出-14"><a href="#输出-14" class="headerlink" title="输出"></a>输出</h2><p>输出为一行，用空格分隔开两个我们所求的数。</p>
<h2 id="样例输入-14"><a href="#样例输入-14" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
200 1000
700 1100
1500 2100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-14"><a href="#样例输出-14" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">900 400<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	if(a[0] == b[0])
		return a[1] &lt; b[1];
	return a[0] &lt; b[0];
}

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];
	}
	sort(point.begin(),point.end(),cmp);
	int maxx = 0;
	int minn = 0;
	int start,end;
	start = point[0][0];
	end = point[0][1];
	for(int i=1;i&lt;n;i++){
		if(point[i][0] &lt;= end){
			end =max(point[i][1],end);
			maxx = max(maxx,end - start);
		}
		else{
			start = point[i][0];
			minn = max(minn,start - end);
			end = point[i][1];
		}
	}
	cout &lt;&lt; maxx &lt;&lt; " " &lt;&lt; minn &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h1><h1 id="问题-A-进制转换"><a href="#问题-A-进制转换" class="headerlink" title="问题 A: 进制转换"></a>问题 A: 进制转换</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个十进制正整数，然后输出它所对应的八进制数。</p>
<h2 id="输入-15"><a href="#输入-15" class="headerlink" title="输入"></a>输入</h2><p>输入一个十进制正整数n(1≤n≤10<em>6</em>) 。</p>
<h2 id="输出-15"><a href="#输出-15" class="headerlink" title="输出"></a>输出</h2><p>输出n对应的八进制数，输出在一行。</p>
<h2 id="样例输入-15"><a href="#样例输入-15" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出-15"><a href="#样例输出-15" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一-c语言-o强转"><a href="#方法一-c语言-o强转" class="headerlink" title="方法一 c语言%o强转"></a>方法一 c语言%o强转</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	printf("%o\n",n);
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="方法二-存储"><a href="#方法二-存储" class="headerlink" title="方法二 %/存储"></a>方法二 %/存储</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; num;
	while(n){
		num.push_back(n%8);
		n /= 8;
	}
	for(int i=num.size()-1;i&gt;=0;i--){
		cout &lt;&lt; num[i];
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-B-排列问题"><a href="#问题-B-排列问题" class="headerlink" title="问题 B: 排列问题"></a>问题 B: 排列问题</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>  输入一个可能含有重复字符的字符串，打印出该字符串中所有字符的全排列。</p>
<h2 id="输入-16"><a href="#输入-16" class="headerlink" title="输入"></a>输入</h2><p>单组测试数据，输入数据是一个长度不超过10个字符的字符串，以逗号结尾。</p>
<h2 id="输出-16"><a href="#输出-16" class="headerlink" title="输出"></a>输出</h2><p>打印出该字符串中所有字符的全排列。以字典序顺序输出，用空格分隔。</p>
<h2 id="样例输入-16"><a href="#样例输入-16" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abc,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出-16"><a href="#样例输出-16" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">abc acb bac bca cab cba<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

string path;
vector&lt;string&gt; result;
vector&lt;int&gt; used;

void backtrack(string str){
	if(path.size() == str.size()){
		result.push_back(path);
		return;
	}
	for(int i=0;i&lt;str.size();i++){
		if(used[i]){
			continue;
		}
		used[i] = 1;
		path.push_back(str[i]);
		backtrack(str);
		path.pop_back();
		used[i] = 0;
	}
}

int main(){
	string str;
	cin &gt;&gt; str;
	str.pop_back();
	sort(str.begin(),str.end());
	used.resize(str.size(),0);
	backtrack(str);
	for(auto s : result){
		cout &lt;&lt; s &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-C-快速幂"><a href="#问题-C-快速幂" class="headerlink" title="问题 C: 快速幂"></a>问题 C: 快速幂</h1><p>时间限制: 1 Sec</p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="%E7%BB%BC%E5%90%88%E7%89%88.assets/20180914130647_85638-16364329703111.png" alt="img"></p>
<h2 id="输入-17"><a href="#输入-17" class="headerlink" title="输入"></a>输入</h2><p>多组测试样例，最多50组。每组测试样例给定一个整数x(1&lt;=x&lt;=25000)</p>
<h2 id="输出-17"><a href="#输出-17" class="headerlink" title="输出"></a>输出</h2><p>对每个样例，输出一行，代表f(x)对100000007取余的结果。</p>
<h2 id="样例输入-17"><a href="#样例输入-17" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
4
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-17"><a href="#样例输出-17" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">33
289
3414<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

const long long mod = 100000007;

long long mypow(long long x,long long m){
	long long ans = 1;
	while(m){
		if(m &amp; 1){
			ans = (ans * x) % mod;
		}
		m &gt;&gt;= 1;
		x = (x * x) %mod;
	}
	return ans;
}

int main(){
	int n;
	while(cin &gt;&gt; n){
		long long ans = 1;
		for(int i=1;i&lt;=n;i++){
			ans =(ans + mypow(i,i)) % mod;
		}
		cout &lt;&lt; ans &lt;&lt;endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-D-求第k小"><a href="#问题-D-求第k小" class="headerlink" title="问题 D: 求第k小"></a>问题 D: 求第k小</h1><p>时间限制: 1 Sec</p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定n(1&lt;=n&lt;=1000000)个元素，求第k小数(1&lt;=k&lt;=n)。</p>
<h2 id="输入-18"><a href="#输入-18" class="headerlink" title="输入"></a>输入</h2><p>一组样例。第一行输入两个整数n和k。第二行输入n个不同的int范围内的数。</p>
<h2 id="输出-18"><a href="#输出-18" class="headerlink" title="输出"></a>输出</h2><p>输出一行，输出第k小数。</p>
<h2 id="样例输入-18"><a href="#样例输入-18" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 2
1 5 3 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-18"><a href="#样例输出-18" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int nums[1000002];

int main(){
	int n,k;
	cin &gt;&gt; n &gt;&gt; k;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	sort(nums,nums+n);
	cout &lt;&lt; nums[k-1] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-E-沙子的质量"><a href="#问题-E-沙子的质量" class="headerlink" title="问题 E: 沙子的质量"></a>问题 E: 沙子的质量</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有N堆沙子排成一排，其编号为1，2，3，…，N（N&lt; =300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为1 3 5 2我们可以先合并1、2堆，代价为4，得到4 5 2又合并1，2堆，代价为9，得到9 2，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。</p>
<h2 id="输入-19"><a href="#输入-19" class="headerlink" title="输入"></a>输入</h2><p>第一行一个数N表示沙子的堆数N。 第二行N个数，表示每堆沙子的质量。 a[i]&lt; =1000。</p>
<h2 id="输出-19"><a href="#输出-19" class="headerlink" title="输出"></a>输出</h2><p>合并的最小代价。</p>
<h2 id="样例输入-19"><a href="#样例输入-19" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4
1 3 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-19"><a href="#样例输出-19" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">22<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	vector&lt;int&gt; sum(n+1,0);
	for(int i=0;i&lt;n;i++){
		sum[i+1] = sum[i] + nums[i]; 
	}
	vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(n,INT_MAX));
	for(int i=0;i&lt;n;i++){
		dp[i][i] = 0;
	}
	for(int len=2;len&lt;=n;len++){
		for(int i=0;i + len -1 &lt; n;i++){
			int j = i + len -1;
			for(int k=i;k&lt;j;k++){
				dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j] + sum[j+1]-sum[i]);
			}
		}
	}
	cout &lt;&lt; dp[0][n-1] &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-F-最长公共子序列"><a href="#问题-F-最长公共子序列" class="headerlink" title="问题 F: 最长公共子序列"></a>问题 F: 最长公共子序列</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个字符串A的子串被定义成从A中顺次选出若干个字符构成的串。如A=“cdaad” ,顺次选1，3，5个字符就构成子串” cad” ,现给定两个字符串，求它们的最长共公子串。</p>
<h2 id="输入-20"><a href="#输入-20" class="headerlink" title="输入"></a>输入</h2><p>第一行两个字符串用空格分开。两个串的长度均小于2000 。</p>
<h2 id="输出-20"><a href="#输出-20" class="headerlink" title="输出"></a>输出</h2><p>最长子串的长度。</p>
<h2 id="样例输入-20"><a href="#样例输入-20" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">abccd aecd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出-20"><a href="#样例输出-20" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	string str1,str2;
	cin &gt;&gt; str1 &gt;&gt; str2;
	int m = str1.size();
	int n = str2.size();
	vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0));
	for(int i=1;i&lt;=m;i++){
		for(int j=1;j&lt;=n;j++){
			if(str1[i-1] == str2[j-1]){
				dp[i][j] = dp[i-1][j-1] + 1;
			}
			else{
				dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
			}
		}
	}
	cout &lt;&lt; dp[m][n] &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-G-sort"><a href="#问题-G-sort" class="headerlink" title="问题 G: sort"></a>问题 G: sort</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 64 MB</p>
<h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你n个整数，请按从大到小的顺序输出其中前m大的数。</p>
<h2 id="输入-21"><a href="#输入-21" class="headerlink" title="输入"></a>输入</h2><p>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</p>
<h2 id="输出-21"><a href="#输出-21" class="headerlink" title="输出"></a>输出</h2><p>对每组测试数据按从大到小的顺序输出前m大的数。</p>
<h2 id="样例输入-21"><a href="#样例输入-21" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 3
3 -35 92 213 -644<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-21"><a href="#样例输出-21" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">213 92 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int nums[1000001];

bool cmp(int a,int b){
	return a &gt; b;
}

int main(){
	int n,m;
	cin &gt;&gt; n &gt;&gt; m;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	sort(nums,nums+n,cmp);
	for(int i=0;i&lt;m;i++){
		cout &lt;&lt; nums[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-H-Joseph"><a href="#问题-H-Joseph" class="headerlink" title="问题 H: Joseph"></a>问题 H: Joseph</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 32 MB</p>
<h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>The Joseph’s problem is notoriously known. For those who are not familiar with the original problem: from among n people, numbered 1, 2, . . ., n, standing in circle every mth is going to be executed and only the life of the last remaining person will be saved. Joseph was smart enough to choose the position of the last remaining person, thus saving his life to give us the message about the incident. For example when n = 6 and m = 5 then the people will be executed in the order 5, 4, 6, 2, 3 and 1 will be saved. </p>
<p>Suppose that there are k good guys and k bad guys. In the circle the first k are good guys and the last k bad guys. You have to determine such minimal m that all the bad guys will be executed before the first good guy.</p>
<p>约瑟夫问题是臭名昭著的。对于那些不熟悉原问题的人来说：从n个人中，编号为1，2，…，n，每隔m月站成一圈就要被处死，只有最后剩下的人的生命才能得到挽救。约瑟夫很聪明地选择了最后剩下的人的位置，从而保住了他的性命，给我们带来了关于这个事件的信息。例如，当n=6，m=5时，那么人们将按5、4、6、2、3的顺序被处决，1人将获救。</p>
<p>假设有k个好人和k个坏人。在这个圈子里，前k个是好人，后k个是坏人。你必须确定这样一个最小的m，使所有的坏人都在第一个好人之前被处决。</p>
<h2 id="输入-22"><a href="#输入-22" class="headerlink" title="输入"></a>输入</h2><p>The input file consists of separate lines containing k. The last line in the input file contains 0. You can suppose that 0 &lt; k &lt; 14.</p>
<p>输入文件由包含 k 的单独行组成。输入文件的最后一行包含 0。您可以假设 0 &lt; k &lt; 14。</p>
<h2 id="输出-22"><a href="#输出-22" class="headerlink" title="输出"></a>输出</h2><p>The output file will consist of separate lines containing m corresponding to k in the input file</p>
<p>输出文件将由包含与输入文件中的 k 对应的 m 的单独行组成</p>
<h2 id="样例输入-22"><a href="#样例输入-22" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
4
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-22"><a href="#样例输出-22" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">5
30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include&lt;bits/stdc++.h&gt;
using namespace std;

bool check(int m,int k){
	int res = 0;
	for(int i=1;i&lt;=k;i++){
		res = (res + m -1) % (2*k-i+1);
		if(res &lt; k){
			return false;
		}
	}
	return true;
}

int main(){
	int k;
	while((cin &gt;&gt; k) &amp;&amp; k){
		for(int i=k+1;;i++){
			if(check(i,k) == true){
				cout &lt;&lt; i &lt;&lt; endl;
				break;
			}
		}
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-I-Factstone-Benchmark"><a href="#问题-I-Factstone-Benchmark" class="headerlink" title="问题 I: Factstone Benchmark"></a>问题 I: Factstone Benchmark</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>Amtel has announced that it will release a 128-bit computer chip by 2010, a 256-bit computer by 2020, and so on, continuing its strategy of doubling the word-size every ten years. (Amtel released a 64-bit computer in 2000, a 32-bit computer in 1990, a 16-bit computer in 1980, an 8-bit computer in 1970, and a 4-bit computer, its first, in 1960.)</p>
<p>Amtel will use a new benchmark - the <em>Factstone</em> - to advertise the vastly improved capacity of its new chips. The <em>Factstone</em> rating is defined to be the largest integer <em>n</em> such that <em>n!</em> can be represented as an unsigned integer in a computer word.</p>
<p>Given a year <em>1960 ≤ y ≤ 2160</em>, what will be the <em>Factstone</em> rating of Amtel’s most recently released chip?</p>
<p>Amtel公司已经宣布，它将在2010年之前发布128位计算机芯片，在2020年之前发布256位计算机，以此类推，继续其每十年将字数增加一倍的战略。(Amtel在2000年发布了64位计算机，1990年发布了32位计算机，1980年发布了16位计算机，1970年发布了8位计算机，1960年发布了其第一款4位计算机）。</p>
<p>Amtel公司将使用一种新的基准—Factstone—来宣传其新芯片的巨大改进的能力。Factstone评级被定义为最大的整数n，使n！可以在计算机字中表示为一个无符号整数。</p>
<p>考虑到1960≤y≤2160年，Amtel最近发布的芯片的Factstone等级将是多少？</p>
<h2 id="输入-23"><a href="#输入-23" class="headerlink" title="输入"></a>输入</h2><p>There are several test cases. For each test case, there is one line of input containing <em>y</em>. A line containing 0 follows the last test case.</p>
<p>有几个测试用例。对于每个测试用例，有一行包含 y 的输入。包含 0 的行跟随最后一个测试用例</p>
<h2 id="输出-23"><a href="#输出-23" class="headerlink" title="输出"></a>输出</h2><p>For each test case, output a line giving the Factstone rating. </p>
<p>对于每个测试用例，输出一行给出Factstone等级。</p>
<h2 id="样例输入-23"><a href="#样例输入-23" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">1960
1981
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-23"><a href="#样例输出-23" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">3
8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	while((cin &gt;&gt; n) &amp;&amp; n){
		double  a = log2(4.0);
		for (int i = 1960; i &lt;= n; i += 10)
			a *= 2;
		double  f = 0;
		int i = 0;
		while(f &lt; a)
		{
			++i;
			f += log2(double(i));
		}
		cout &lt;&lt; i - 1 &lt;&lt; endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-J-Ants"><a href="#问题-J-Ants" class="headerlink" title="问题 J: Ants"></a>问题 J: Ants</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>An army of ants walk on a horizontal pole of length <em>l</em> cm, each with a constant speed of 1 cm/s. When a walking ant reaches an end of the pole, it immediatelly falls off it. When two ants meet they turn back and start walking in opposite directions. We know the original positions of ants on the pole, unfortunately, we do not know the directions in which the ants are walking. Your task is to compute the earliest and the latest possible times needed for all ants to fall off the pole. </p>
<p>一群蚂蚁走在一根长为 l cm 的水平杆上，每支蚂蚁以 1 cm/s 的恒定速度行走。当一只行走的蚂蚁到达杆子的末端时，它会立即从杆子上掉下来。当两只蚂蚁相遇时，它们会转身向相反的方向走。我们知道蚂蚁在杆子上的原始位置，不幸的是，我们不知道蚂蚁行走的方向。你的任务是计算所有蚂蚁从杆子上掉下来所需的最早和最晚时间。</p>
<h2 id="输入-24"><a href="#输入-24" class="headerlink" title="输入"></a>输入</h2><p>The first line of input contains one integer giving the number of cases that follow. The data for each case start with two integer numbers: the length of the pole (in cm) and <em>n</em>, the number of ants residing on the pole. These two numbers are followed by <em>n</em> integers giving the position of each ant on the pole as the distance measured from the left end of the pole, in no particular order. All input integers are not bigger than 1000000 and they are separated by whitespace. </p>
<p>输入的第一行包含一个整数，给出后面的案例数。每个案例的数据都以两个整数开始：杆的长度（以厘米为单位）和 n，杆上的蚂蚁数量。这两个数字后跟 n 个整数，表示每只蚂蚁在杆子上的位置，即从杆子左端测量的距离，没有特定的顺序。所有输入的整数都不大于 1000000，并且它们以空格分隔。</p>
<h2 id="输出-24"><a href="#输出-24" class="headerlink" title="输出"></a>输出</h2><p>For each case of input, output two numbers separated by a single space. The first number is the earliest possible time when all ants fall off the pole (if the directions of their walks are chosen appropriately) and the second number is the latest possible such time.</p>
<p>对于输入的每种情况，输出由单个空格分隔的两个数字。第一个数字是所有蚂蚁从杆子上掉下来的最早时间（如果它们的行走方向选择得当），第二个数字是最晚的时间。</p>
<h2 id="样例输入-24"><a href="#样例输入-24" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2
10 3
2 6 7
214 7
11 12 7 13 176 23 191<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-24"><a href="#样例输出-24" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4 8
38 207<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><p><code>Min=max(Min,min(a[i],L-a[i]));</code></p>
<p><code>Max=max(Max,max(a[i],L-a[i]));</code></p>
<h2 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;


int main(){
	int t;
	cin &gt;&gt; t;
	while(t--){
		int l,n;
		cin &gt;&gt; l &gt;&gt; n;
		vector&lt;int&gt; ants(n,0);
		for(int i=0;i&lt;n;i++){
			cin &gt;&gt; ants[i];
		}
		int Max = 0, Min = 0;
		for(int i=0;i&lt;n;i++){
			Min = max(Min,min(ants[i],l-ants[i]));
			Max = max(Max,max(ants[i],l-ants[i]));
		}
		cout &lt;&lt; Min &lt;&lt; " " &lt;&lt; Max &lt;&lt; endl;
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-K-Matches-Game"><a href="#问题-K-Matches-Game" class="headerlink" title="问题 K: Matches Game"></a>问题 K: Matches Game</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 64 MB</p>
<h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>Here is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a player’s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not. </p>
<p>这是一个简单的游戏。在这场比赛中，有几堆比赛和两名球员。两个玩家轮流玩。在每一回合中，可以选择一堆并从堆中带走任意数量的火柴（当然，被带走的火柴数量不能为零，也不能大于所选堆中的火柴数量）。如果在轮到玩家之后，没有剩余比赛，则该玩家为赢家。假设两个玩家都非常清楚。你的工作是判断先玩的玩家能否赢得比赛。</p>
<h2 id="输入-25"><a href="#输入-25" class="headerlink" title="输入"></a>输入</h2><p>The input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 &lt;= M &lt;=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.</p>
<p>输入由几行组成，每行都有一个测试用例。在一行的开头，有一个整数M（1 &lt;= M &lt;=20），就是桩的数量。然后是M个正整数，不大于10000000。这M个整数代表每堆匹配的数量。</p>
<h2 id="输出-25"><a href="#输出-25" class="headerlink" title="输出"></a>输出</h2><p>For each test case, output “Yes” in a single line, if the player who play first will win, otherwise output “No”.</p>
<p>对于每个测试用例，单行输出“Yes”，如果先玩的玩家获胜，否则输出“No”。</p>
<h2 id="样例输入-25"><a href="#样例输入-25" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 45 45
3 3 6 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-25"><a href="#样例输出-25" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">No
Yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><p>这题有问题，我一直感觉学算法，优化应该在熟悉证明上，在算法复杂度上进行优化，而不是在语言效率，底层输入输出上。</p>
<h2 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h2><h3 id="c-过不了"><a href="#c-过不了" class="headerlink" title="c++过不了"></a>c++过不了</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int m;
	while(~scanf("%d",&amp;m)){
		int flag = 0;
		long long x;
		for(int i=0;i&lt;m;i++){
			cin &gt;&gt; x;
			flag ^= x;
		}
		if(flag) 
			cout &lt;&lt; "Yes" &lt;&lt; endl;
		else
			cout &lt;&lt; "No" &lt;&lt; endl; 
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="c就能过"><a href="#c就能过" class="headerlink" title="c就能过"></a>c就能过</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            flag<span class="token operator">^=</span>x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Yes\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-L-sort2"><a href="#问题-L-sort2" class="headerlink" title="问题 L: sort2"></a>问题 L: sort2</h1><p>时间限制: 1 Sec</p>
<p>内存限制: 64 MB</p>
<h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你n个整数，请按从大到小的顺序输出其中前m大的数。</p>
<h2 id="输入-26"><a href="#输入-26" class="headerlink" title="输入"></a>输入</h2><p>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个都处于区间[-500000,500000]的整数，<strong><em>整数可能会重复出现\</em></strong>。</p>
<h2 id="输出-26"><a href="#输出-26" class="headerlink" title="输出"></a>输出</h2><p>对每组测试数据按从大到小的顺序输出前m大的数。</p>
<h2 id="样例输入-26"><a href="#样例输入-26" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">10 5
1 2 3 4 5 6 7 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-26"><a href="#样例输出-26" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">9 8 7 7 6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h2><h3 id="直接sort超时"><a href="#直接sort超时" class="headerlink" title="直接sort超时"></a>直接sort超时</h3><h3 id="map超时"><a href="#map超时" class="headerlink" title="map超时"></a>map超时</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int nums[1000001];


int main(){
	int n,m;
	cin &gt;&gt; n &gt;&gt; m;
	map&lt;int,int&gt; mp;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
		if(mp.find(nums[i]) != mp.end()){
			mp[nums[i]]++;
		}
		mp.insert(pair&lt;int,int&gt;(nums[i],1));
	}
	int i = 0;
	for(auto num : mp){
		while(num.second){
			nums[i] = num.first;
			num.second--;
			i++;
		}
	}
	for(int i=n-1;i&gt;n-m-1;i--){
		cout &lt;&lt; nums[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int offset = 500000;
int Hash[1000001] = {0};
int main(){
	int m,n;
	while(cin &gt;&gt; n &gt;&gt; m){
		for(int i=0;i&lt;n;i++){
			int x;
			cin &gt;&gt; x;
			Hash[x+offset]++;
		}
		for(int i=offset;i&gt;=-offset &amp;&amp; m &gt; 0;i--){
			while(Hash[i+offset] &gt; 0 &amp;&amp; m &gt; 0){
				cout &lt;&lt; i &lt;&lt; " ";
				Hash[i+offset]--;
				m--;
			}
		}
		cout &lt;&lt; endl;
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h1><h1 id="问题-A-单词排序"><a href="#问题-A-单词排序" class="headerlink" title="问题 A: 单词排序"></a>问题 A: 单词排序</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>小红学会了很多英文单词，妈妈为了帮小红加强记忆，拿出纸、笔，把 N 个单词写在纸上的一行里，小红看了几秒钟后，将这张纸扣在桌子上。妈妈问小红：“你能否将这 N 个单词按照字典排列的顺序，从小到大写出来？”小红按照妈妈的要求写出了答案。现在请你编写程序帮助妈妈检查小红的答案是否正确。注意：所有单词都由小写字母组成，单词两两之间用一个空格分隔。</p>
<h2 id="输入-27"><a href="#输入-27" class="headerlink" title="输入"></a>输入</h2><p>输入包含两行。</p>
<p>第一行仅包括一个正整数N(0&lt;N≤26)。</p>
<p>第二行包含N个单词，表示妈妈写出的单词，两两之间用一个空格分隔。</p>
<p>单个单词长度不超过1010。</p>
<h2 id="输出-27"><a href="#输出-27" class="headerlink" title="输出"></a>输出</h2><p>输出仅有一行。针对妈妈写出的单词，按照字典排列的顺序从小到大排列成一行的结果，每个单词后带一个空格。</p>
<h2 id="样例输入-27"><a href="#样例输入-27" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4
city boy tree student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-27"><a href="#样例输出-27" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">boy city student tree <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;string&gt; strs;
	for(int i=0;i&lt;n;i++){
		string str;
		cin &gt;&gt; str;
		strs.push_back(str);
	}
	sort(strs.begin(),strs.end());
	for(int i=0;i&lt;n;i++){
		cout &lt;&lt; strs[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-B-求数组的最长递减子序列"><a href="#问题-B-求数组的最长递减子序列" class="headerlink" title="问题 B: 求数组的最长递减子序列"></a>问题 B: 求数组的最长递减子序列</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数序列，输出它的最长递减（注意不是“不递增”）子序列。</p>
<h2 id="输入-28"><a href="#输入-28" class="headerlink" title="输入"></a>输入</h2><p>输入包括两行，第一行包括一个正整数N（N&lt;=1000），表示输入的整数序列的长度。第二行包括用空格分隔开的N个整数，整数范围区间为[-30000,30000]。</p>
<h2 id="输出-28"><a href="#输出-28" class="headerlink" title="输出"></a>输出</h2><p>输出最长递减子序列，数字之间有一个空格。</p>
<h2 id="样例输入-28"><a href="#样例输入-28" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">8
9 4 3 2 5 4 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-28"><a href="#样例输出-28" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">9 5 4 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>求个数很简单，但最后输出的是序列数组，这个比较麻烦。</p>
<p>前面求出dp动态数组和最大值，顺便记录最大值的下表和值</p>
<p>以及每一步的前面的下表，方便后面循环查找。</p>
<h2 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	vector&lt;int&gt; dp(n,1);
	vector&lt;int&gt; track(n,-1);
	int result = 0;
	int rp = -1;
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;i;j++){
			if((nums[i] &lt; nums[j]) &amp;&amp; dp[j]+1 &gt; dp[i]){
				dp[i] = dp[j] + 1;
				track[i] = j;
			}
			if(dp[i] &gt; result){
				result = dp[i];
				rp = i;
			}
		}
	}
	vector&lt;int&gt; ans;
	for(int i=result;i&gt;0;i--){
		ans.push_back(nums[rp]);
		if(track[rp] == -1)
			break;
		rp = track[rp];
	}
	for(int i=ans.size()-1;i&gt;=0;i--){
		cout &lt;&lt; ans[i] &lt;&lt; " ";
	}
	cout &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-C-矩形滑雪场"><a href="#问题-C-矩形滑雪场" class="headerlink" title="问题 C: 矩形滑雪场"></a>问题 C: 矩形滑雪场</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>zcb喜欢滑雪。他来到了一个滑雪场，这个滑雪场是一个矩形，为了简便，我们用r行c列的矩阵来表示每块地形。为了得到更快的速度，滑行的路线必须向下倾斜。 例如样例中的那个矩形，可以从某个点滑向上下左右四个相邻的点之一。例如24-17-16-1，其实25-24-23…3-2-1更长，事实上这是最长的一条。</p>
<h2 id="输入-29"><a href="#输入-29" class="headerlink" title="输入"></a>输入</h2><p>第1行:两个数字r，c(1 ≤ r, c ≤ 100)，表示矩阵的行列。第2..r+1行:每行c个数，表示这个矩阵。</p>
<h2 id="输出-29"><a href="#输出-29" class="headerlink" title="输出"></a>输出</h2><p>仅一行:输出1个整数，表示可以滑行的最大长度。</p>
<h2 id="样例输入-29"><a href="#样例输入-29" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-29"><a href="#样例输出-29" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><p>有点难，dfs搜索应该可以</p>
<p>这里还是那动态规划，把这个看成大型的二维的最长递减序列。</p>
<h2 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> #include&lt;bits/stdc++.h&gt;
using namespace std;

struct node{
	int x;
	int y;
	int n;
};

bool cmp(node a,node b)
{
    return a.n&lt;b.n;
}

//node nums[100005];

int main(){
	int m,n;
	cin &gt;&gt; m &gt;&gt; n;
	vector&lt;node&gt; nums(m*n);
	int index = 0;
	for(int i=0;i&lt;m;i++){
		for(int j=0;j&lt;n;j++){
			cin &gt;&gt; nums[index].n;
			nums[index].x = i;
			nums[index].y = j;
			index++;
		}
	}
	sort(nums.begin(),nums.end(),cmp);
	//大型的最长递减子序列
	int result = 0;
	vector&lt;int&gt; dp(index,1);
	for(int i=0;i&lt;index;i++){
		for(int j=0;j&lt;i;j++){
			//这里判断条件改成前后左右
			if(((nums[i].x==nums[j].x &amp;&amp; abs(nums[i].y-nums[j].y)==1) || (nums[i].y==nums[j].y &amp;&amp; abs(nums[i].x-nums[j].x)==1)) &amp;&amp; nums[i].n &gt; nums[j].n){
				dp[i] = max(dp[i],dp[j]+1);
			}
			if(dp[i] &gt; result){
				result = dp[i];
			}

		}
	}
	cout &lt;&lt; result &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

struct node{
	int x,y,h;
};

bool cmp(node a,node b){
	return a.h &lt; b.h;
}

node nums[999999];


int main(){
	int r,c;
	cin &gt;&gt; r &gt;&gt; c;
	int n = 0;
	for(int i=0;i&lt;r;i++){
		for(int j=0;j&lt;c;j++){
			cin &gt;&gt; nums[n].h;
			nums[n].x = i;
			nums[n].y = j;
			n++;
 		}
	}
	sort(nums,nums+n,cmp);
	vector&lt;int&gt; dp(n,1);
	int result = 0;
	for(int i=0;i&lt;n;i++){
		for(int j=0;j&lt;i;j++){
			if((nums[i].h &gt; nums[j].h) &amp;&amp; (abs(nums[i].x-nums[j].x) + abs(nums[i].y-nums[j].y)) == 1){
				dp[i] = max(dp[i],dp[j]+1);
			}
			if(dp[i] &gt; result){
				result = dp[i];
			}
		}
	}
	cout &lt;&lt; result &lt;&lt; endl;
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-D-Homework"><a href="#问题-D-Homework" class="headerlink" title="问题 D: Homework"></a>问题 D: Homework</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>临近开学了，大家都忙着收拾行李准 备返校，但 I_Love_C 却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动。</p>
<p>暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。如果有 5 张试卷，其中 4 张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前 4 张长很多。但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。</p>
<p>I_Love_C决定就用这样的方法来蒙混过关，他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。</p>
<p>现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p>
<h2 id="输入-30"><a href="#输入-30" class="headerlink" title="输入"></a>输入</h2><p>测试数据包括多组。每组测试数据以两个整数 M,N(1&lt;M&lt;20,1&lt;N&lt;10000) 开头，分别表示试卷的数目和 I_Love_C 剩下的时间。接下来有 M 行，每行包括两个整数 T,V(1&lt;T&lt;N,1&lt;V&lt;10000)分别表示做完这张试卷所需的时间以及做完后能得到的价值，输入以 0 0 结束。</p>
<h2 id="输出-30"><a href="#输出-30" class="headerlink" title="输出"></a>输出</h2><p>对应每组测试数据输出 I_Love_C 能获得的最大价值。保留小数点 2 位</p>
<p>提示：float 的精度可能不够，你应该使用 double 类型。</p>
<h2 id="样例输入-30"><a href="#样例输入-30" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 20
4 10
5 22
10 3
1 2
0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-30"><a href="#样例输出-30" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">37.00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool cmp(vector&lt;double&gt;a,vector&lt;double&gt; b){
	return a[2] &gt; b[2];
}

int main(){
	int m,n;
	while(cin &gt;&gt; m &gt;&gt; n){
		if(m == 0 &amp;&amp; n ==0){
			break;
		}
		vector&lt;vector&lt;double&gt;&gt; homework(m,vector&lt;double&gt;(3,0));
		for(int i=0;i&lt;m;i++){
			cin &gt;&gt; homework[i][0] &gt;&gt; homework[i][1];
			homework[i][2] = homework[i][1] / homework[i][0];
		}
		sort(homework.begin(),homework.end(),cmp);
		double ans = 0; 
		for(int i=0;i&lt;n;i++){
			if(n &gt; homework[i][0]){
				ans += homework[i][1];
				n -= homework[i][0];
			}
			else{
				ans += homework[i][2] * n;
				break;
			}
		}
		printf("%.2lf\n",ans);
		
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-E-区间包含问题"><a href="#问题-E-区间包含问题" class="headerlink" title="问题 E: 区间包含问题"></a>问题 E: 区间包含问题</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知 n 个左闭右开区间 [a,b)，对其进行 m 次询问，求区间[l,r]最多可以包含 n 个区间中的多少个区间，并且被包含的所有区间都不相交。</p>
<h2 id="输入-31"><a href="#输入-31" class="headerlink" title="输入"></a>输入</h2><p>输入包含多组测试数据，对于每组测试数据：</p>
<p>第一行包含两个整数 n ,m (1≤n≤100000,1≤m≤100) 。</p>
<p>接下来 n 行每行包含两个整数 a ,b (0≤a&lt;b≤10^9) 。</p>
<p>接下来 m 行每行包含两个整数 l ,r (0≤l&lt;r≤10^9) 。</p>
<h2 id="输出-31"><a href="#输出-31" class="headerlink" title="输出"></a>输出</h2><p>对于每组测试数据，输出 m 行，每行包含一个整数。</p>
<p>数据过大请使用快速输入输出。</p>
<h2 id="样例输入-31"><a href="#样例输入-31" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4 3
1 3
2 4
1 4
1 2
1 2
1 3
1 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-31"><a href="#样例输出-31" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">1
1
2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><p>就是右端点小排序</p>
<p>优先选取满足小区间</p>
<h2 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool cmp(vector&lt;int&gt; a, vector&lt;int&gt; b){
	return a[1] &lt; b[1];
}

int main(){
	int n, m;
	while(cin &gt;&gt; n &gt;&gt; m){
		vector&lt;vector&lt;int&gt;&gt; point(n,vector&lt;int&gt;(2,0));
		for(int i=0;i&lt;n;i++){
			cin &gt;&gt; point[i][0] &gt;&gt; point[i][1];
		}
		sort(point.begin(),point.end(),cmp);
		while(m--){
			int left,right;
			cin &gt;&gt; left &gt;&gt; right;
			int ans = 0;
			for(int i=0;i&lt;n;i++){
				if(point[i][1] &gt; right){
					break;
				}
				if(left &lt;= point[i][0]){
					left = point[i][1];
					ans++;
				}
			}
			cout &lt;&lt; ans &lt;&lt; endl;
		}
	}
	return 0;
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-F-最长子序列"><a href="#问题-F-最长子序列" class="headerlink" title="问题 F: 最长子序列"></a>问题 F: 最长子序列</h1><p>时间限制: 1 Sec 内存限制: 128 MB</p>
<h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个数组中找出和最大的连续几个数。（至少包含一个数）</p>
<p>例如：</p>
<p>数组A[] = [-2,1,-3,4,-1,2,1,-5,4]，则连续的子序列[4,-1,2,1]有最大的和6.</p>
<h2 id="输入-32"><a href="#输入-32" class="headerlink" title="输入"></a>输入</h2><p>第一行输入一个不超过1000的整数n。</p>
<p>第二行输入n个整数A[i]。</p>
<h2 id="输出-32"><a href="#输出-32" class="headerlink" title="输出"></a>输出</h2><p>输出一个整数，表示最大的和。</p>
<h2 id="样例输入-32"><a href="#样例输入-32" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">3
1 1 -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="样例输出-32"><a href="#样例输出-32" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; nums(n,0);
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; nums[i];
	}
	int sum = 0;
	int ans = INT_MIN;
	for(int i=0;i&lt;n;i++){
		sum += nums[i];
		if(sum &gt; ans){
			ans = sum;
		}
		if(sum &lt; 0){
			sum = 0;
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-G-元素整除问题"><a href="#问题-G-元素整除问题" class="headerlink" title="问题 G: 元素整除问题"></a>问题 G: 元素整除问题</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入20个整数，输出其中能被数组中其它元素整除的那些数组元素。</p>
<h2 id="输入-33"><a href="#输入-33" class="headerlink" title="输入"></a>输入</h2><p>输入20个整数</p>
<h2 id="输出-33"><a href="#输出-33" class="headerlink" title="输出"></a>输出</h2><p>按输入顺序输出符合要求的数字，每行输出一个整数。</p>
<h2 id="样例输入-33"><a href="#样例输入-33" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="样例输出-33"><a href="#样例输出-33" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">4
6
8
9
10
12
14
15
16
18
20
21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main(){
    vector&lt;int&gt; nums(20,0);
    for(int i=0;i&lt;20;i++){
        cin &gt;&gt; nums[i];
    }
    for(int i=0;i&lt;20;i++){
        bool flag = false;
        for(int j=0;j&lt;20;j++){
            if(i == j){
                continue;
            }
            if((nums[i] % nums[j]) == 0){
                flag = true;
            }
        }
        if(flag){
            cout &lt;&lt; nums[i] &lt;&lt;endl;
        }
    }
    return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-H-渊子赛马"><a href="#问题-H-渊子赛马" class="headerlink" title="问题 H: 渊子赛马"></a>问题 H: 渊子赛马</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 128 MB</p>
<h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为“战国时期”。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。 赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：“下次有机会带我到马场看看，也许我能帮你。” 孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有 N(1&lt;=n&lt;=1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p>
<h2 id="输入-34"><a href="#输入-34" class="headerlink" title="输入"></a>输入</h2><p>输入有多组测试数据。 每组测试数据包括 3 行： 第一行输入 N。表示马的数量。 第二行有 N 个整型数字，即渊子的 N 匹马的速度。 第三行有 N 个整型数字，即对手的 N 匹马的速度。 当 N 为 0 时退出。</p>
<h2 id="输出-34"><a href="#输出-34" class="headerlink" title="输出"></a>输出</h2><p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出YES。 否则输出NO。</p>
<h2 id="样例输入-34"><a href="#样例输入-34" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">5
2 3 3 4 5
1 2 3 4 5
4
2 2 1 2
2 2 3 1
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-34"><a href="#样例输出-34" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">YES
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><p>贪心吧</p>
<p>先分别排序，看<code>a[i] &gt; b[j]</code>  如果大于那就赢了一把，敌方换马，如果一直没赢，因为从大到小排序，证明后面也赢不了。</p>
<p>切记记录失败次数。</p>
<h2 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	int n;
	while((cin &gt;&gt; n) &amp;&amp; n){
		vector&lt;int&gt; a(n,0);
		vector&lt;int&gt; b(n,0);
		for(int i=0;i&lt;n;i++){
			cin &gt;&gt; a[i];
		}
		for(int i=0;i&lt;n;i++){
			cin &gt;&gt; b[i];
		}
		sort(a.begin(),a.end());
		sort(b.begin(),b.end());
		int cnt1 =0, cnt2 = 0;
		int j = 0;
		for(int i=0;i&lt;n;i++){
			if(a[i] &gt; b[j]){
				cnt1++;
				j++;
			}
			else{
				cnt2++;
			}
		}
		if(cnt1 &gt; cnt2){
			cout &lt;&lt; "YES" &lt;&lt; endl;
		}
		else{
			cout &lt;&lt; "NO" &lt;&lt; endl;
		}		
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-I-The-Hardest-Problem-Ever"><a href="#问题-I-The-Hardest-Problem-Ever" class="headerlink" title="问题 I: The Hardest Problem Ever"></a>问题 I: The Hardest Problem Ever</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 32 MB</p>
<h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>Julius Caesar lived in a time of danger and intrigue. The hardest situation Caesar ever faced was keeping himself alive. In order for him to survive, he decided to create one of the first ciphers. This cipher was so incredibly sound, that no one could figure it out without knowing how it worked. </p>
<p>You are a sub captain of Caesar’s army. It is your job to decipher the messages sent by Caesar and provide to your general. The code is simple. For each letter in a plaintext message, you shift it five places to the right to create the secure message (i.e., if the letter is ‘A’, the cipher text would be ‘F’). Since you are creating plain text out of Caesar’s messages, you will do the opposite: </p>
<p>Cipher text<br>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z </p>
<p>Plain text<br>V W X Y Z A B C D E F G H I J K L M N O P Q R S T U </p>
<p>Only letters are shifted in this cipher. Any non-alphabetical character should remain the same, and all alphabetical characters will be upper case.</p>
<p>朱利叶斯·凯撒生活在一个充满危险和阴谋的时代。凯撒面临的最艰难的情况是让自己活着。为了让他活下来，他决定创造第一个密码。这个密码非常可靠，如果不知道它是如何工作的，就没有人能猜出它。</p>
<p>你是凯撒军队的副队长。你的工作是破译凯撒发送的信息并提供给你的将军。代码很简单。对于明文消息中的每个字母，您将其向右移动五位以创建安全消息（即，如果字母是“A”，则密文将是“F”）。由于您是从 Caesar 的消息中创建纯文本，因此您将执行相反的操作：</p>
<p>密文</p>
<p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p>
<p>纯文本</p>
<p>V W X Y Z A B C D E F G H I J K L M N O P Q R S T U</p>
<p>在这个密码中只有字母被移位。任何非字母字符都应保持不变，所有字母字符都将大写。</p>
<h2 id="输入-35"><a href="#输入-35" class="headerlink" title="输入"></a>输入</h2><p>Input to this problem will consist of a (non-empty) series of up to 100 data sets. Each data set will be formatted according to the following description, and there will be no blank lines separating data sets. All characters will be uppercase. </p>
<p>A single data set has 3 components: </p>
<ol>
<li>Start line - A single line, “START” </li>
<li>Cipher message - A single line containing from one to two hundred characters, inclusive, comprising a single message from Caesar </li>
<li>End line - A single line, “END” </li>
</ol>
<p>Following the final data set will be a single line, “ENDOFINPUT”. </p>
<p>此问题的输入将包含最多 100 个数据集的（非空）系列。每个数据集将根据以下描述进行格式化，并且不会有分隔数据集的空行。所有字符都将大写。</p>
<p>单个数据集有 3 个组成部分：</p>
<p>起始行 - 单行，“START”</p>
<p>密码消息 - 一行包含 1 到 200 个字符（含），包含来自 Caesar 的单个消息</p>
<p>结束行 - 单行，“END”</p>
<p>在最终数据集之后将是一行，“ENDOFINPUT”。</p>
<h2 id="输出-35"><a href="#输出-35" class="headerlink" title="输出"></a>输出</h2><p>For each data set, there will be exactly one line of output. This is the original message by Caesar.</p>
<p>对于每个数据集，只会有一行输出。这是凯撒的原始信息。</p>
<h2 id="样例输入-35"><a href="#样例输入-35" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">START
NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX
END
START
N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ
END
START
IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ
END
ENDOFINPUT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-35"><a href="#样例输出-35" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES
I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME
DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><p>凯撒加密，难度上没啥，就是控制输入输出得调试。</p>
<h2 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;

int main(){
	string str;
	while(1){
		cin &gt;&gt; str;
		if(str == "ENDOFINPUT"){
			break;
		}
		else if(str == "START"){
			cin &gt;&gt; str;
			string s;
			getline(cin,s);
			s = str + s;
			string c;
			for(int i=0;i &lt; s.size();i++){
				if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z'){
					c.push_back((s[i] - 'A'+26-5)%26 + 'A');
				}
				else{
					c.push_back(s[i]);
				}
			}
			cout &lt;&lt; c &lt;&lt; endl;
		}
		else if(str == "END"){
			continue;
		}
	}
	return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="问题-J-Rock-Paper-Scissors-Tournament"><a href="#问题-J-Rock-Paper-Scissors-Tournament" class="headerlink" title="问题 J: Rock-Paper-Scissors Tournament"></a>问题 J: Rock-Paper-Scissors Tournament</h1><p>时间限制: 3 Sec </p>
<p>内存限制: 64 MB</p>
<h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>Rock-Paper-Scissors is game for two players, A and B, who each choose, independently of the other, one of rock, paper, or scissors. A player chosing paper wins over a player chosing rock; a player chosing scissors wins over a player chosing paper; a player chosing rock wins over a player chosing scissors. A player chosing the same thing as the other player neither wins nor loses.<br>A tournament has been organized in which each of n players plays k rock-scissors-paper games with each of the other players - k<em>n</em>(n-1)/2 games in total. Your job is to compute the win average for each player, defined as w / (w + l) where w is the number of games won, and l is the number of games lost, by the player. </p>
<p>Rock-Paper-Scissors 是 A 和 B 两个玩家的游戏，他们各自独立地选择石头、纸或剪刀之一。选择纸的玩家胜过选择石头的玩家；选择剪刀的玩家胜过选择纸的玩家；选择石头的玩家胜过选择剪刀的玩家。与其他玩家选择相同事物的玩家既不会赢也不会输。</p>
<p>已经组织了一个锦标赛，其中 n 个玩家中的每一个与其他每个玩家玩 k 个石头剪刀布游戏 - 总共 k<em>n</em>(n-1)/2 个游戏。您的工作是计算每个玩家的平均获胜次数，定义为 w / (w + l)，其中 w 是该玩家赢得的游戏数量，l 是该玩家输掉的游戏数量。</p>
<h2 id="输入-36"><a href="#输入-36" class="headerlink" title="输入"></a>输入</h2><p>Input consists of several test cases. The first line of input for each case contains 1 &lt;= n &lt;= 100 1 &lt;= k &lt;= 100 as defined above. For each game, a line follows containing p1, m1, p2, m2. 1 &lt;= p1 &lt;= n and 1 &lt;= p2 &lt;= n are distinct integers identifying two players; m1 and m2 are their respective moves (“rock”, “scissors”, or “paper”). A line containing 0 follows the last test case.</p>
<p>输入由几个测试用例组成。每个案例的第一行输入包含 1 &lt;= n &lt;= 100 1 &lt;= k &lt;= 100，如上所定义。对于每个游戏，后面有一行包含 p1、m1、p2、m2。 1 &lt;= p1 &lt;= n 和 1 &lt;= p2 &lt;= n 是识别两个玩家的不同整数； m1 和 m2 是它们各自的移动（“石头”、“剪刀”或“纸”）。包含 0 的行跟随最后一个测试用例。</p>
<h2 id="输出-36"><a href="#输出-36" class="headerlink" title="输出"></a>输出</h2><p>Output one line each for player 1, player 2, and so on, through player n, giving the player’s win average rounded to three decimal places. If the win average is undefined, output “-“. Output an empty line between cases.</p>
<p>为玩家 1、玩家 2 等输出一行，通过玩家 n，将玩家的胜利平均值四舍五入到小数点后三位。如果未定义获胜平均值，则输出“-”。在案例之间输出一个空行。</p>
<h2 id="样例输入-36"><a href="#样例输入-36" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">2 4
1 rock 2 paper
1 scissors 2 paper
1 rock 2 rock
2 rock 1 scissors
2 1
1 rock 2 paper
0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-36"><a href="#样例输出-36" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">0.333
0.667

0.000
1.000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><h2 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h2><h1 id="问题-K-Balloon-Robot"><a href="#问题-K-Balloon-Robot" class="headerlink" title="问题 K: Balloon Robot"></a>问题 K: Balloon Robot</h1><p>时间限制: 1 Sec </p>
<p>内存限制: 64 MB</p>
<h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>The 2017 China Collegiate Programming Contest Qinhuangdao Site is coming! There will be (n) teams participating in the contest, and the contest will be held on a huge round table with (m) seats numbered from 1 to (m) in clockwise order around it. The (i)-th team will be seated on the (s_i)-th seat.</p>
<p>BaoBao, an enthusiast for competitive programming, has made (p) predictions of the contest result before the contest. Each prediction is in the form of ((a_i,b_i)), which means the (a_i)-th team solves a problem during the (b_i)-th time unit.</p>
<p>As we know, when a team solves a problem, a balloon will be rewarded to that team. The participants will be unhappy if the balloons take almost centuries to come. If a team solves a problem during the (t_a)-th time unit, and the balloon is sent to them during the (t_b)-th time unit, then the unhappiness of the team will increase by (t_b-t_a). In order to give out balloons timely, the organizers of the contest have bought a balloon robot.</p>
<p>At the beginning of the contest (that is to say, at the beginning of the 1st time unit), the robot will be put on the (k)-th seat and begin to move around the table. If the robot moves past a team which has won themselves some balloons after the robot’s last visit, it will give all the balloons they deserve to the team. During each unit of time, the following events will happen <strong>in order</strong>:</p>
<ol>
<li>The robot moves to the next seat. That is to say, if the robot is currently on the (i)-th ((1 \le i &lt; m)) seat, it will move to the ((i+1))-th seat; If the robot is currently on the (m)-th seat, it will move to the 1st seat.</li>
<li>The participants solve some problems according to BaoBao’s prediction.</li>
<li>The robot gives out balloons to the team seated on its current position if needed.</li>
</ol>
<p>BaoBao is interested in minimizing the total unhappiness of all the teams. Your task is to select the starting position (k) of the robot and calculate the minimum total unhappiness of all the teams according to BaoBao’s predictions.</p>
<h2 id="输入-37"><a href="#输入-37" class="headerlink" title="输入"></a>输入</h2><p>There are multiple test cases. The first line of the input contains an integer T, indicating the number of test cases. For each test case:</p>
<p>The first line contains three integers (n), (m) and (p) ((1 \le n \le 10^5), (n \le m \le 10^9), (1 \le p \le 10^5)), indicating the number of participating teams, the number of seats and the number of predictions.</p>
<p>The second line contains (n) integers (s_1, s_2, \dots, s_n) ((1 \le s_i \le m), and (s_i \ne s_j) for all (i \ne j)), indicating the seat number of each team.</p>
<p>The following (p) lines each contains two integers (a_i) and (b_i) ((1 \le a_i \le n), (1 \le b_i \le 10^9)), indicating that the (a_i)-th team solves a problem at time (b_i) according to BaoBao’s predictions.</p>
<p>It is guaranteed that neither the sum of (n) nor the sum of (p) over all test cases will exceed (5 \times 10^5).</p>
<h2 id="输出-37"><a href="#输出-37" class="headerlink" title="输出"></a>输出</h2><p>For each test case output one integer, indicating the minimum total unhappiness of all the teams according to BaoBao’s predictions.</p>
<h2 id="样例输入-37"><a href="#样例输入-37" class="headerlink" title="样例输入"></a>样例输入</h2><pre class="line-numbers language-none"><code class="language-none">4
2 3 3
1 2
1 1
2 1
1 4
2 3 5
1 2
1 1
2 1
1 2
1 3
1 4
3 7 5
3 5 7
1 5
2 1
3 3
1 5
2 5
2 100 2
1 51
1 500
2 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="样例输出-37"><a href="#样例输出-37" class="headerlink" title="样例输出"></a>样例输出</h2><pre class="line-numbers language-none"><code class="language-none">1
4
5
50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2>
                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LowlyLi</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://lcy5201314.top/2021/11/17/suan-fa-shi-yan/">http://lcy5201314.top/2021/11/17/suan-fa-shi-yan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LowlyLi</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AE%97%E6%B3%95/">
                                    <span class="chip bg-color">算法</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'KrP8LCvOkNLeKYOzomaIagbA-gzGzoHsz',
        appKey: 'tOTYSpmIAEnlWHbIzwFx73iX',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/11/18/suan-fa-li-lun-fu-xi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="算法理论复习">
                        
                        <span class="card-title">算法理论复习</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            信安算法理论复习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">
                                    算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/11/15/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            欢迎访问我的博客
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%97%A5%E5%B8%B8/" class="post-category">
                                    日常
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%97%A5%E5%B8%B8/">
                        <span class="chip bg-color">日常</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 秋月日常<br />'
            + '文章作者: LowlyLi<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">LowlyLi</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "11";
                    var startDate = "15";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/lcy5201314" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:543797538@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=543797538" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 543797538" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/wczxzppxuvj3litzyyta1w2asmyg4dus.js"></script>
        <script>
            $(document).ready(function () {
                setInterval(change_Tidio, 50);
                function change_Tidio() {
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";
                        document.getElementById("tidio-chat-iframe").style.right="-15px";
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;
                        document.getElementById("tidio-chat-iframe").style.right="-15px";
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                }
            });
        </script>
    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <!-- 樱花 -->
    <script type="text/javascript">
        // 只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
    </script>
        


</body>

</html>
